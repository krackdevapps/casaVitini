const transaccion = entrada.body.transaccion;
    if (!transaccion) {
        try {
            const error = "No se ha definido la 'transaccion'"
            throw new Error(error)

        } catch (errorCapturado) {
            const error = {
               error: errorCapturado.message
            }
            salida.json(error)
        }

    }


    if (transaccion === "cambiarVista") {

        try {
            const vista = entrada.body.vista
            if (!vista) {
                const error = "Tienes que definir 'Vista' con el nombre de la vista"
                throw new Error(error)
            }
            const filtroSeguridad = new RegExp('[^A-Za-z0-9/_-]', 'g');
            const resultadoFitlrado = filtroSeguridad.test(vista)
            if (resultadoFitlrado) {
                const error = {
                    "error": "Solo se acepta letras y numeros, nada mas"
                }
                //  return salida.json(error)

            }
            //  entrada.session.VitiniID = "TESTEST"
            // 

            const transaccion = {
                "vista": vista,
                "usuario": entrada.session.usuario,
                "rol": entrada.session.rol
            }
            const transaccionInterna = await cambiarVista(transaccion)

            return salida.json(transaccionInterna)
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }


    }
    if (transaccion === "calendario") {

        try {
            let tipo = entrada.body.tipo
            if (tipo === "actual") {

                let fechaActual = new Date();
                let anoActual = fechaActual.getFullYear();
                let mesActual = fechaActual.getMonth()
                let diaActual = fechaActual.getDate()
                let fechaSeleccionada = new Date(anoActual, (mesActual), 0);
                let posicionDia1 = (fechaSeleccionada.getDay())
                let numeroDeDiasPorMes = new Date(anoActual, mesActual + 1, 0).getDate();

                let respuesta = {
                    "calendario": "OK",
                    "ano": anoActual,
                    "mes": (mesActual + 1),
                    "dia": diaActual,
                    "tiempo": "presente",
                    "posicionDia1": (posicionDia1 + 1),
                    "numeroDiasPorMes": numeroDeDiasPorMes
                }
                salida.json(respuesta)
            }


            if (tipo === "personalizado") {
                let ano = entrada.body.ano
                let mes = entrada.body.mes
                let calendario = {}
                if (typeof ano !== 'number' || typeof mes !== 'number') {
                    let error = "H el 'Mes' y el 'Ano' tienen que ser numeros y no cadenas, es decir numeros a saco sin comillas"
                    throw new Error(error)
                }
                // Limite del presente
                let fechaActual = new Date();
                let anoActual = fechaActual.getFullYear();
                let mesActual = Number(fechaActual.getMonth() + 1)


                if (anoActual > ano) {
                    calendario["tiempo"] = "pasado"
                    calendario["detalleTemporal"] = "pasadoPorAno"
                }

                if (anoActual === ano && mesActual > mes) {
                    calendario["tiempo"] = "pasado"
                    calendario["detalleTemporal"] = "pasadoPorMes"

                }
                let tiempoConfig

                if (anoActual === ano && mesActual === mes) {
                    tiempoConfig = "presente"
                    calendario["tiempo"] = "presente"


                }
                if (anoActual < ano) {
                    tiempoConfig = "futuroPorAno"
                    calendario["tiempo"] = "futuro"
                    calendario["detalleTemporal"] = "futuroPorAno"

                }
                if (anoActual === ano && mesActual < mes) {
                    calendario["tiempo"] = "futuro"
                    calendario["detalleTemporal"] = "futuroPorMes"

                }

                if (tiempoConfig === "presente") {
                    let diaActual = fechaActual.getDate()
                    calendario["dia"] = diaActual
                }

                let fecha = new Date(ano, (mes), 0);
                let numeroDeDiasPorMes = fecha.getDate();
                let posicionDiaComienzoMes = new Date(ano, (mes - 1), 0).getDay()

                calendario["calendario"] = "OK"
                calendario["ano"] = ano
                calendario["mes"] = mes
                // Calendario["Tiempo"] = Tiempo
                calendario["numeroDiasPorMes"] = numeroDeDiasPorMes
                calendario["posicionDia1"] = (posicionDiaComienzoMes + 1)

                salida.json(calendario)
                // El numero de dias y el dia inicial

            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "confirmarReserva") {

        const reservaDumb = {
            "entrada": {
                "dia": 22,
                "mes": 5,
                "ano": 2023
            },
            "salida": {
                "dia": 23,
                "mes": 5,
                "ano": 2023
            },
            "alojamiento": {
                "apartamento1": {
                    "apartamentoUI": "Apartamento 1",
                    "habitaciones": {
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "camaDoble",
                            "camaUI": "Cama doble",
                            "pernoctantes": [
                                {
                                    "nombre": "AAAAAAAAAAAAAAA",
                                    "pasaporte": "VVVVVVVVVVVVVVV"
                                },
                                {
                                    "nombre": "GGGGGGGGGGGGGGG",
                                    "pasaporte": "HHHHHHHHHHHHHHH"
                                }
                            ]
                        },
                        "habitacion2": {
                            "habitacionUI": "Habitacion 2",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "UUUUUUUUUUUUUUU",
                                    "pasaporte": "YYYYYYYYYYYYYYYYY"
                                },
                                {
                                    "nombre": "TTTTTTTTTTTTTTTTTT",
                                    "pasaporte": "IIIIIIIIIIIIIIIIIIIIIIII"
                                }
                            ]
                        }
                    }
                },
                "apartamento6": {
                    "apartamentoUI": "Apartamento 6",
                    "habitaciones": {
                        "habitacion2": {
                            "habitacionUI": "Habitacion 2",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "OOOOOOOOOOOOOOOOOOOO",
                                    "pasaporte": "JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ"
                                },
                                {
                                    "nombre": "KKKKKKKKKKKKKKKKKKKKKKK",
                                    "pasaporte": "LLLLLLLLLLLLLLLLLLLLLLLLLLL"
                                }
                            ]
                        },
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "MMMMMMMMMMMMMMMMMM",
                                    "pasaporte": "PPPPPPPPPPPPPPPPPPPPPPP"
                                },
                                {
                                    "nombre": "UUUUUUUUUUUUUUUUUUU",
                                    "pasaporte": "YYYYYYYYYYYYYYYYYYYYY"
                                }
                            ]
                        }
                    }
                },
                "apartamento4": {
                    "apartamentoUI": "Apartamento 4",
                    "habitaciones": {
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "BBBBBBBBBBBBBB",
                                    "pasaporte": "HHHHHHHHHHHH"
                                },
                                {
                                    "nombre": "IIIIIIIIIIIIIIIIIIIIII",
                                    "pasaporte": "VVVVVVVVVVVVVVVV"
                                }
                            ]
                        }
                    }
                },
                "apartamento2": {
                    "apartamentoUI": "Apartamento 2",
                    "habitaciones": {
                        "habitacion2": {
                            "habitacionUI": "Habitacion 2",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "YYYYYYYYYYYYYYYYYYYYY",
                                    "pasaporte": "DDDDDDDDDDDDDDDDDDD"
                                },
                                {
                                    "nombre": "SSSSSSSSSSSSSSSSSSSSS",
                                    "pasaporte": "XXXXXXXXXXXXXXXXXXXX"
                                }
                            ]
                        },
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "camaDoble",
                            "camaUI": "Cama doble",
                            "pernoctantes": [
                                {
                                    "nombre": "ZZZZZZZZZZZZZZZZZZZZZ",
                                    "pasaporte": "AAAAAAAAAAAAAAAAAAAAA"
                                },
                                {
                                    "nombre": "BBBBBBBBBBBBBBBBBBBB",
                                    "pasaporte": "VVVVVVVVVVVVVVVVVVV"
                                }
                            ]
                        }
                    }
                },
                "apartamento3": {
                    "apartamentoUI": "Apartamento 3",
                    "habitaciones": {
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "LLLLLLLLLLLLLLLLLLL",
                                    "pasaporte": "NNNNNNNNNNNNNNN"
                                },
                                {
                                    "nombre": "MMMMMMMMMMMMMMMM",
                                    "pasaporte": "nnnnnnnnnnnnnnnnnn"
                                }
                            ]
                        }
                    }
                },
                "apartamento5": {
                    "apartamentoUI": "Apartamento 5",
                    "habitaciones": {
                        "habitacion1": {
                            "habitacionUI": "Habitacion 1",
                            "camaIDV": "dosCamasIndividuales",
                            "camaUI": "Dos camas individuales",
                            "pernoctantes": [
                                {
                                    "nombre": "PPPPPPPPPPPPPPPPPP",
                                    "pasaporte": "KKKKKKKKKKKKKKK"
                                },
                                {
                                    "nombre": "IIIIIIIIIIIIIIIIIIIII",
                                    "pasaporte": "UUUUUUUUUUUUUUU"
                                }
                            ]
                        }
                    }
                }
            }
        }
        //let reserva = reservaDumb
        const reserva = entrada.body.reserva
        const estadoReserva = "Reserva Desarrollo"
        const mutex = new Mutex();
        const bloqueoReserva = await mutex.acquire();
        try {
            const resuelveValidacionObjetoReserva = await validarObjetoReserva(reserva);
            if (!resuelveValidacionObjetoReserva.ok) {
                let error = "Ha ocurrido un error desconocido en la validacion del objeto"
                throw new Error(error)
            }
            const metadatos = {
                "tipoProcesadorPrecio": "objeto",
                "reserva": reserva
            }
            const resuelvePrecioReserva = await precioReserva(metadatos);
            // EL precio resuelto se usa para el objeto de cobro
            const token = entrada.body.token;
            const idempotencyKey = entrada.body.idempotencyKey;

            // Solo puede ser activado o desactivado, definir aqui
            const moduloPagoEstado = "activado"




            if (!token || !idempotencyKey) {
                const error = "Falta el token o el idempotencyKey por lo tanto se cancela el proceso de pago y no se contacta con square"
                if (moduloPagoEstado === "desactivado") {
                    throw new Error(error)
                }
            }
            const locationResponse = await clienteSquare.locationsApi.retrieveLocation(process.env.SQUARE_LOCATION_ID);
            const currency = locationResponse.result.location.currency;
            // Charge the customer's card
            let requestBody = {
                idempotencyKey,
                sourceId: token,
                amountMoney: {
                    amount: 100, // $1.00 charge
                    currency
                }
            };
            if (entrada.body.verificationToken) {
                requestBody.verificationToken = entrada.body.verificationToken;
            }
            //////////////////////////////////////
            if (moduloPagoEstado === "activado") {
                const { result: { payment } } = await clienteSquare.paymentsApi.createPayment(requestBody);
                const result = JSON.stringify(payment, (key, value) => {
                    return typeof value === "bigint" ? parseInt(value) : value;
                }, 4);
            }
            //////////////////////////////////////
            const resuelveInsercionReserva = await insertarReserva(reserva)
            if (resuelveInsercionReserva.ok) {
                salida.json(resuelveInsercionReserva);
            }
        } catch (err) {
            
            let errorFinal;
            if (err.message) {
                let error = {
                    "error": err.message
                }
                errorFinal = error

            }
            if (err.result) {
                errorFinal = err.result

            }
            salida.json(errorFinal)
        } finally {
            bloqueoReserva();
        }
    }
    if (transaccion === "IDX") {
        try {
            const IDX = entrada.body.IDX
            if (!IDX) {
                const error = "Falta espeficiar la 'accion'"
                throw new Error(error)
            }
            if (IDX === "conectar") {
                const usuario = entrada.body.usuario

                const filtroIDX = /^[a-z0-9_\-\.]+$/;
                if (!usuario || !filtroIDX.test(usuario)) {
                    const error = "El campo usuarios solo admite min√∫sculas, numeros, guion medio, guion bajo y punto"
                    throw new Error(error)
                }
                const clave = entrada.body.clave
                if (!clave) {
                    const error = "Falta especificar la contrasena"
                    throw new Error(error)
                }

                // Se valida si existe el usuario
                const consultaControlIDX = `
                SELECT
                usuario,
                rol,
                sal,
                clave,
                "estadoCuenta" 
                FROM 
                usuarios 
                WHERE 
                usuario = $1
                `
                const resuelveControlIDX = await conexion.query(consultaControlIDX, [usuario])
                if (resuelveControlIDX.rowCount === 0) {
                    const error = "Nombre de usuario o contrasena incorrectos"
                    throw new Error(error)
                }
                // Se recupera el hash y la sal

                const IDX_ = resuelveControlIDX.rows[0].usuario
                const rol = resuelveControlIDX.rows[0].rol
                const sal = resuelveControlIDX.rows[0].sal
                const claveHash = resuelveControlIDX.rows[0].clave
                const estadoCuenta = resuelveControlIDX.rows[0].estadoCuenta
                const ip = entrada.socket.remoteAddress;
                const metadatos = {
                    sentido: "comparar",
                    clavePlana: clave,
                    sal: sal,
                    claveHash: claveHash
                }
                const controlClave = vitiniCrypto(metadatos)
                if (!controlClave) {
                    const error = "Nombre de usuario o contrasena incorrectos"
                    throw new Error(error)
                }

                if (estadoCuenta === "desactivado") {
                    const error = "Esta cuenta esta desactivada"
                    throw new Error(error)
                }


                entrada.session.usuario = IDX_;
                entrada.session.rol = rol
                entrada.session.ip = ip

                const ok = {
                    "ok": IDX_,
                    "rol": rol,
                    "controlEstado": "Objeto en IF IDX",
                }
                salida.json(ok)
            }

            if (IDX === "desconectar") {
                entrada.session.destroy();
                salida.clearCookie("IDX");
                const respuesta = {
                    "IDX": "desconectado"
                }
                salida.json(respuesta);
            }
            if (IDX === "estado") {
                const usuario = entrada.session.usuario;
                const rol = entrada.session.rol
                const respuesta = {}
                if (usuario) {
                    respuesta.estado = "conectado"
                    respuesta.usuario = usuario
                    respuesta.rol = rol

                } else {
                    respuesta.estado = "desconectado"
                }
                salida.json(respuesta)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "listarReservas") {

        try {
            let Pagina = entrada.body["pagina"]
            let nombreColumna = entrada.body["nombreColumna"]
            nombreColumna = nombreColumna ? nombreColumna : "entrada"
            let sentidoColumna = entrada.body["sentidoColumna"]
            if (sentidoColumna !== "descendente" && sentidoColumna !== "ascendente") {
                sentidoColumna = "ascendente"
            }
            let nombreColumnaSentidoUI

            if (sentidoColumna == "ascendente") {
                sentidoColumna = "ASC"
                nombreColumnaSentidoUI = "ascendente"
            }

            if (sentidoColumna == "descendente") {
                sentidoColumna = "DESC"
                nombreColumnaSentidoUI = "descendente"

            }

            const filtronombreColumna = /^[a-zA-Z]+$/;
            if (!filtronombreColumna.test(nombreColumna)) {
                const error = "el campo 'ordenClolumna' solo puede ser letras."
                throw new Error(error)
            }
            nombreColumna = nombreColumna

            if (typeof Pagina !== "number" || !Number.isInteger(Pagina) || Pagina <= 0) {
                const error = "Debe de especificarse la clave 'pagina' y su valor debe de ser numerico, entero, positivo y mayor a cero."
                throw new Error(error)
            }

            const tipoConsulta = entrada.body.tipoConsulta
            let numeroPagina = Number((Pagina - 1) + "0");

            let numeroPorPagina = 10
            if (tipoConsulta !== "hoy" && tipoConsulta !== "rango" && tipoConsulta !== "por_id") {
                const error = "Hay que especificar el tipo de consulta, si es hoy o rango"
                throw new Error(error)
            }

            if (tipoConsulta === "hoy") {
                const fechaHoy = new Date();
                const dia = fechaHoy.getDate() < 10 ? 0 + fechaHoy.getDate().toString() : fechaHoy.getDate()
                const corretorMes = Number(fechaHoy.getMonth() + 1)
                const mes = corretorMes < 10 ? 0 + corretorMes.toString() : corretorMes
                const ano = fechaHoy.getFullYear()
                const numeroPagina = 1
                const numeroPorPagina = 10
                const fechaFormato = dia + "/" + mes + "/" + ano
                const consultaHoy = `
                SELECT 
                reserva, 
                to_char(entrada, 'DD/MM/YYYY') as entrada, 
                to_char(salida, 'DD/MM/YYYY') as salida", 
                "estadoReserva", 
                "estadoPago"
                FROM reservas
                WHERE entrada = $1
                ORDER BY 
                "${nombreColumna}" ${sentidoColumna} 
                LIMIT $2
                OFFSET $3;
                `
                let consultaReservasHoy = await conexion.query(consultaHoy, [fechaFormato, numeroPorPagina, numeroPagina])
                let consultaConteoTotalFilas = consultaReservasHoy.rowCount
                consultaReservasHoy = consultaReservasHoy.rows
                const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                const corretorNumeroPagina = String(numeroPagina).replace("0", "")

                const Respuesta = {
                    "ok": {
                        "tipoConsulta": "hoy",
                        "pagina": Number(corretorNumeroPagina) + 1,
                        "paginasTotales": totalPaginas,
                        "totalReservas": Number(consultaConteoTotalFilas),
                        "nombreColumna": nombreColumna,
                        "sentidoColumna": nombreColumnaSentidoUI,
                        "reservas": consultaReservasHoy
                    }
                }
                salida.json(Respuesta)
            }
            if (tipoConsulta === "rango") {
                let fechaEntrada = entrada.body.fechaEntrada
                let fechaSalida = entrada.body.fechaSalida
                let tipoCoincidencia = entrada.body.tipoCoincidencia;
                if (tipoCoincidencia !== "cualquieraQueCoincida" &&
                    tipoCoincidencia !== "soloDentroDelRango" &&
                    tipoCoincidencia !== "porFechaDeEntrada" &&
                    tipoCoincidencia !== "porFechaDeSalida") {
                    const error = "Falta especificar el 'tipoCoincidencia'"
                    throw new Error(error)
                }

                if (tipoCoincidencia === "cualquieraQueCoincida") {

                    if (!fechaEntrada) {
                        const error = "Falta determinar la 'fechaEntrada'"
                        throw new Error(error)
                    }
                    if (!fechaSalida) {
                        const error = "Falta determinar la 'fechaSalida'"
                        throw new Error(error)
                    }
                    const convertirFechaISO8601 = (fechaStr) => {
                        const [dia, mes, anio] = fechaStr.split('/');
                        const fechaISO8601 = `${anio}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                        return fechaISO8601;
                    };

                    const fechaEntradaReservaControl = new Date(convertirFechaISO8601(fechaEntrada));
                    const fechaSalidaReservaControl = new Date(convertirFechaISO8601(fechaSalida));
                    if (fechaSalidaReservaControl <= fechaEntradaReservaControl) {

                        let error = "La fecha de entrada seleccionada es igual o superior a la fecha de salida de la reserva"
                        throw new Error(error)
                    }

                    let consultaConstructor = `
                        SELECT
                        reserva,
                        to_char(entrada, 'DD/MM/YYYY') as entrada, 
                        to_char(salida, 'DD/MM/YYYY') as salida, 
                        "estadoReserva",
                        "estadoPago",
                        COUNT(*) OVER() as total_filas
                        FROM reservas
                        WHERE entrada <= $2::DATE AND salida >= $1::DATE
                        ORDER BY 
                        "${nombreColumna}" ${sentidoColumna} 
                        LIMIT $3 OFFSET $4    
                        ;`
                    let consultaReservas = await conexion.query(consultaConstructor, [fechaEntradaReservaControl, fechaSalidaReservaControl, numeroPorPagina, numeroPagina])
                    let consultaConteoTotalFilas = consultaReservas?.rows[0]?.total_filas ? consultaReservas.rows[0].total_filas : 0
                    consultaReservas = consultaReservas.rows

                    const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                    const corretorNumeroPagina = String(numeroPagina).replace("0", "")
                    const ok = {
                        "ok": {
                            "tipoCoincidencia": "cualquieraQueCoincida",
                            "totalReservas": Number(consultaConteoTotalFilas),
                            "paginasTotales": totalPaginas,
                            "tipoConsulta": "rango",
                            "fechaEntrada": fechaEntrada,
                            "fechaSalida": fechaSalida,
                            "pagina": Number(corretorNumeroPagina) + 1,
                            "nombreColumna": nombreColumna,
                            "sentidoColumna": nombreColumnaSentidoUI,
                            "reservas": consultaReservas
                        }
                    }
                    salida.json(ok)
                }


                if (tipoCoincidencia === "soloDentroDelRango") {
                    if (!fechaEntrada) {
                        const error = "Falta determinar la 'fechaEntrada'"
                        throw new Error(error)
                    }
                    if (!fechaSalida) {
                        const error = "Falta determinar la 'fechaSalida'"
                        throw new Error(error)
                    }
                    const convertirFechaISO8601 = (fechaStr) => {
                        const [dia, mes, anio] = fechaStr.split('/');
                        const fechaISO8601 = `${anio}-${mes.padStart(2, '0')}-${dia.padStart(2, '0')}`;
                        return fechaISO8601;
                    };

                    const fechaEntradaReservaControl = new Date(convertirFechaISO8601(fechaEntrada));
                    const fechaSalidaReservaControl = new Date(convertirFechaISO8601(fechaSalida));
                    if (fechaSalidaReservaControl <= fechaEntradaReservaControl) {

                        let error = "La fecha de entrada seleccionada es igual o superior a la fecha de salida de la reserva"
                        throw new Error(error)
                    }
                    let consultaConstructor = `
                        SELECT
                        reserva,
                        to_char(entrada, 'DD/MM/YYYY') as entrada, 
                        to_char(salida, 'DD/MM/YYYY') as salida, 
                        "estadoReserva",
                        "estadoPago",
                        COUNT(*) OVER() as total_filas
                        FROM reservas
                        WHERE entrada >= $1::DATE AND salida <= $2::DATE
                        ORDER BY 
                        "${nombreColumna}" ${sentidoColumna} 
                        LIMIT $3 OFFSET $4    
                        ;`
                    let consultaReservas = await conexion.query(consultaConstructor, [fechaEntrada, fechaSalida, numeroPorPagina, numeroPagina])
                    let consultaConteoTotalFilas = consultaReservas?.rows[0]?.total_filas ? consultaReservas.rows[0].total_filas : 0
                    consultaReservas = consultaReservas.rows
                    const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                    const corretorNumeroPagina = String(numeroPagina).replace("0", "")
                    const ok = {
                        "ok": {
                            "tipoCoincidencia": "soloDentroDelRango",
                            "totalReservas": Number(consultaConteoTotalFilas),
                            "paginasTotales": totalPaginas,
                            "tipoConsulta": "rango",
                            "fechaEntrada": fechaEntrada,
                            "fechaSalida": fechaSalida,
                            "pagina": Number(corretorNumeroPagina) + 1,
                            "nombreColumna": nombreColumna,
                            "sentidoColumna": nombreColumnaSentidoUI,
                            "reservas": consultaReservas
                        }
                    }
                    salida.json(ok)
                }

                if (tipoCoincidencia === "porFechaDeEntrada") {
                    if (!fechaEntrada) {
                        const error = "Falta determinar la 'fechaEntrada'"
                        throw new Error(error)
                    }
                    let consultaConstructor = `
                        SELECT
                        reserva,
                        to_char(entrada, 'DD/MM/YYYY') as entrada, 
                        to_char(salida, 'DD/MM/YYYY') as salida, 
                        "estadoPago",
                        "estadoPago",
                        COUNT(*) OVER() as total_filas 
                        FROM reservas
                        WHERE entrada = $1::DATE
                        ORDER BY 
                        "${nombreColumna}" ${sentidoColumna} 
                        LIMIT $2 OFFSET $3; `
                    let consultaReservas = await conexion.query(consultaConstructor, [fechaEntrada, numeroPorPagina, numeroPagina])
                    let consultaConteoTotalFilas = consultaReservas?.rows[0]?.total_filas ? consultaReservas.rows[0].total_filas : 0
                    consultaReservas = consultaReservas.rows
                    const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                    const corretorNumeroPagina = String(numeroPagina).replace("0", "")
                    const ok = {
                        "ok": {
                            "tipoCoincidencia": "porFechaDeEntrada",
                            "totalReservas": Number(consultaConteoTotalFilas),
                            "paginasTotales": totalPaginas,
                            "tipoConsulta": "rango",
                            "fechaEntrada": fechaEntrada,
                            "fechaSalida": fechaSalida,
                            "pagina": Number(corretorNumeroPagina) + 1,
                            "nombreColumna": nombreColumna,
                            "sentidoColumna": nombreColumnaSentidoUI,
                            "reservas": consultaReservas
                        }
                    }
                    salida.json(ok)
                }
                if (tipoCoincidencia === "porFechaDeSalida") {
                    if (!fechaSalida) {
                        const error = "Falta determinar la 'fechaSalida'"
                        throw new Error(error)
                    }

                    let consultaConstructor = `
                        SELECT
                        reserva,
                        to_char(entrada, 'DD/MM/YYYY') as entrada, 
                        to_char(salida, 'DD/MM/YYYY') as salida, 
                        "estadoReserva",
                        "estadoPago",
                        COUNT(*) OVER() as total_filas
                        FROM reservas
                        WHERE salida = $1::DATE
                        ORDER BY 
                        "${nombreColumna}" ${sentidoColumna} 
                        LIMIT $2 OFFSET $3  `
                    let consultaReservas = await conexion.query(consultaConstructor, [fechaSalida, numeroPorPagina, numeroPagina])
                    let consultaConteoTotalFilas = consultaReservas?.rows[0]?.total_filas ? consultaReservas.rows[0].total_filas : 0
                    consultaReservas = consultaReservas.rows
                    const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                    const corretorNumeroPagina = String(numeroPagina).replace("0", "")
                    const ok = {
                        "ok": {
                            "tipoCoincidencia": "porFechaDeSalida",
                            "totalReservas": Number(consultaConteoTotalFilas),
                            "paginasTotales": totalPaginas,
                            "tipoConsulta": "rango",
                            "fechaEntrada": fechaEntrada,
                            "fechaSalida": fechaSalida,
                            "pagina": Number(corretorNumeroPagina) + 1,
                            "nombreColumna": nombreColumna,
                            "sentidoColumna": nombreColumnaSentidoUI,
                            "reservas": consultaReservas
                        }
                    }
                    salida.json(ok)
                }
            }

            if (tipoConsulta === "por_id") {

                const reservaID = entrada.body.id
                if (!reservaID) {
                    const error = "Falta especificar la clave 'id'"
                    throw new Error(error)
                }
                if (typeof reservaID !== "number" || !Number.isInteger(reservaID) && reservaID <= 0) {
                    const error = "la clave 'id' debe de tener un dato tipo 'number', positivo y entero"
                    throw new Error(error)
                }
                let consultaConstructor = `
                    SELECT
                    reserva,
                    to_char(entrada, 'DD/MM/YYYY') as entrada, 
                    to_char(salida, 'DD/MM/YYYY') as salida, 
                    "estadoReserva",
                    "estadoPago",
                    COUNT(*) OVER() as total_filas
                    FROM reservas
                    WHERE reserva = $1
                    ORDER BY 
                    "${nombreColumna}" ${sentidoColumna} 
                    LIMIT $2 OFFSET $3;`
                let consultaReservas = await conexion.query(consultaConstructor, [reservaID, numeroPorPagina, numeroPagina])
                let consultaConteoTotalFilas = consultaReservas?.rows[0]?.total_filas ? consultaReservas.rows[0].total_filas : 0
                consultaReservas = consultaReservas.rows
                const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
                const corretorNumeroPagina = String(numeroPagina).replace("0", "")
                const ok = {
                    "ok": {
                        "pagina": 1,
                        "tipoConsulta": "por_id",
                        "totalReservas": Number(consultaConteoTotalFilas),
                        "paginasTotales": totalPaginas,
                        "pagina": Number(corretorNumeroPagina) + 1,
                        "nombreColumna": nombreColumna,
                        "sentidoColumna": nombreColumnaSentidoUI,
                        "reservas": consultaReservas
                    }
                }
                salida.json(ok)
            }

        } catch (error) {
            const detalleError = {
                "error": error.message,
            }
            salida.json(detalleError)
        } finally {
            
        }


    }
    if (transaccion === "detallesReserva") {
        try {
            const reservaUID = entrada.body.reserva
            if (!reservaUID) {
                const error = "Se necesita un id de 'reserva'"
                throw new Error(error)
            }
            if (typeof reservaUID !== "number" || !Number.isInteger(reservaUID) || reservaUID <= 0) {
                let error = "Se ha definico correctamente  la clave 'reserva' pero el valor de esta debe de ser un numero positivo, si has escrito un numero positivo, revisa que en el objeto no este numero no este envuelvo entre comillas"
                throw new Error(error)
            }
            const metadatos = {
                reservaUID: reservaUID
            }
            const resuelveDetallesReserva = await detallesReserva(metadatos)
            salida.json(resuelveDetallesReserva)
        } catch (error) {
            let Error = {
                "Error": error.message,
                "detalles": error
            }
            salida.json(Error)
        } finally {
            
        }
    }
    if (transaccion === "buscarClientes") {
        try {

            let buscar = entrada.body.buscar;
            let tipoBusqueda = entrada.body.tipoBusqueda
            let nombreColumna = entrada.body.nombreColumna
            let sentidoColumna = entrada.body.sentidoColumna
            if (tipoBusqueda !== "rapido") {
                tipoBusqueda = null;
            }

            if (!buscar) {
                let error = "se tiene que espeficiar 'buscar' y lo que se desea buscar"
                throw new Error(error)
            }
            let Pagina = entrada.body["pagina"]
            Pagina = Pagina ? Pagina : 1
            if (typeof Pagina !== "number" || !Number.isInteger(Pagina) || Pagina <= 0) {
                const error = "En 'pagina' solo se aceptan numero enteros superiores a cero y positivos. Nada de decimales"
                throw new Error(error)
            }

            let condicionComplejaSQLOrdenarResultadosComoSegundaCondicion = ""
            let nombreColumnaSentidoUI
            let nombreColumnaUI
            if (nombreColumna) {
                if (nombreColumna !== "nombre" && nombreColumna !== "primerApellido" && nombreColumna !== "segundoApellido" && nombreColumna !== "pasaporte" && nombreColumna !== "uid") {
                    const error = "En 'nombreColumna' solo se aceptan nombre, primerApellido, segundoApellido, pasaporte, uid"
                    throw new Error(error)
                }
                // OJO con la coma, OJO LA COMA ES IMPORTANTISMA!!!!!!!!
                //!!!!!!!
                if (sentidoColumna !== "descendente" && sentidoColumna !== "ascendente") {
                    sentidoColumna = "ascendente"
                }
                if (sentidoColumna == "ascendente") {
                    sentidoColumna = "ASC"
                    nombreColumnaSentidoUI = "ascendente"
                }
                if (sentidoColumna == "descendente") {
                    sentidoColumna = "DESC"
                    nombreColumnaSentidoUI = "descendente"
                }
                nombreColumnaUI = nombreColumna
                condicionComplejaSQLOrdenarResultadosComoSegundaCondicion = `,"${nombreColumna}" ${sentidoColumna}`
            }


            let terminoBuscar = buscar.split(" ")
            let terminosFormateados = []
            terminoBuscar.map((termino) => {
                let terminoFinal = "%" + termino + "%"
                terminosFormateados.push(terminoFinal)
            })
            const numeroPorPagina = 10
            let numeroPagina = Number((Pagina - 1) + "0");
            let consultaConstructor =
                `    
                SELECT *,
                COUNT(*) OVER() as "totalClientes"
            FROM clientes
            WHERE  
                (
                LOWER(COALESCE(nombre, '')) ILIKE ANY($1) OR
                LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1) OR
                LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1) OR
                LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1)
                )
            ORDER BY
                (
                  CASE
                    WHEN (
                      (LOWER(COALESCE(nombre, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int
                    ) = 1 THEN 1
                    WHEN (
                      (LOWER(COALESCE(nombre, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int
                    ) = 3 THEN 3
                    ELSE 2
                  END
                ) DESC
                ${condicionComplejaSQLOrdenarResultadosComoSegundaCondicion}
            LIMIT $2 OFFSET $3;`

            let consultaReservas = await conexion.query(consultaConstructor, [terminosFormateados, numeroPorPagina, numeroPagina])

            consultaReservas = consultaReservas.rows
            let consultaConteoTotalFilas = consultaReservas[0]?.totalClientes ? consultaReservas[0].totalClientes : 0
            if (tipoBusqueda === "rapido") {
                consultaReservas.map((cliente) => {
                    delete cliente.Telefono
                    delete cliente.email
                    delete cliente.notas

                })
            }
            const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
            const corretorNumeroPagina = String(numeroPagina).replace("0", "")
            const Respuesta = {
                "transaccion": "buscarClientes",
                "buscar": buscar,
                "totalClientes": consultaConteoTotalFilas,
                "paginasTotales": totalPaginas,
                "pagina": Number(corretorNumeroPagina) + 1,
            }
            if (nombreColumna) {
                Respuesta["nombreColumna"] = nombreColumnaUI
                Respuesta["sentidoColumna"] = nombreColumnaSentidoUI
            }

            Respuesta["clientes"] = consultaReservas

            salida.json(Respuesta)
        } catch (error) {
            const detalleError = {
                "error": error.message,
            }
            return salida.json(detalleError)
        } finally {
            
        }

    }
    if (transaccion === "cambiarTipoClienteEnReserva") {
        const mutex = new Mutex();
        const bloqueoCambiarTipoClienteEnReserva = await mutex.acquire();
        try {
            let reserva = entrada.body.reserva
            let clientePool = entrada.body.clientePool
            let cliente = entrada.body.cliente

            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof clientePool !== "number" || !Number.isInteger(clientePool) || clientePool <= 0) {
                const error = "El campo 'clientePool' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof cliente !== "number" || !Number.isInteger(cliente) || cliente <= 0) {
                const error = "El campo 'cliente' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }


            const consultaControlClienteUnico = `
            SELECT pernoctante 
            FROM "reservaPernoctantes" 
            WHERE pernoctante = $1 AND reserva = $2;`
            let controlClienteUnicoReserva = await conexion.query(consultaControlClienteUnico, [cliente, reserva])
            controlClienteUnicoReserva = controlClienteUnicoReserva.rows[0]
            if (controlClienteUnicoReserva?.pernoctante) {
                const error = "Ya existe el cliente en la reserva, escoge otro"
                throw new Error(error)
            }

            const cambiarClientePoolPorCliente = `
            UPDATE "reservaPernoctantes"
            SET pernoctante = $1, "pernoctantePool" = NULL
            WHERE "pernoctantePool" = $2 AND reserva = $3;
            `
            let clientePoolResuelto = await conexion.query(cambiarClientePoolPorCliente, [cliente, clientePool, reserva])
            clientePoolResuelto = clientePoolResuelto
            if (clientePoolResuelto.rowCount === 0) {
                const error = "revisa los parametros que introduces por que aunque estan escritos en el formato correcto pero no son correctos"
                throw new Error(error)
            }
            let ok = {
                "ok": "Se ha acualizado el pernoctanet correctamente"
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "Error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            bloqueoCambiarTipoClienteEnReserva();
        }

    }
    if (transaccion === "cambiarPernoctanteHabitacion") {
        const mutex = new Mutex();
        const bloqueoCambiarPernoctanteHabitacion = await mutex.acquire();
        try {
            let reserva = entrada.body.reserva
            let habitacionDestino = entrada.body.habitacionDestino
            let pernoctanteUID = entrada.body.pernoctanteUID

            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            const consultaExistenciaCliente = `
            SELECT uid 
            FROM "reservaPernoctantes" 
            WHERE reserva = $1 AND uid = $2;
            `
            let controlExistencia = await conexion.query(consultaExistenciaCliente, [reserva, pernoctanteUID])
            controlExistencia = controlExistencia.rows[0]

            if (!controlExistencia?.uid) {
                const error = "No existe el pernoctante, por lo tanto no se puede mover de habitacion"
                throw new Error(error)
            }
            const consultaControlUnicoCliente = `
                SELECT uid 
                FROM "reservaPernoctantes" 
                WHERE reserva = $1 AND habitacion = $2 AND uid = $3;
                `
            let seleccionaClienteOrigen = await conexion.query(consultaControlUnicoCliente, [reserva, habitacionDestino, pernoctanteUID])
            seleccionaClienteOrigen = seleccionaClienteOrigen.rows[0]
            if (seleccionaClienteOrigen?.uid) {
                const error = "Ya existe el cliente en esta habitacion"
                throw new Error(error)
            }
            const actualizaNuevaPosicionClientePool = `
                UPDATE "reservaPernoctantes"
                SET habitacion = $1
                WHERE reserva = $2 AND uid = $3;
                `
            let actualizaClientePoolDestino = await conexion.query(actualizaNuevaPosicionClientePool, [habitacionDestino, reserva, pernoctanteUID])
            if (actualizaClientePoolDestino.rowCount === 0) {
                const error = "Ha ocurrido un error al intentar actualiza el cliente pool en el destino"
                throw new Error(error)

            }

            if (actualizaClientePoolDestino.rowCount === 1) {
                const ok = {
                    "ok": "Se ha cambiado correctamente al pernoctante de alojamiento dentro de la reserva "
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": "Ha ocurrido durante la transaccion",
                "Detalles": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoCambiarPernoctanteHabitacion()
        }


    }
    if (transaccion === "cambiarCamaHabitacion") {
        const mutex = new Mutex();
        const bloqueoCambiarCamaHabitacion = await mutex.acquire();

        try {
            const reserva = entrada.body.reserva
            const habitacion = entrada.body.habitacion
            const nuevaCama = entrada.body.nuevaCama
            if (typeof reserva !== 'number' || !Number.isInteger(reserva) || reserva <= 0) {
                let error = "Se necesita un id de 'reserva' que sea un numero, positio y mayor a cero"
                throw new Error(error)
            }
            if (typeof habitacion !== 'number' || !Number.isInteger(habitacion) || habitacion <= 0) {
                let error = "Se necesita un id de 'habitacion' que sea un n√∫mero entero, positivo y mayor a cero"
                throw new Error(error)
            }
            const filtroCadena = /^[A-Za-z\s]+$/;
            if (!nuevaCama || !filtroCadena.test(nuevaCama)) {
                let error = "Se necesita un 'nuevaCama' que sea un string con letras y espacios, nada mas"
                throw new Error(error)
            }
            // Valida reserva
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }
            // valida que la habitacion exista dentro de la reserva
            const consultaValidacionHabitacion = `
            SELECT uid 
            FROM "reservaHabitaciones" 
            WHERE reserva = $1 AND uid = $2;`
            let resuelveconsultaValidacionHabitacion = await conexion.query(consultaValidacionHabitacion, [reserva, habitacion])
            if (resuelveconsultaValidacionHabitacion?.rowCount === 0) {
                const error = "No existe la habitacion dentro de la reserva"
                throw new Error(error)
            }
            // valida camaIDV que entra
            const consultaValidacionCamaIDV = `
            SELECT "camaUI" 
            FROM camas 
            WHERE cama = $1;`
            let resuelveConsultaValidacionCamaIDV = await conexion.query(consultaValidacionCamaIDV, [nuevaCama])
            if (resuelveConsultaValidacionCamaIDV?.rowCount === 0) {
                const error = "No exist el camaIDV introducido en el campo nuevaCama"
                throw new Error(error)
            }
            // Valida que la cama existe dentro de la reserva

            const resolucionNombreCama = await conexion.query(`SELECT "camaUI" FROM camas WHERE cama = $1`, [nuevaCama])
            if (resolucionNombreCama.rowCount === 0) {
                const error = "No existe el identificador de la camaIDV"
                throw new Error(error)
            }
            const camaUI = resolucionNombreCama.rows[0].camaUI

            const consultaExistenciaCama = `
            SELECT uid 
            FROM "reservaCamas" 
            WHERE reserva = $1 AND habitacion = $2;`
            const resuelveconsultaExistenciaCama = await conexion.query(consultaExistenciaCama, [reserva, habitacion])
            if (resuelveconsultaExistenciaCama.rowCount === 1) {
                const consultaActualizaCama = `
                UPDATE "reservaCamas"
                SET
                cama = $3,
                "camaUI" = $4
                WHERE reserva = $1 AND habitacion = $2;`
                const resueleConsultaActualizaCama = await conexion.query(consultaActualizaCama, [reserva, habitacion, nuevaCama, camaUI])
                if (resueleConsultaActualizaCama?.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha actualizado correctamten la cama"
                    }
                    salida.json(ok)
                }
            }
            if (resuelveconsultaExistenciaCama.rowCount === 0) {
                const insertaNuevaCama = `
                INSERT INTO "reservaCamas"
                (
                reserva,
                habitacion,
                cama,
                "camaUI"
                )
                VALUES ($1, $2,$3) RETURNING uid
                `
                const resuelveInsertaNuevaCama = await conexion.query(insertaNuevaCama, [reserva, habitacion, nuevaCama, camaUI])
                if (resuelveInsertaNuevaCama.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha anadido correctamente la nueva a la habitacion",
                        "nuevoUID": resuelveInsertaNuevaCama.rows[0].uid
                    }
                    salida.json(ok)
                }
            }
            salida.end()
        } catch (errorCapurado) {
            const error = {
                "error": errorCapurado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoCambiarCamaHabitacion()
        }
    }
    if (transaccion === "listarTipoCamasHabitacion") {

        try {
            const apartamento = entrada.body.apartamento
            const habitacion = entrada.body.habitacion

            const filtroCadena = /^[A-Za-z\s\d]+$/;
            if (!apartamento || !filtroCadena.test(apartamento)) {
                let error = "Se necesita un 'apartamento' que sea un string con letras y espacios, nada mas"
                throw new Error(error)
            }
            if (!habitacion || !filtroCadena.test(habitacion)) {
                let error = "Se necesita un 'habitacion' que sea un string con letras y espacios, nada mas"
                throw new Error(error)
            }

            const consultaControlApartamento = `
            SELECT uid 
            FROM "configuracionApartamento" 
            WHERE apartamento = $1 AND habitacion = $2;`
            const controlConfiguracionApartamento = await conexion.query(consultaControlApartamento, [apartamento, habitacion])
            if (controlConfiguracionApartamento.rowCount === 0) {
                let error = "No exista el apartamento o la habitacion en el"
                throw new Error(error)
            }
            if (controlConfiguracionApartamento.rowCount === 1) {
                let configuracionApartamento = controlConfiguracionApartamento.rows[0]["uid"]
                const consultaControlApartamento = `
                SELECT cama
                FROM "configuracionHabitacion" 
                WHERE habitacion = $1;`
                const configuracionCamasHabitacion = await conexion.query(consultaControlApartamento, [configuracionApartamento])
                if (configuracionCamasHabitacion.rowCount === 0) {
                    let error = "No existe ningun tipo de camas configuradas para esta habitacion"
                    throw new Error(error)
                }
                let camasResueltas = []
                for (const camaPorResolver of configuracionCamasHabitacion.rows) {
                    let camaIDV = camaPorResolver.cama

                    const consultaResolucionNombresCamas = `
                    SELECT "camaUI", cama
                    FROM camas 
                    WHERE cama = $1;`
                    let resolucionNombresCamas = await conexion.query(consultaResolucionNombresCamas, [camaIDV])
                    resolucionNombresCamas = resolucionNombresCamas.rows[0]

                    let camaResuelta = {
                        "cama": resolucionNombresCamas.cama,
                        "camaUI": resolucionNombresCamas.camaUI

                    }
                    camasResueltas.push(camaResuelta)

                }
                let ok = {
                    "camasDisponibles": camasResueltas,
                }
                salida.json(ok);
            }
        } catch (error) {
            let respuesta = {
                "Error": error.message,
                "detalles": error?.table
            }
            salida.json(respuesta);
        } finally {
            
        }

    }
    if (transaccion === "apartamentosDisponiblesPublico") {

        try {
            const fechaEntrada = entrada.body.entrada
            const fechaSalida = entrada.body.salida


            if (!fechaEntrada) {
                let error = "falta definir el campo 'entrada'"
                throw new Error(error)
            }

            if (!fechaSalida) {
                let error = "falta definir el campo 'salida'"
                throw new Error(error)
            }
            const fecha = {
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida
            }
            
            const resuelveADP = await apartamentosDisponiblesPublico(fecha)
            const apartamentosDisponiblesEntonctrados = resuelveADP.apartamentosDisponibles
            const resuelveCA = await configuracionApartamento(apartamentosDisponiblesEntonctrados)
            

            const estructuraFinal = {}
            estructuraFinal.apartamentosDisponibles = resuelveCA.configuracionApartamento
            // Aqui se deberia mostra la media del precio en relacion con las fechas
            const metadatos = {
                "fechaEntrada": "1/9/2023",
                "fechaSalida": "10/9/2023",
                "apartamentosIDVArreglo": apartamentosDisponiblesEntonctrados
            }
            const resolverPrecioApartamento = await precioRangoApartamento(metadatos)

            estructuraFinal["desgloseTotales"] = resolverPrecioApartamento




            const ok = {
                "ok": estructuraFinal
            }
            salida.json(ok)


        } catch (errorCapurado) {
            let error = {
                "error": errorCapurado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "apartamentosDisponiblesAdministracion") {
        try {
            const fechaEntrada = entrada.body.entrada
            const fechaSalida = entrada.body.salida
            const fecha = {
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida
            }


            if (!fechaEntrada) {
                let error = "falta definir el campo 'entrada'"
                throw new Error(error)
            }

            if (!fechaSalida) {
                let error = "falta definir el campo 'salida'"
                throw new Error(error)
            }
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaEntrada)) {
                let error = "el formato fecha de entrada no esta correctametne formateado"
                throw new Error(error)
            }

            if (!filtroFecha.test(fechaSalida)) {
                let error = "el formato fecha de salida no esta correctametne formateado"
                throw new Error(error)

            }


            const transactor = await apartamentosDisponiblesAdministracion(fecha)
            if (transactor) {
                const ok = {
                    "ok": transactor
                }
                salida.json(ok)

            }
            salida.end()
        } catch (errorCapurado) {
            let error = {
                "error": errorCapurado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "apartamentosDisponiblesConfigurados") {
        try {
            const apartamentosDisponiblesParaCrearOfertas = `
            SELECT 
            a.apartamento AS "apartamentoIDV",
            a."apartamentoUI",
            ea."estadoUI"
            FROM apartamentos a
            JOIN "estadoApartamentos" ea ON a.estado = ea.estado;            
            `
            let resulveApartamentosDisponiblesParaCrearOfertas = await conexion.query(apartamentosDisponiblesParaCrearOfertas)
            if (resulveApartamentosDisponiblesParaCrearOfertas.rowCount === 0) {
                let error = "No hay ningun apartamento disponible configurado"
                throw new Error(error)
            }
            let apartamenosDisponiblesEcontrados = resulveApartamentosDisponiblesParaCrearOfertas.rows
            let ok = {
                "ok": apartamenosDisponiblesEcontrados
            }
            salida.json(ok)
        } catch (errorCapurado) {
            let error = {
                "error": errorCapurado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "configuracionApartamento") {
        try {
            let apartamentos = entrada.body.apartamentos
            const transactor = await configuracionApartamento(apartamentos)
            salida.json(transactor)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "squareConstruyeCliente") {

        try {
            const locationResponse = await clienteSquare.locationsApi.retrieveLocation(process.env.SQUARE_LOCATION_ID);
            const currency = locationResponse.result.location.currency;
            const country = locationResponse.result.location.country;
            const idempotencyKey = uuidv4();

            let clienteMetadatos = {
                squareApplicationId: process.env.SQUARE_APPLICATION_ID,
                squareLocationId: process.env.SQUARE_LOCATION_ID,
                squareAccountCountry: country,
                squareAccountCurrency: currency,
                idempotencyKey
            }

            salida.json(clienteMetadatos)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "precioReserva") {
        try {
            const tipoProcesadorPrecio = entrada.body.tipoProcesadorPrecio
            const reserva = entrada.body.reserva
            if (tipoProcesadorPrecio !== "objeto" && tipoProcesadorPrecio !== "uid") {
                const error = "El campo 'tipoProcesadorPrecio' solo puede ser objeto o uid"
                throw new Error(error)
            }
            const transaccion = {
                "tipoProcesadorPrecio": tipoProcesadorPrecio,
                "reserva": reserva
            }
            const transaccionInterna = await precioReserva(transaccion)
            salida.json(transaccionInterna)
        } catch (err) {
            const error = {
                "error": err.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "insertarDatosFinancierosReservaExistente") {
        try {
            const reserva = entrada.body.reserva
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo1"
                throw new Error(error)
            }
            const transaccionPrecioReserva = {
                "tipoProcesadorPrecio": "uid",
                "reservaUID": reserva
            }
            const resuelvePrecioReserva = await insertarTotalesReserva(transaccionPrecioReserva)
            const metadatosDetallesReserva = {
                reservaUID: reserva
            }
            const reseuvleDetallesReserva = await detallesReserva(metadatosDetallesReserva)
            const respuesta = {
                "ok": resuelvePrecioReserva,
                "desgloseFinanciero": reseuvleDetallesReserva.desgloseFinanciero
            }
            salida.json(respuesta)
        } catch (err) {
            let error = {
                "error": err.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "estadoHabitacionesApartamento") {
        try {
            let apartamento = entrada.body.apartamento
            let reserva = entrada.body.reserva
            if (typeof apartamento !== "number" || !Number.isInteger(apartamento) || apartamento <= 0) {
                const error = "El campo 'apartamento' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            let transaccionInterna = {
                "apartamento": apartamento,
                "reserva": reserva
            }
            let resuelveHabitaciones = await estadoHabitacionesApartamento(transaccionInterna)
            let habitacionesResuelvas = resuelveHabitaciones.ok
            if (habitacionesResuelvas.length === 0) {
                let ok = {
                    "ok": []
                }
                salida.json(ok)
            }
            if (habitacionesResuelvas.length > 0) {
                let habitacionesProcesdas = []
                for (const habitacionPreProcesada of habitacionesResuelvas) {
                    const consultaHabitacion = `
                    SELECT habitacion, "habitacionUI"
                    FROM habitaciones
                    WHERE habitacion = $1
                    `
                    let resuelveHabitacion = await conexion.query(consultaHabitacion, [habitacionPreProcesada])
                    let habitacionIDV = resuelveHabitacion.rows[0].habitacion
                    let habitaconUI = resuelveHabitacion.rows[0].habitacionUI
                    let habitacionResuelta = {
                        "habitacionIDV": habitacionIDV,
                        "habitacionUI": habitaconUI
                    }
                    habitacionesProcesdas.push(habitacionResuelta)
                }
                let ok = {
                    "ok": habitacionesProcesdas
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message,
                "detalles": errorCapturado
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "anadirHabitacionAlApartamentoEnReserva") {
        const mutex = new Mutex();
        const bloqueoaAnadirHabitacionAlApartamentoEnReserva = await mutex.acquire();
        try {
            let apartamento = entrada.body.apartamento
            const reserva = entrada.body.reserva
            const habitacion = entrada.body.habitacion
            if (typeof apartamento !== "number" || !Number.isInteger(apartamento) || apartamento <= 0) {
                const error = "El campo 'apartamento' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(habitacion)) {
                const error = "el campo 'habitacion' solo puede ser letras min√∫sculas y numeros."
                throw new Error(error)
            }
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }
            // Mira las habitaciones diponbiles para anadira este apartamento
            const transaccionInterna = {
                "apartamento": apartamento,
                "reserva": reserva
            }
            const resuelveHabitaciones = await estadoHabitacionesApartamento(transaccionInterna)
            const habitacionesResuelvas = resuelveHabitaciones.ok
            if (habitacionesResuelvas.length === 0) {
                const error = `El apartamento no tiene disponibles mas habitaciones para ser anadidas en base a su configuracion glboal`
                throw new Error(error)
            }
            if (habitacionesResuelvas.length > 0) {
                for (const habitacionResuelta of habitacionesResuelvas) {
                    if (habitacion === habitacionResuelta) {

                        const resolucionNombreHabitacion = await conexion.query(`SELECT "habitacionUI" FROM habitaciones WHERE habitacion = $1`, [habitacion])
                        if (resolucionNombreHabitacion.rowCount === 0) {
                            const error = "No existe el identificador de la habitacionIDV"
                            throw new Error(error)
                        }
                        const habitacionUI = resolucionNombreHabitacion.rows[0].habitacionUI


                        const consultaInsertaHabitacion = `
                        INSERT INTO "reservaHabitaciones"
                        (
                        apartamento,
                        habitacion,
                        "habitacionUI",
                        reserva
                        )
                        VALUES ($1, $2, $3, $4) RETURNING uid
                        `
                        const resuelveInsercionHabitacion = await conexion.query(consultaInsertaHabitacion, [apartamento, habitacion, habitacionUI, reserva])
                        if (resuelveInsercionHabitacion.rowCount === 1) {
                            const ok = {
                                "ok": `Se ha anadido la ${habitacionUI} al apartamento`,
                                "nuevoUID": resuelveInsercionHabitacion.rows[0].uid
                            }
                            return salida.json(ok)
                        }

                    }
                }
                let error = {
                    "error": `No se puede anadir esta habitacion, revisa que este bien escrito los datos y que el apartamento tenga habitaciones disponibles`
                }
                salida.json(error)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoaAnadirHabitacionAlApartamentoEnReserva()
        }

    }
    if (transaccion === "anadirApartamentoReserva") {
        const mutex = new Mutex();
        const bloqueoAnadirApartamentoReserva = await mutex.acquire();
        try {
            const reserva = entrada.body.reserva
            const apartamento = entrada.body.apartamento
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(apartamento) || typeof apartamento !== "string") {
                const error = "el campo 'apartamento' solo puede ser una cadena de letras min√∫sculas y numeros."
                throw new Error(error)
            }
            // Validar que le nombre del apartamento existe como tal
            const validacionNombreApartamento = `
            SELECT *
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1
            `
            let resuelveValidacionNombreApartamento = await conexion.query(validacionNombreApartamento, [apartamento])
            if (resuelveValidacionNombreApartamento.rowCount === 0) {
                const error = "No existe el nombre del apartamento, revisa el nombre escrito"
                throw new Error(error)
            }


            // valida reserva y obten fechas
            const validacionReserva = `
            SELECT 
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida,
            "estadoReserva", 
            "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // Comprobar si existen totales en esta reserva
            const validarExistenciaTotales = `
           SELECT 
           *
           FROM "reservaTotales"
           WHERE reserva = $1
           `
            const resuelveValidarExistenciaTotales = await conexion.query(validarExistenciaTotales, [reserva])
            let estadoInfomracionFinanciera = "noActualizar"
            if (resuelveValidarExistenciaTotales.rowCount > 0) {
                const transaccionPrecioReserva = {
                    "tipoProcesadorPrecio": "uid",
                    "reservaUID": reserva
                }
                await insertarTotalesReserva(transaccionPrecioReserva)
                estadoInfomracionFinanciera = "actualizar"

            }

            let fechaEntrada = resuelveValidacionReserva.rows[0].entrada
            let fechaSalida = resuelveValidacionReserva.rows[0].salida
            // ACABAR ESTA SENTENCIA DE ABAJO--
            // validar que el apartamento no este ya en la reserva
            const validacionHabitacionYaExisteneEnReserva = `
            SELECT 
            apartamento
            FROM "reservaApartamentos"
            WHERE reserva = $1 AND apartamento = $2
            `
            let resuelvevalidacionHabitacionYaExisteneEnReserva = await conexion.query(validacionHabitacionYaExisteneEnReserva, [reserva, apartamento])
            if (resuelvevalidacionHabitacionYaExisteneEnReserva.rowCount === 1) {
                const error = "El apartamento ya existe en la reserva"
                throw new Error(error)
            }

            // Validar que el apartamento esta diponbiles en el modo normal, sacando las fechas de la reserva
            let transacion = {
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida

            }
            let resuelveApartamentosDisponibles = await apartamentosDisponiblesAdministracion(transacion)

            let apartamentosDisponiblesResueltos = resuelveApartamentosDisponibles.apartamentosDisponibles
            if (apartamentosDisponiblesResueltos.length === 0) {
                const error = "No hay ningun apartamento disponbile para las fechas de la reserva"
                throw new Error(error)
            }
            if (apartamentosDisponiblesResueltos.length > 0) {
                for (const apartamentosDisponible of apartamentosDisponiblesResueltos) {
                    if (apartamento === apartamentosDisponible) {


                        const apartamentoUI = await resolverApartamentoUI(apartamento)

                        const insertarApartamento = `
                        INSERT INTO "reservaApartamentos"
                        (
                        reserva,
                        apartamento,
                        "apartamentoUI"
                        )
                        VALUES ($1, $2, $3) RETURNING uid
                        `
                        let resuelveInsertarApartamento = await conexion.query(insertarApartamento, [reserva, apartamento, apartamentoUI])
                        if (resuelveInsertarApartamento.rowCount === 1) {
                            const ok = {
                                "ok": "apartamento anadido correctamente",
                                "apartamentoIDV": apartamento,
                                "apartamentoUI": apartamentoUI,
                                "nuevoUID": resuelveInsertarApartamento.rows[0].uid,
                                "estadoDesgloseFinanciero": estadoInfomracionFinanciera
                            }
                            salida.json(ok)
                        }
                        break
                    }
                }
                const error = "ha ocurrido un error y no se ha funcionado la comparacion correctamente"
                throw new Error(error)
            }
            // En el modo forzoso el apartamento entra igual
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoAnadirApartamentoReserva()
        }
    }
    if (transaccion === "eliminarApartamentoReserva") {
        const mutex = new Mutex();
        const bloqueoEliminarApartamentoReserva = await mutex.acquire();
        try {

            const reserva = entrada.body.reserva
            // apartamentoUID
            const apartamento = entrada.body.apartamento
            const tipoBloqueo = entrada.body.tipoBloqueo
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof apartamento !== "number" || !Number.isInteger(apartamento) || apartamento <= 0) {
                const error = "el campo 'apartamento' solo puede un numero, entero y positivo"
                throw new Error(error)
            }

            if (tipoBloqueo !== "permanente" && tipoBloqueo !== "rangoTemporal" && tipoBloqueo !== "sinBloqueo") {
                const error = "El campo 'tipoBloqueo' solo puede ser 'permanente', 'rangoTemporal', 'sinBloquo'"
                throw new Error(error)
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida,
            "estadoReserva",
            "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // Comprobar si existen totales en esta reserva
            const validarExistenciaTotales = `
            SELECT 
            *
            FROM "reservaTotales"
            WHERE reserva = $1
            `
            const resuelveValidarExistenciaTotales = await conexion.query(validarExistenciaTotales, [reserva])
            let estadoInfomracionFinanciera = "noActualizar"

            if (resuelveValidarExistenciaTotales.rowCount > 0) {
                const transaccionPrecioReserva = {
                    "tipoProcesadorPrecio": "uid",
                    "reservaUID": reserva
                }
                await insertarTotalesReserva(transaccionPrecioReserva)
                estadoInfomracionFinanciera = "actualizar"

            }








            const fechaEntrada = resuelveValidacionReserva.rows[0].entrada
            const fechaSalida = resuelveValidacionReserva.rows[0].salida

            const metadatos = {
                "reserva": reserva,
                "apartamentoUID": apartamento,
                "tipoBloqueo": tipoBloqueo,
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida
            }
            const transaccionInterna = await bloquearApartamentos(metadatos)

            const eliminaApartamentoReserva = `
            DELETE FROM "reservaApartamentos"
            WHERE uid = $1 AND reserva = $2;
            `
            const resuelveEliminaApartamentoReserva = await conexion.query(eliminaApartamentoReserva, [apartamento, reserva])
            if (resuelveEliminaApartamentoReserva.rowCount === 1) {
                const ok = {};
                ok.estadoDesgloseFinanciero = estadoInfomracionFinanciera
                if (tipoBloqueo === "rangoTemporal") {
                    ok.ok = "Se ha eliminado el apartamento y aplicado el bloqueo temporal"
                }
                if (tipoBloqueo === "permanente") {
                    ok.ok = "Se ha eliminado el apartamento y aplicado el bloqueo permanente"
                }
                if (tipoBloqueo === "sinBloqueo") {
                    ok.ok = "Se ha eliminado el apartamento de la reserva y se ha liberado"
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoEliminarApartamentoReserva()
        }




    }
    if (transaccion === "eliminarHabitacionReserva") {
        const mutex = new Mutex();
        const bloqueoEliminarHabitacionReserva = await mutex.acquire();
        try {

            let reserva = entrada.body.reserva
            // apartamentoUID
            let habitacion = entrada.body.habitacion
            let pernoctantes = entrada.body.pernoctantes
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof habitacion !== "number" || !Number.isInteger(habitacion) || habitacion <= 0) {
                const error = "el campo 'habitacion' solo puede un numero, entero y positivo"
                throw new Error(error)
            }
            if (pernoctantes !== "conservar" && pernoctantes !== "eliminar") {
                const error = "El campo 'pernoctantes' solo puede ser 'conservar', 'mantener'"
                throw new Error(error)
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // validar habitacion
            const validacionHabitacion = `
            SELECT 
            uid
            FROM "reservaHabitaciones"
            WHERE reserva = $1 AND uid = $2
            `
            let resuelveValidacionHabitacion = await conexion.query(validacionHabitacion, [reserva, habitacion])
            if (resuelveValidacionHabitacion.rowCount === 0) {
                const error = "No existe la habitacion dentro de la reserva"
                throw new Error(error)
            }
            let ok;
            if (pernoctantes === "eliminar") {
                let eliminarPernoctantes = `
                DELETE FROM "reservaPernoctantes"
                WHERE habitacion = $1 AND reserva = $2;
                `
                let resuelveEliminarPernoctantes = await conexion.query(eliminarPernoctantes, [habitacion, reserva])
                ok = {
                    "ok": "Se ha eliminado al habitacion correctamente y los pernoctanes que contenia"
                }
            }
            let eliminaHabitacionReserva = `
            DELETE FROM "reservaHabitaciones"
            WHERE uid = $1 AND reserva = $2;
            `
            let resuelveEliminaHabitacionReserva = await conexion.query(eliminaHabitacionReserva, [habitacion, reserva])
            if (pernoctantes === "conservar") {
                let desasignaPernoctanteDeHabitacion = `
                UPDATE "reservaPernoctantes"
                SET habitacion = NULL
                WHERE reserva = $1 AND habitacion = $2;
                `
                await conexion.query(desasignaPernoctanteDeHabitacion, [reserva, habitacion])

                ok = {
                    "ok": "Se ha eliminado al habitacion correctamente pero los pernoctantes que contenia siguen asignados a la reserva"
                }
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoEliminarHabitacionReserva()
        }
    }
    if (transaccion === "anadirPernoctanteHabitacion") {
        const mutex = new Mutex();
        const bloqueoAnadirPernoctanteHabitacion = await mutex.acquire();
        try {
            const reserva = entrada.body.reserva
            const habitacionUID = entrada.body.habitacionUID
            const clienteUID = entrada.body.clienteUID
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof habitacionUID !== "number" || !Number.isInteger(habitacionUID) || habitacionUID <= 0) {
                const error = "el campo 'habitacionUID' solo puede un numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof clienteUID !== "number" || !Number.isInteger(clienteUID) || clienteUID <= 0) {
                const error = "el campo 'clienteUID' solo puede un numero, entero y positivo"
                throw new Error(error)
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            reserva,
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida,
            "estadoReserva",
            "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            let fechaEntrada = resuelveValidacionReserva.rows[0].entrada
            fechaEntrada = fechaEntrada.split("/")
            const diaEntrada = fechaEntrada[0]
            const mesEntrada = fechaEntrada[1]
            const anoEntrada = fechaEntrada[2]
            fechaEntrada = `${diaEntrada}/${mesEntrada}/${anoEntrada}`

            let fechaSalida = resuelveValidacionReserva.rows[0].salida
            fechaSalida = fechaSalida.split("/")
            const diaSalida = fechaSalida[0]
            const mesSalida = fechaSalida[1]
            const anoSalida = fechaSalida[2]
            fechaSalida = `${diaSalida}/${mesSalida}/${anoSalida}`

            const consultaReservasRangoInteracion = `
            SELECT reserva 
            FROM reservas 
            WHERE entrada <= $1::DATE AND salida >= $2::DATE;`
            const resuelveConsultaReservasRangoInteracion = await conexion.query(consultaReservasRangoInteracion, [fechaSalida, fechaEntrada])
            let interruptorClienteEncontrado;
            if (resuelveConsultaReservasRangoInteracion.rowCount > 0) {
                const reservas = resuelveConsultaReservasRangoInteracion.rows
                for (const reserva of reservas) {
                    const reservaUID = reserva.reserva
                    const buscarClienteEnOtrasReservas = `
                    SELECT pernoctante 
                    FROM "reservaPernoctantes" 
                    WHERE pernoctante = $1 AND reserva = $2;`
                    const resuelveBuscarClienteEnOtrasReservas = await conexion.query(buscarClienteEnOtrasReservas, [clienteUID, reservaUID])
                    if (resuelveBuscarClienteEnOtrasReservas.rowCount === 1) {
                        interruptorClienteEncontrado = "encontrado"
                        break
                    }
                }
            }

            if (interruptorClienteEncontrado === "encontrado") {
                const error = "Este cliente no se puede anadir a esta reserva por que esta en otra reserva cuyo rango de fecha coincide con esta, dicho de otra manera, si se anadiese este cliente en esta reserva, puede que en un dia o en mas de un dia este cliente estaria asignado a un apartmento distingo en fechas coincidentes"
                throw new Error(error)
            }

            // validar habitacion
            const validacionHabitacion = `
            SELECT 
            uid
            FROM "reservaHabitaciones"
            WHERE reserva = $1 AND uid = $2
            `
            const resuelveValidacionHabitacion = await conexion.query(validacionHabitacion, [reserva, habitacionUID])
            if (resuelveValidacionHabitacion.rowCount === 0) {
                const error = "No existe la habitacion dentro de esta reserva"
                throw new Error(error)
            }
            // validar cliente
            const validacionCliente = `
            SELECT 
            uid
            FROM clientes
            WHERE uid = $1
            `
            let resuelveValidacionCliente = await conexion.query(validacionCliente, [clienteUID])
            if (resuelveValidacionCliente.rowCount === 0) {
                const error = "No existe el cliente"
                throw new Error(error)
            }


            // No se puede anadir un pernoctante ya existen a la reserva, proponer moverlo de habitacion
            const validacionUnicidadPernoctante = `
            SELECT 
            uid
            FROM "reservaPernoctantes"
            WHERE pernoctante = $1 AND reserva = $2
            `
            const resuelveValidacionUnicidadPernoctante = await conexion.query(validacionUnicidadPernoctante, [clienteUID, reserva])
            if (resuelveValidacionUnicidadPernoctante.rowCount === 1) {
                const error = "Este cliente ya es un pernoctante dentro de esta reserva, mejor muevalo de habitacion"
                throw new Error(error)
            }
            const insertarClienteExistenteEnReserva = `
            INSERT INTO "reservaPernoctantes"
            (reserva,habitacion,pernoctante)
            VALUES ($1, $2,$3) RETURNING uid
            `
            const resuelveInsertarClienteExistenteEnReserva = await conexion.query(insertarClienteExistenteEnReserva, [reserva, habitacionUID, clienteUID])
            if (resuelveInsertarClienteExistenteEnReserva.rowCount === 1) {
                const ok = {
                    "ok": "Se ha anadido correctamente el cliente en la habitacin de la reserva",
                    "nuevoUID": resuelveInsertarClienteExistenteEnReserva.rows[0].uid
                }
                salida.json(ok)
            }
            if (resuelveInsertarClienteExistenteEnReserva.rowCount === 0) {
                const error = "Ha ocurrido un error al final del proceso y no se ha anadido el cliente"
                throw new Error(error)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoAnadirPernoctanteHabitacion()
        }
    }
    if (transaccion === "crearClienteDesdeReservaYAnadirloAreserva") {
        const mutex = new Mutex();
        const bloqueoCrearClienteDesdeReservaYAnadirloAreserva = await mutex.acquire();
        try {
            let reserva = entrada.body.reserva
            let habitacionUID = entrada.body.habitacionUID
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let correoElectronico = entrada.body.correoElectronico
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            if (typeof habitacionUID !== "number" || !Number.isInteger(habitacionUID) || habitacionUID <= 0) {
                const error = "el campo 'habitacionUID' solo puede un numero, entero y positivo"
                throw new Error(error)
            }
            const filtroCadena = /^[a-zA-Z0-9\s]+$/;

            if (nombre?.length > 0) {
                if (!filtroCadena.test(nombre)) {
                    const error = "el campo 'nombre' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                nombre = nombre.trim();
                nombre = nombre.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'nombre' es obligatorio."
                throw new Error(error)
            }

            if (primerApellido?.length > 0) {
                if (!filtroCadena.test(primerApellido)) {
                    const error = "el campo 'primerApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                primerApellido = primerApellido.trim();
                primerApellido = primerApellido.replace(/\s+/g, ' ');
            }

            if (segundoApellido?.length > 0) {
                if (!filtroCadena.test(segundoApellido)) {
                    const error = "el campo 'segundoApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                segundoApellido = segundoApellido.trim();
                segundoApellido = segundoApellido.replace(/\s+/g, ' ');
            }
            if (pasaporte?.length > 0) {
                const filtroPasaporte = /^[a-zA-Z0-9]+$/;

                if (!filtroPasaporte.test(pasaporte)) {
                    const error = "el campo 'pasaporte' solo puede ser letras min√∫sculas, masculas y numeros."
                    throw new Error(error)
                }
                pasaporte = pasaporte.trim();
                pasaporte = pasaporte.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'pasaporte' es obligatorio."
                throw new Error(error)
            }
            if (telefono?.length > 0) {
                if (typeof telefono !== "number" || Number.isInteger(telefono) || telefono <= 0) {
                    const error = "el campo 'telefono' solo puede un numero, entero y positivo"
                    throw new Error(error)
                }
                telefono = telefono.trim();
                telefono = telefono.replace(/\s+/g, '');
            }
            if (correoElectronico?.length > 0) {
                const filtroCorreoElectronico = /^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/;
                if (!filtroCorreoElectronico.test(correoElectronico)) {
                    const error = "el campo 'correoElectronico' no cumple con el formato esperado"
                    throw new Error(error)
                }
                correoElectronico = correoElectronico.trim();
                correoElectronico = correoElectronico.replace(/\s+/g, '');
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // validar habitacion
            const validacionHabitacion = `
            SELECT 
            uid
            FROM "reservaHabitaciones"
            WHERE reserva = $1 AND uid = $2
            `
            let resuelveValidacionHabitacion = await conexion.query(validacionHabitacion, [reserva, habitacionUID])
            if (resuelveValidacionHabitacion.rowCount === 0) {
                const error = "No existe la habitacion dentro de esta reserva"
                throw new Error(error)
            }
            // Se anade como cliente en la base de datos de clientes y luego se asocia a la habitacion
            let insertarCliente = `
            INSERT INTO clientes
            (nombre,"primerApellido","segundoApellido",pasaporte,telefono,email)
            VALUES ($1,$2,$3,$4,$5,$6) RETURNING uid
            `
            let resuelveInsertarCliente = await conexion.query(insertarCliente, [nombre, primerApellido, segundoApellido, pasaporte, telefono, correoElectronico])
            if (resuelveInsertarCliente.rowCount === 0) {
                const error = "No se ha insertardo el cliente en la base de datos"
                throw new Error(error)
            }
            let nuevoUIDCliente = resuelveInsertarCliente.rows[0].uid
            let insertarPernoctante = `
            INSERT INTO "reservaPernoctantes"
            (reserva,habitacion,pernoctante)
            VALUES ($1,$2,$3) RETURNING uid
            `
            let resuelveInsertarPernoctante = await conexion.query(insertarPernoctante, [reserva, habitacionUID, nuevoUIDCliente])
            if (resuelveInsertarPernoctante.rowCount === 0) {
                const error = "No se ha insertardo el pernoctante en al reserva"
                throw new Error(error)
            }
            if (resuelveInsertarPernoctante.rowCount === 1) {
                let ok = {
                    "ok": "Se ha anadido correctamente el cliente en la habitacin de la reserva",
                    "nuevoUIDPernoctante": resuelveInsertarPernoctante.rows[0].uid,
                    "nuevoUIDCliente": resuelveInsertarCliente.rows[0].uid
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoCrearClienteDesdeReservaYAnadirloAreserva()
        }
    }
    if (transaccion === "eliminarPernoctanteReserva") {

        const mutex = new Mutex();
        const bloqueoEliminarPernoctanteReserva = await mutex.acquire();
        try {
            let reserva = entrada.body.reserva
            let pernoctanteUID = entrada.body.pernoctanteUID
            let tipoElinacion = entrada.body.tipoEliminacion
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof pernoctanteUID !== "number" || !Number.isInteger(pernoctanteUID) || pernoctanteUID <= 0) {
                const error = "El campo 'pernoctanteUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof tipoElinacion !== "string" || (tipoElinacion !== "habitacion" && tipoElinacion !== "reserva")) {
                const error = "El campo 'tipoElinacion' solo puede ser 'habitacion' o 'reserva'"
                throw new Error(error)
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // validar habitacion
            let validarCliente = `
                SELECT 
                uid
                FROM "reservaPernoctantes"
                WHERE reserva = $1 AND uid = $2
                `
            let resuelveValidarCliente = await conexion.query(validarCliente, [reserva, pernoctanteUID])
            if (resuelveValidarCliente.rowCount === 0) {
                const error = "No existe el pernoctante en la reserva"
                throw new Error(error)
            }
            let sentenciaDinamica;
            if (tipoElinacion === "habitacion") {
                sentenciaDinamica = `
                UPDATE "reservaPernoctantes"
                SET habitacion = NULL
                WHERE reserva = $1 AND uid = $2 ;
                `
            }
            if (tipoElinacion === "reserva") {
                sentenciaDinamica = `
                DELETE FROM "reservaPernoctantes"
                WHERE reserva = $1 AND uid = $2;
                `
            }
            let actualicarPernoctante = await conexion.query(sentenciaDinamica, [reserva, pernoctanteUID])
            if (actualicarPernoctante.rowCount === 0) {
                const error = "No existe el pernoctante en la reserva, por lo tanto no se puede actualizar"
                throw new Error(error)
            }
            if (actualicarPernoctante.rowCount === 1) {
                let ok
                if (tipoElinacion === "habitacion") {
                    ok = {
                        "ok": "Se ha eliminado al pernoctante de la habitacion"
                    }
                }
                if (tipoElinacion === "reserva") {
                    ok = {
                        "ok": "Se ha eliminar al pernoctante de la reserva"
                    }
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoEliminarPernoctanteReserva()
        }
    }
    if (transaccion === "guardarNuevoClienteYSustituirloPorElClientePoolActual") {
        const mutex = new Mutex();
        const bloqueoGuardarNuevoClienteYSustituirloPorElClientePoolActual = await mutex.acquire();
        try {
            const reserva = entrada.body.reserva
            const pernoctanteUID = entrada.body.pernoctanteUID
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let correoElectronico = entrada.body.correoElectronico
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (typeof pernoctanteUID !== "number" || !Number.isInteger(pernoctanteUID) || pernoctanteUID <= 0) {
                const error = "el campo 'pernoctanteUID' solo puede un numero, entero y positivo"
                throw new Error(error)
            }
            const filtroCadena = /^[a-zA-Z0-9\s]+$/;
            if (nombre?.length > 0) {
                if (!filtroCadena.test(nombre)) {
                    const error = "el campo 'nombre' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }

                nombre = nombre.trim();
                nombre = nombre.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'nombre' es obligatorio."
                throw new Error(error)
            }
            if (primerApellido?.length > 0) {
                if (!filtroCadena.test(primerApellido)) {
                    const error = "el campo 'primerApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                primerApellido = primerApellido.trim();
                primerApellido = primerApellido.replace(/\s+/g, ' ');
            }
            if (segundoApellido?.length > 0) {
                if (!filtroCadena.test(segundoApellido)) {
                    const error = "el campo 'segundoApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                segundoApellido = segundoApellido.trim();
                segundoApellido = segundoApellido.replace(/\s+/g, ' ');
            }
            if (pasaporte?.length > 0) {
                const filtroPasaporte = /^[a-zA-Z0-9]+$/;

                if (!filtroPasaporte.test(pasaporte)) {
                    const error = "el campo 'pasaporte' solo puede ser letras min√∫sculas, masculas y numeros."
                    throw new Error(error)
                }
                pasaporte = pasaporte.trim();
                pasaporte = pasaporte.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'pasaporte' es obligatorio."
                throw new Error(error)
            }
            if (telefono?.length > 0) {
                if (typeof telefono !== "number" || Number.isInteger(telefono) || telefono <= 0) {
                    const error = "el campo 'telefono' solo puede un numero, entero y positivo"
                    throw new Error(error)
                }
                telefono = telefono.trim();
                telefono = telefono.replace(/\s+/g, '');
            }
            if (correoElectronico?.length > 0) {
                const filtroCorreoElectronico = /^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/;
                if (!filtroCorreoElectronico.test(correoElectronico)) {
                    const error = "el campo 'correoElectronico' no cumple con el formato esperado"
                    throw new Error(error)
                }
                correoElectronico = correoElectronico.trim();
                correoElectronico = correoElectronico.replace(/\s+/g, '');
            }
            // Comprobar que la reserva exisste
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            // validar pernoctante y extraer el UID del clientePool
            const validacionPernoctante = `
            SELECT 
            "pernoctantePool", pernoctante
            FROM "reservaPernoctantes"
            WHERE reserva = $1 AND uid = $2
            `
            const resuelveValidacionPernoctante = await conexion.query(validacionPernoctante, [reserva, pernoctanteUID])
            if (resuelveValidacionPernoctante.rowCount === 0) {
                const error = "No existe el pernoctante dentro de esta reserva"
                throw new Error(error)
            }
            const clientePoolUID = resuelveValidacionPernoctante.rows[0].pernoctantePool
            const pernoctanteUIDControl = resuelveValidacionPernoctante.rows[0].pernoctante
            if (pernoctanteUIDControl && !clientePoolUID) {
                const error = "El pernoctnte ya es un cliente y un clientePool"
                throw new Error(error)
            }
            const ok = {}
            const insertarCliente = `
            INSERT INTO clientes
            (nombre,"primerApellido","segundoApellido",pasaporte,telefono,email)
            VALUES ($1,$2,$3,$4,$5,$6) RETURNING uid
            `
            const resuelveInsertarCliente = await conexion.query(insertarCliente, [nombre, primerApellido, segundoApellido, pasaporte, telefono, correoElectronico])
            if (resuelveInsertarCliente.rowCount === 0) {
                const error = "No se ha insertardo el cliente en la base de datos"
                throw new Error(error)
            }
            const nuevoUIDCliente = resuelveInsertarCliente.rows[0].uid

            // Borrar clientePool
            const eliminarClientePool = `
            DELETE FROM "poolClientes"
            WHERE uid = $1;
            `
            const resuelveEliminarClientePool = await conexion.query(eliminarClientePool, [clientePoolUID])
            if (resuelveEliminarClientePool.rowCount === 0) {
                ok["informacion"] = "No se ha encontrado un clientePool asociado al pernoctante"

            }
            const actualizaPernoctanteReserva =
                `
                UPDATE "reservaPernoctantes"
                SET "pernoctantePool" = NULL, pernoctante = $3
                WHERE reserva = $1 AND uid = $2 ;
                `
            const resuelveActualizaPernoctanteReserva = await conexion.query(actualizaPernoctanteReserva, [reserva, pernoctanteUID, nuevoUIDCliente])
            if (resuelveActualizaPernoctanteReserva.rowCount === 0) {
                const error = "No se ha podido actualizar al pernoctante dentro de la reserva"
                throw new Error(error)
            }
            if (resuelveActualizaPernoctanteReserva.rowCount === 1) {
                primerApellido = primerApellido ? primerApellido : ""
                segundoApellido = segundoApellido ? segundoApellido : ""
                ok["ok"] = "Se ha guardado al nuevo cliente y sustituido por el clientePool, tambien se ha eliminado al clientePool de la base de datos"
                ok["nuevoClienteUID"] = nuevoUIDCliente
                ok["nombreCompleto"] = `${nombre} ${primerApellido} ${segundoApellido}`
                ok["pasaporte"] = pasaporte
                salida.json(ok)

            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoGuardarNuevoClienteYSustituirloPorElClientePoolActual()
        }
    }
    if (transaccion === "modificarFechaReserva") {
        const mutex = new Mutex();
        const bloqueoModificarFechaReserva = await mutex.acquire();
        try {
            const reserva = entrada.body.reserva
            const fechaSeleccionada = entrada.body.fechaSeleccionada
            const sentidoRango = entrada.body.sentidoRango
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const filtroFecha = /^\d{2}\/\d{2}\/\d{4}$/;
            if (sentidoRango !== "pasado" && sentidoRango !== "futuro") {
                const error = "El campo 'sentidoRango' solo puede ser pasado o futuro"
                throw new Error(error)
            }
            const metadatos = {
                "reserva": reserva,
                "fechaSeleccionada": fechaSeleccionada,
                "sentidoRango": sentidoRango
            }
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            let transaccionInterna = await validarModificacionRangoFechaResereva(metadatos)
            salida.json(transaccionInterna)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoModificarFechaReserva()
        }
    }
    if (transaccion === "estadoReserva") {
        try {
            let reserva = entrada.body.reserva
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const consultaEstadoReservas = `
            SELECT 
            reserva,
            "estadoPago",
            "estadoReserva"
            FROM reservas 
            WHERE reserva = $1;`
            const resuelveConsultaEstadoReservas = await conexion.query(consultaEstadoReservas, [reserva])
            if (resuelveConsultaEstadoReservas.rowCount === 0) {
                const error = "No existe al reserva"
                throw new Error(error)
            }
            if (resuelveConsultaEstadoReservas.rowCount === 1) {
                const ok = {
                    "estadoReserva": resuelveConsultaEstadoReservas.rows[0].estadoReserva,
                    "estadoPago": resuelveConsultaEstadoReservas.rows[0].estadoPago
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "confirmarModificarFechaReserva") {
        const mutex = new Mutex();
        const bloqueoConfirmarModificarFechaReserva = await mutex.acquire();
        try {
            const reserva = entrada.body.reserva
            const tipoFecha = entrada.body.tipoFecha
            const fecha = entrada.body.fecha
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (tipoFecha !== "entrada" && tipoFecha !== "salida") {
                const error = "El campo 'tipoFecha' solo puede ser entrada o salida"
                throw new Error(error)
            }
            const filtroFecha = /^\d{2}\/\d{2}\/\d{4}$/;
            if (!filtroFecha.test(fecha)) {
                const error = "El campo 'fecha' debe de tener este formado 00/00/0000"
                throw new Error(error)
            }
            const validacionReserva = `
            SELECT 
            reserva, "estadoReserva", "estadoPago"
            FROM reservas
            WHERE reserva = $1
            `
            const resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            if (resuelveValidacionReserva.rows[0].estadoReserva === "cancelada") {
                const error = "La reserva no se puede modificar por que esta cancelada"
                throw new Error(error)
            }

            if (resuelveValidacionReserva.rows[0].estadoPago === "pagado") {
                const error = "La reserva no se puede modificar por que esta pagada"
                throw new Error(error)
            }

            if (tipoFecha === "entrada") {
                const metadatos = {
                    "reserva": reserva,
                    "fechaSeleccionada": fecha,
                    "sentidoRango": "pasado"
                }
                const transaccionInterna = await validarModificacionRangoFechaResereva(metadatos)
                if (transaccionInterna.ok?.limitePasado) {
                    const fechaLimitePasado = new Date(convertirFechaISO8601(transaccionInterna.ok?.limitePasado));
                    const fechaSeleccionadaEntrada = new Date(convertirFechaISO8601(fecha));
                    if (fechaLimitePasado >= fechaSeleccionadaEntrada) {
                        const error = "No se puede confirmar el cambio de la fecha por que ya no esta disponible el rango temporal"
                        throw new Error(error)
                    }
                }
                const actualizarModificacionFechaEntradaReserva = `
                UPDATE reservas
                SET entrada = $1
                WHERE reserva = $2;
                `
                const resuelveActualizarModificacionFechaEntradaReserva = await conexion.query(actualizarModificacionFechaEntradaReserva, [fecha, reserva])
                if (resuelveActualizarModificacionFechaEntradaReserva.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha actualizado correctamente la fecha de entrada en la reserva"
                    }
                    salida.json(ok)
                }
            }
            if (tipoFecha === "salida") {
                const metadatos = {
                    "reserva": reserva,
                    "fechaSeleccionada": fecha,
                    "sentidoRango": "futuro"
                }

                const transaccionInterna = await validarModificacionRangoFechaResereva(metadatos)
                if (transaccionInterna.ok?.limiteFuturo) {
                    const fechaLimiteFuturo = new Date(convertirFechaISO8601(transaccionInterna.ok?.limiteFuturo));
                    const fechaSeleccionadaSalida = new Date(convertirFechaISO8601(fecha));
                    if (fechaLimiteFuturo <= fechaSeleccionadaSalida) {
                        const error = "No se puede confirmar el cambio de la fecha por que ya no esta disponible el rango temporal"
                        throw new Error(error)
                    }
                }
                const actualizarModificacionFechaEntradaReserva = `
                UPDATE reservas
                SET salida = $1
                WHERE reserva = $2;
                `
                const resuelveActualizarModificacionFechaEntradaReserva = await conexion.query(actualizarModificacionFechaEntradaReserva, [fecha, reserva])
                if (resuelveActualizarModificacionFechaEntradaReserva.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha actualizado correctamente la fecha de entrada en la reserva"
                    }
                    salida.json(ok)
                }
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoConfirmarModificarFechaReserva()
        }
    }
    if (transaccion === "cancelarReserva") {
        try {
            let reserva = entrada.body.reserva
            let tipoBloqueo = entrada.body.tipoBloqueo
            if (typeof reserva !== "number" || !Number.isInteger(reserva) || reserva <= 0) {
                const error = "El campo 'reserva' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            if (tipoBloqueo !== "rangoTemporal" && tipoBloqueo !== "permanente" && tipoBloqueo !== "sinBloqueo") {
                const error = "El campo 'tipoBloqueo' solo puede ser rangoTemporal, permanente, liberar"
                throw new Error(error)
            }
            const validacionReserva = `
            SELECT 
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida
            FROM reservas
            WHERE reserva = $1
            `
            let resuelveValidacionReserva = await conexion.query(validacionReserva, [reserva])
            if (resuelveValidacionReserva.rowCount === 0) {
                const error = "No existe la reserva"
                throw new Error(error)
            }
            let fechaEntrada = resuelveValidacionReserva.rows[0].entrada
            let fechaSalida = resuelveValidacionReserva.rows[0].salida
            // extraer todos los apartamentos de la reserva
            const seleccionarApartamentosReserva = `
            SELECT 
            uid
            FROM "reservaApartamentos"
            WHERE reserva = $1
            `
            let resuelveSeleccionarApartamentosReserva = await conexion.query(seleccionarApartamentosReserva, [reserva])
            let estadoReserva = "cancelada"
            if (resuelveSeleccionarApartamentosReserva.rowCount === 0) {
                let actualizarEstadoReserva = `
                UPDATE reservas
                SET "estadoReserva" = $2
                WHERE reserva = $1 ;
                `
                let resuelveActualizarEstadoReserva = await conexion.query(actualizarEstadoReserva, [reserva, estadoReserva])
                if (resuelveActualizarEstadoReserva.rowCount === 1) {
                    let ok = {
                        "ok": "La reserva se ha cancelado"
                    }
                    salida.json(ok)
                }
            }
            if (resuelveSeleccionarApartamentosReserva.rowCount > 0) {
                let apartamentosReserva = resuelveSeleccionarApartamentosReserva.rows
                for (const apartamento of apartamentosReserva) {
                    let metadatos = {
                        "reserva": reserva,
                        "apartamentoUID": apartamento.uid,
                        "tipoBloqueo": tipoBloqueo,
                        "fechaEntrada": fechaEntrada,
                        "fechaSalida": fechaSalida
                    }
                    await bloquearApartamentos(metadatos)
                }
                let actualizarEstadoReserva = `
                UPDATE reservas
                SET "estadoReserva" = $2
                WHERE reserva = $1 ;
                `
                let resuelveActualizarEstadoReserva = await conexion.query(actualizarEstadoReserva, [reserva, estadoReserva])
                if (resuelveActualizarEstadoReserva.rowCount === 1) {
                    let ok = {
                        "ok": "La reserva se ha cancelado"
                    }
                    salida.json(ok)
                }
            }
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        } finally {
            
        }
    }
    if (transaccion === "diasOcupadosTotalmentePorMes") {

        try {
            const mes = entrada.body.mes
            const ano = entrada.body.ano
            if (typeof mes !== "number" || !Number.isInteger(mes) || mes < 0 || mes > 12) {
                const error = "El campo 'mes' solo puede ser un numero entero y positivo entre el 1 y el 12"
                throw new Error(error)
            }

            if (typeof ano !== "number" || !Number.isInteger(ano) || ano < 0) {
                const error = "El campo 'ano' solo puede ser un numero entero y positivo y superior a 0"
                throw new Error(error)
            }
            // Aqui falta especificar que las fechas no sean canceladas
            const reservarEnEseMes = `
            SELECT 
            reserva,
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida
            FROM reservas
            WHERE
              -- Reservas que tienen alguna intersecci√≥n con el mes y ano especificados
              (
                (EXTRACT(MONTH FROM entrada) = $1 AND EXTRACT(YEAR FROM entrada) = $2)
                OR
                (EXTRACT(MONTH FROM salida) = $1 AND EXTRACT(YEAR FROM salida) = $2)
                OR
                (
                  (EXTRACT(MONTH FROM entrada) < $1 AND EXTRACT(YEAR FROM entrada) = $2) 
                  AND 
                  (EXTRACT(MONTH FROM salida) > $1 AND EXTRACT(YEAR FROM salida) = $2)
                )
              )
           `
            const resuelveReservarEnEseMes = await conexion.query(reservarEnEseMes, [mes, ano])
            const reservasCoincidentes = resuelveReservarEnEseMes.rows

            // Cuantos apartamentos disponivles existen como confirmacion
            const estadoApartamentoDisponbile = "disponible"
            const consultaApartamentosDisponibles = `
            SELECT 
            "apartamentoIDV"
            FROM "configuracionApartamento"
            WHERE "estadoConfiguracion" = $1;          
           `
            const resuelveConsultaApartamentosDisponibles = await conexion.query(consultaApartamentosDisponibles, [estadoApartamentoDisponbile])
            if (resuelveConsultaApartamentosDisponibles.rowCount === 0) {
                const error = "No hay ningun apartamento disponible"
                throw new Error(error)
            }

            const apartamentosDisponiblesPorFormatear = resuelveConsultaApartamentosDisponibles.rows
            const apartamentosDisponbiles = []

            apartamentosDisponiblesPorFormatear.map((apartamento) => {
                apartamentosDisponbiles.push(apartamento.apartamentoIDV)
            })
            const obtenerFechasInternas = (fechaEntrada, fechaSalida) => {
                const fechasInternas = [];
                const fechaActual = new Date(fechaEntrada);
                const fechahFin = new Date(fechaSalida);

                while (fechaActual <= fechahFin) {
                    const fechaUTC = new Date(fechaActual)
                    const diaInterno = fechaUTC.getDate();
                    const mesInterno = fechaUTC.getMonth() + 1; // El mes se indexa desde 0, por lo tanto, se le suma 1
                    const anoInterno = fechaUTC.getFullYear();
                    //const fechaFormateada = `${diaInterno.toString().padStart(2, '0')}/${mesInterno.toString().padStart(2, '0')}/${anoInterno}`;
                    const diaFinal = diaInterno.toString().padStart(2, '0')
                    if (mes === mesInterno && ano === anoInterno) {
                        fechasInternas.push(diaFinal);
                    }
                    fechaActual.setDate(fechaActual.getDate() + 1);
                }
                return fechasInternas;
            }
            const objetoFechasInternas = {}
            for (const reservaCoincidente of reservasCoincidentes) {

                const reservaUID = reservaCoincidente.reserva

                const consultaApartamentosPorReserva = `
                SELECT 
                apartamento
                FROM "reservaApartamentos"
                WHERE reserva = $1;          
                `
                const resuelveConsultaApartamentosPorReserva = await conexion.query(consultaApartamentosPorReserva, [reservaUID])
                if (resuelveConsultaApartamentosPorReserva.rowCount > 0) {

                    const apartamentosPorReservaObjetoCompleto = resuelveConsultaApartamentosPorReserva.rows
                    const apartamentosPorReservaArray = []
                    apartamentosPorReservaObjetoCompleto.map((apartamento) => {
                        apartamentosPorReservaArray.push(apartamento.apartamentoIDV)
                    })

                    let fechaEntrada = reservaCoincidente.entrada
                    fechaEntrada = fechaEntrada.split("/")
                    const diaEntrada = fechaEntrada[0]
                    const mesEntrada = fechaEntrada[1]
                    const anoEntrada = fechaEntrada[2]
                    fechaEntrada = `${anoEntrada}/${mesEntrada}/${diaEntrada}`

                    let fechaSalida = reservaCoincidente.salida
                    fechaSalida = fechaSalida.split("/")
                    const diaSalida = fechaSalida[0]
                    const mesSalida = fechaSalida[1]
                    const anoSalida = fechaSalida[2]
                    fechaSalida = `${anoSalida}/${mesSalida}/${diaSalida}`

                    const fechasInternas = obtenerFechasInternas(fechaEntrada, fechaSalida);
                    fechasInternas.map((fechaInterna) => {
                        if (!objetoFechasInternas[fechaInterna]?.apartamentos) {
                            const detalleDia = {
                                "fecha": `${fechaInterna}/${mes}/${ano}`,
                                "apartamentos": apartamentosPorReservaArray,
                                "estadoDia": "porVer"
                            }
                            objetoFechasInternas[fechaInterna] = detalleDia
                        } else {

                            let arrayExistente = objetoFechasInternas[fechaInterna].apartamentos
                            const arrayFusion = Array.from(new Set(arrayExistente.concat(apartamentosPorReservaArray)));
                            objetoFechasInternas[fechaInterna].apartamentos = arrayFusion
                        }

                    })
                }
            }

            const controlEstadoDia = (apartamentosDisponbiles, apartamentosPorDia) => {

                apartamentosDisponbiles.sort();
                apartamentosPorDia.sort()

                if (apartamentosDisponbiles.length !== apartamentosPorDia.length) {
                    return false; // Los arrays tienen longitudes diferentes, no pueden ser iguales
                }
                return apartamentosDisponbiles.every((element, index) => element === apartamentosPorDia[index]);
            }
            for (const [fechaDia, detallesDia] of Object.entries(objetoFechasInternas)) {
                const apartamentos = detallesDia.apartamentos
                if (controlEstadoDia(apartamentosDisponbiles, apartamentos)) {
                    detallesDia.estadoDia = "diaCompleto"
                } else {
                    detallesDia.estadoDia = "diaParcial"
                }
            }

            const respuestaFinal = {
                "mes": mes,
                "dias": objetoFechasInternas

            }
            const objetofinal = {
                "ok": respuestaFinal
            }

            salida.json(objetofinal)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        } finally {
            
        }
    }
    if (transaccion === "crearReservaSimpleAdministrativa") {
        const mutex = new Mutex();
        const bloqueoCrearReservaSimpleAdministrativa = await mutex.acquire();
        try {
            const fechaEntrada = entrada.body.fechaEntrada
            const fechaSalida = entrada.body.fechaSalida
            const apartamentos = entrada.body.apartamentos
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaEntrada)) {
                let error = "el formato fecha de entrada no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaSalida)) {
                let error = "el formato fecha de salida no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!Array.isArray(apartamentos)) {
                let error = "el campo 'apartamentos' debe de ser un array"
                throw new Error(error)
            }
            // validar que en el array hay un maximo de posiciones no superior al numero de filas que existen en los apartementos
            const estadoDisonibleApartamento = "disponible"
            const validarNumeroApartamentosMaximoArrayEntrante = `
            SELECT
            "apartamentoIDV"
            FROM "configuracionApartamenros"
            WHERE "estadoConfiguracion" = $1`
            const resuelveValidarNumeroApartamentosMaximoArrayEntrante = await conexion.query(validarNumeroApartamentosMaximoArrayEntrante, [estadoDisonibleApartamento])
            if (resuelveValidarNumeroApartamentosMaximoArrayEntrante.rowCount === 0) {
                const error = "No hay ningun apartamento disponible ahora mismo"
                throw new Error(error)
            }
            if (apartamentos.length > resuelveValidarNumeroApartamentosMaximoArrayEntrante.rowCount) {
                const error = "El tamano de posiciones del array de apartamentos es demasiado grande"
                throw new Error(error)
            }

            // Formateo fecha mucho ojo que los anglosajones tiene el formato mes/dia/ano y queremos usar dia/mes/ano y el objeto date de javascript por cojones usa ese formato
            const fechaEntradaEnArreglo = fechaEntrada.split("/")
            const fechaSalidaEnArreglo = fechaSalida.split("/")
            const constructorFechaEntradaFormatoMDA = `${fechaEntradaEnArreglo[1]}/${fechaEntradaEnArreglo[0]}/${fechaEntradaEnArreglo[2]}`
            const constructorFechaSalidaFormatoMDA = `${fechaSalidaEnArreglo[1]}/${fechaSalidaEnArreglo[0]}/${fechaSalidaEnArreglo[2]}`
            const controlFechaEntrada = new Date(constructorFechaEntradaFormatoMDA); // El formato es d√≠a/mes/ano
            const controlFechaSalida = new Date(constructorFechaSalidaFormatoMDA);

            // validacion: la fecha de entrada no puede ser superior a la fecha de salida y al mimso tiempo la fecha de salida no puede ser inferior a la fecha de entrada
            if (controlFechaEntrada >= controlFechaSalida) {
                const error = "La fecha de entrada no puede ser igual o superior que la fecha de salida"
                throw new Error(error)
            }

            const filtroApartamentoIDV = /^[a-z0-9]+$/;
            for (const apartamento of apartamentos) {

                if (!filtroApartamentoIDV.test(apartamento)) {
                    const error = "Hay un apartamentoIDV dentro del array que no cumple los requisitos."
                    throw new Error(error)
                }
            }
            // validar que los apartamentos que se existen estan disponbiles para las fechas
            const transacion = {
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida
            }
            const resuelveApartamentosDisponibles = await apartamentosDisponiblesAdministracion(transacion)
            const apartamentosDisponibles = resuelveApartamentosDisponibles.apartamentosDisponibles
            if (apartamentosDisponibles.length === 0) {
                const error = "No hay ningun apartamento disponible para estas fechas"
                throw new Error(error)
            }
            if (apartamentosDisponibles.length > 0) {
                const validarApartamentosDisonbiles = (apartamentosSolicitados, apartamentosDisponibles) => {
                    return apartamentosSolicitados.every(apartamento => apartamentosDisponibles.includes(apartamento));
                }

                const controlApartamentosDisponibles = validarApartamentosDisonbiles(apartamentos, apartamentosDisponibles);
                if (!controlApartamentosDisponibles) {
                    const error = "Los apartamentos solicitados para este rango de fechas no estan disponbiles."
                    throw new Error(error)
                }

                const obtenerFechaReducida = () => {
                    const fechaActual = new Date();
                    const dia = fechaActual.getDate();
                    const mes = fechaActual.getMonth() + 1; // Se suma 1 porque los meses en JavaScript son indexados desde 0
                    const anio = fechaActual.getFullYear();
                    // Agregar ceros iniciales si es necesario
                    const diaFormateado = dia < 10 ? `0${dia}` : dia;
                    const mesFormateado = mes < 10 ? `0${mes}` : mes;
                    const fechaReducida = `${diaFormateado}/${mesFormateado}/${anio}`;
                    return fechaReducida;
                }

                const formatoFechaEntradaDMA = `${fechaEntradaEnArreglo[0]}/${fechaEntradaEnArreglo[1]}/${fechaEntradaEnArreglo[2]}`
                const formatoFechaSalidaDMA = `${fechaSalidaEnArreglo[0]}/${fechaSalidaEnArreglo[1]}/${fechaSalidaEnArreglo[2]}`
                // insertar fila reserva y en la tabla reservarAartametnos insertar las correspondientes filas
                const estadoReserva = "confirmada";
                const origen = "administracion";
                const creacionFechaReserva = obtenerFechaReducida();
                const estadoPago = "noPagado"
                await conexion.query('BEGIN'); // Inicio de la transacci√≥n
                const insertarReserva = `
                INSERT INTO
                reservas 
                (entrada,
                salida,
                "estadoReserva",
                origen,
                creacion,
                "estadoPago")
                VALUES
                ($1,$2,$3,$4,$5,$6)
                RETURNING 
                reserva `
                const resuelveInsertarReserva = await conexion.query(insertarReserva, [formatoFechaEntradaDMA, formatoFechaSalidaDMA, estadoReserva, origen, creacionFechaReserva, estadoPago])
                const reservaUIDNuevo = resuelveInsertarReserva.rows[0]["reserva"];

                for (const apartamento of apartamentos) {


                    const apartamentoUI = await resolverApartamentoUI(apartamento)

                    const InsertarApartamento = `
                    INSERT INTO
                    "reservaApartamentos"
                    (
                    reserva,
                    apartamento, 
                    "apartamentoUI"
                    )
                    VALUES ($1, $2, $3)
                    `
                    const resuelveInsertarApartamento = await conexion.query(InsertarApartamento, [reservaUIDNuevo, apartamento, apartamentoUI])
                    if (resuelveInsertarApartamento.rowCount === 0) {
                        const error = "Ha ocurrido un error insertando el apartamento " + apartamento + " se detiene y se deshache todo el proceso"
                        throw new Error(error)
                    }
                }
                await conexion.query('COMMIT'); // Confirmar la transacci√≥n
                const ok = {
                    "ok": "Se ha anadido al reserva vacia",
                    "reservaUID": reservaUIDNuevo
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoCrearReservaSimpleAdministrativa()
        }



    }
    if (transaccion === "situacion") {
        try {
            const apartamentosObjeto = {}
            const consultaEstadoApartamentos = `
            SELECT "apartamentoIDV","estadoConfiguracion"
            FROM "configuracionApartamento"
            ORDER BY apartamento ASC
            `
            const resuelveConsultaEstadoApartamentos = await conexion.query(consultaEstadoApartamentos)
            if (resuelveConsultaEstadoApartamentos.rowCount === 0) {
                const error = "No hay apartamentos configurados"
                throw new Error(error)

            }

            resuelveConsultaEstadoApartamentos = resuelveConsultaEstadoApartamentos.rows
            for (const apartamento of resuelveConsultaEstadoApartamentos) {
                const apartamentoIDV = apartamento.apartamentoIDV
                const estadoApartamento = apartamento.estadoConfiguracion


                const apartamentoUI = await resolverApartamentoUI(apartamento)

                apartamentosObjeto[apartamentoIDV] = {
                    "apartamentoUI": apartamentoUI,
                    "estadoApartamento": estadoApartamento,
                    "estadoPernoctacion": "libre"
                }

            }

            const hoy = new Date();
            const dia = hoy.getDate();
            const mes = hoy.getMonth() + 1; // Los meses en JavaScript se indexan desde 0, por lo que debes sumar 1
            const ano = hoy.getFullYear();
            const fechaHoy = `${dia}/${mes}/${ano}`

            const consultaReservasHoy = `
            SELECT 
            reserva, 
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida
            FROM reservas
            WHERE entrada <= $1::DATE AND salida >= $1::DATE; 
            `
            const resuelveConsultaReservasHoy = await conexion.query(consultaReservasHoy, [fechaHoy])
            if (resuelveConsultaReservasHoy.rowCount === 0) {
                const ok = {
                    "ok": apartamentosObjeto
                }
                salida.json(ok)
            }
            if (resuelveConsultaReservasHoy.rowCount > 0) {

                const reservasHoy = resuelveConsultaReservasHoy.rows

                const apartamentosResueltos = []
                for (const reservaDetalles of reservasHoy) {
                    const reservaUID = reservaDetalles.reserva
                    const fechaEntrada = reservaDetalles.entrada
                    const fechaSalida = reservaDetalles.salida

                    const consultaApartamentos = `
                    SELECT apartamento
                    FROM "reservaApartamentos"
                    WHERE reserva = $1
                    `
                    const resuelveConsultaApartamentos = await conexion.query(consultaApartamentos, [reservaUID])
                    if (resuelveConsultaApartamentos.rowCount === 0) {
                        const ok = {
                            "ok": apartamentosObjeto
                        }
                        salida.json(ok)
                    }
                    if (resuelveConsultaApartamentos.rowCount > 0) {
                        apartamentosResueltos = resuelveConsultaApartamentos.rows

                        apartamentosResueltos.map((apartamento) => {


                            apartamentosObjeto[apartamento.apartamento].reserva = reservaUID
                            apartamentosObjeto[apartamento.apartamento].fechaEntrada = fechaEntrada
                            apartamentosObjeto[apartamento.apartamento].fechaSalida = fechaSalida
                            apartamentosObjeto[apartamento.apartamento].estadoPernoctacion = "ocupado"


                            let fechaEntradaArray = fechaEntrada.split("/")
                            let fechaSalidaArray = fechaSalida.split("/")

                            let fechaEntradaFormatoAAAAMMDD = `${fechaEntradaArray[2]}-${fechaEntradaArray[1]}-${fechaEntradaArray[0]}`
                            let fechaSalidaFormatoAAAAMMDD = `${fechaSalidaArray[2]}-${fechaSalidaArray[1]}-${fechaSalidaArray[0]}`

                            const fechaEntradaFormateadaFinal = new Date(fechaEntradaFormatoAAAAMMDD); // Fecha de entrada
                            const fechaSalidaFormateadaFinal = new Date(fechaSalidaFormatoAAAAMMDD); // Fecha de salida
                            const fechaHoyFormatoFinal = new Date(); // Fecha actual

                            const totalDias = fechaSalidaFormateadaFinal.getTime() - fechaEntradaFormateadaFinal.getTime(); // Total de d√≠as entre fecha de entrada y fecha de salida
                            const diasTranscurridos = fechaHoyFormatoFinal.getTime() - fechaEntradaFormateadaFinal.getTime(); // D√≠as transcurridos entre fecha de entrada y fecha actual

                            const porcentaje = (diasTranscurridos / totalDias) * 100; // C√°lculo del porcentaje
                            apartamentosObjeto[apartamento.apartamento].estadoReserva = porcentaje.toFixed(2) + '%'

                        })
                    }
                }
                const ok = {
                    "ok": apartamentosObjeto
                }
                salida.json(ok)

            }

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }











    }
    if (transaccion === "detallesSituacionApartmento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadena = /^[a-z0-9]+$/;


            if (!apartamentoIDV || !filtroCadena.test(apartamentoIDV)) {
                const error = "el campo 'apartmentoIDV' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }

            // Validar que existe el apartamento
            const detalleApartamento = {}
            const validarApartamento = `
            SELECT "apartamentoIDV", "estadoConfiguracion"
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1
            `
            const consultaValidarApartamento = await conexion.query(validarApartamento, [apartamentoIDV])
            if (consultaValidarApartamento.rowCount === 0) {
                const error = "No existe el apartamento"
                throw new Error(error)

            }
            const estadoApartamento = consultaValidarApartamento.rows[0].estadoConfiguracion


            const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)


            // Ver las reservas que existen hoy
            detalleApartamento.estadoApartamento = estadoApartamento
            const hoy = new Date();
            const dia = hoy.getDate();
            const mes = hoy.getMonth() + 1; // Los meses en JavaScript se indexan desde 0, por lo que debes sumar 1
            const ano = hoy.getFullYear();
            const fechaHoy = `${dia}/${mes}/${ano}`

            const consultaReservasHoy = `
            SELECT 
            reserva
            FROM reservas
            WHERE entrada <= $1::DATE AND salida >= $1::DATE; 
            `

            const objetoFinal = {
                "apartamentoUI": apartamentoUI,
                "apartamentoIDV": apartamentoIDV,
                "estadoApartamento": estadoApartamento,
                "estadoPernoctacion": "libre"
            }
            const resuelveConsultaReservasHoy = await conexion.query(consultaReservasHoy, [fechaHoy])
            if (resuelveConsultaReservasHoy.rowCount === 0) {
                detalleApartamento.estadoPernoctacion = "libre"
                const ok = {
                    "ok": objetoFinal
                }
                salida.json(ok)
            }

            if (resuelveConsultaReservasHoy.rowCount > 0) {
                // Analizar los apartmetnos de esas reservas parar buscar el apatamento   
                // extraer datos de la reserva, pernoctanes etc

                const reservasEncontradasHoy = resuelveConsultaReservasHoy.rows
                const resultadoBusqueda = "noEncontrado"
                let reservaEntonctrada
                let apartamentoUID
                for (const reserva of reservasEncontradasHoy) {
                    const reservaUID = reserva.reserva
                    const consultaApartamentosReserva = `
                    SELECT 
                    reserva, uid
                    FROM "reservaApartamentos"
                    WHERE reserva = $1 AND apartamento = $2; 
                    `
                    const resuelveConsultaApartamentosReserva = await conexion.query(consultaApartamentosReserva, [reservaUID, apartamentoIDV])
                    if (resuelveConsultaApartamentosReserva.rowCount === 1) {
                        resultadoBusqueda = "encontrado"
                        reservaEntonctrada = resuelveConsultaApartamentosReserva.rows[0].reserva
                        apartamentoUID = resuelveConsultaApartamentosReserva.rows[0].uid
                        break
                    }
                }

                if (resultadoBusqueda === "noEncontrado") {
                    const ok = {
                        "ok": objetoFinal
                    }
                    salida.json(ok)

                }

                if (resultadoBusqueda === "encontrado") {
                    // Extrar el id reserva
                    const reservaUIDEncontrada = reservaEntonctrada
                    const consultaDetallesReservaEntontrada = `
                    SELECT 
                    to_char(entrada, 'DD/MM/YYYY') as entrada, 
                    to_char(salida, 'DD/MM/YYYY') as salida
                    FROM reservas
                    WHERE reserva = $1; 
                    `
                    const resuelveConsultaDetallesReservaEntontrada = await conexion.query(consultaDetallesReservaEntontrada, [reservaUIDEncontrada])

                    let fechaEntrada = resuelveConsultaDetallesReservaEntontrada.rows[0].entrada
                    let fechaSalida = resuelveConsultaDetallesReservaEntontrada.rows[0].salida
                    objetoFinal["reservaUID"] = reservaUIDEncontrada
                    objetoFinal["fechaEntrada"] = fechaEntrada
                    objetoFinal["fechaSalida"] = fechaSalida


                    const fechaEntradaArray = fechaEntrada.split("/")
                    const fechaSalidaArray = fechaSalida.split("/")
                    const fechaEntradaFormatoAAAAMMDD = `${fechaEntradaArray[2]}-${fechaEntradaArray[1]}-${fechaEntradaArray[0]}`
                    const fechaSalidaFormatoAAAAMMDD = `${fechaSalidaArray[2]}-${fechaSalidaArray[1]}-${fechaSalidaArray[0]}`
                    const fechaEntradaFormateadaFinal = new Date(fechaEntradaFormatoAAAAMMDD); // Fecha de entrada
                    const fechaSalidaFormateadaFinal = new Date(fechaSalidaFormatoAAAAMMDD); // Fecha de salida
                    const fechaHoyFormatoFinal = new Date(); // Fecha actual
                    const totalDias = fechaSalidaFormateadaFinal.getTime() - fechaEntradaFormateadaFinal.getTime(); // Total de d√≠as entre fecha de entrada y fecha de salida
                    const diasTranscurridos = fechaHoyFormatoFinal.getTime() - fechaEntradaFormateadaFinal.getTime(); // D√≠as transcurridos entre fecha de entrada y fecha actual
                    const porcentaje = (diasTranscurridos / totalDias) * 100; // C√°lculo del porcentaje

                    objetoFinal["reservaEstado"] = porcentaje.toFixed(2) + '%'


                    objetoFinal["habitaciones"] = {
                        "no": "Dentro de la reserva no se ha especificado ninguna configuracion de habitaciones"
                    }
                    // Extraer las habitaciones
                    const consultaHabitaciones = `
                    SELECT 
                    uid, habitacion
                    FROM "reservaHabitaciones"
                    WHERE reserva = $1 AND apartamento = $2 ; 
                    `
                    const resuelveConsultaHabitaciones = await conexion.query(consultaHabitaciones, [reservaUIDEncontrada, apartamentoUID])
                    if (resuelveConsultaHabitaciones.rowCount === 0) {
                        const ok = {
                            "ok": objetoFinal
                        }
                        salida.json(ok)
                    }
                    if (resuelveConsultaHabitaciones.rowCount > 0) {
                        const habitaciones = resuelveConsultaHabitaciones.rows
                        const detalleHabitacion = {}

                        for (const habitacion of habitaciones) {

                            const habitacionUID = habitacion.uid
                            const habitacionIDV = habitacion.habitacion

                            const resolverHabitacionUI = `
                            SELECT 
                            "habitacionUI"
                            FROM habitaciones
                            WHERE habitacion = $1; 
                            `
                            const resuelveResolverHabitacionUI = await conexion.query(resolverHabitacionUI, [habitacionIDV])
                            const habitacionUI = resuelveResolverHabitacionUI.rows[0].habitacionUI
                            detalleHabitacion[habitacionIDV] = {
                                "habitacionUI": habitacionUI
                            }
                            const consultaPernoctanesHabitacion = `
                            SELECT 
                            pernoctante, "pernoctantePool"
                            FROM "reservaPernoctantes"
                            WHERE reserva = $1 AND habitacion = $2 ; 
                            `
                            const resuelveConsultaPernoctanesHabitacion = await conexion.query(consultaPernoctanesHabitacion, [reservaUIDEncontrada, habitacionUID])

                            if (resuelveConsultaPernoctanesHabitacion.rowCount === 0) {

                                const ok = {
                                    "ok": objetoFinal
                                }
                                salida.json(ok)
                                break
                            }
                            if (resuelveConsultaPernoctanesHabitacion.rowCount > 0) {
                                const pernoctantes = resuelveConsultaPernoctanesHabitacion.rows
                                const pernoctantesObjetoTemporal = []
                                for (const pernoctante of pernoctantes) {
                                    const pernoctanteUID = pernoctante.pernoctante
                                    const pernoctantePoolUID = pernoctante.pernoctantePool


                                    if (pernoctanteUID) {

                                        const resolverDatosPernoctante = `
                                        SELECT 
                                        nombre, "primerApellido", "segundoApellido", uid
                                        FROM clientes
                                        WHERE uid = $1 ; 
                                        `
                                        const resuelveResolverDatosPernoctante = await conexion.query(resolverDatosPernoctante, [pernoctanteUID])
                                        const datosCliente = resuelveResolverDatosPernoctante.rows[0]
                                        const constructorNombreCompleto = `${datosCliente.nombre} ${datosCliente.primerApellido} ${datosCliente.segundoApellido}`
                                        const uid = resuelveResolverDatosPernoctante.rows[0].uid


                                        const detallesPernoctante = {
                                            "nombreCompleto": constructorNombreCompleto,
                                            "tipoPernoctante": "cliente",
                                            "uidCliente": uid
                                        }
                                        pernoctantesObjetoTemporal.push(detallesPernoctante)

                                    }



                                    if (pernoctantePoolUID) {

                                        const resolverDatosPernoctante = `
                                        SELECT 
                                        "nombreCompleto", uid
                                        FROM "poolClientes"
                                        WHERE uid = $1 ; 
                                        `
                                        const resuelveResolverDatosPernoctante = await conexion.query(resolverDatosPernoctante, [pernoctantePoolUID])
                                        const nombreCompleto = resuelveResolverDatosPernoctante.rows[0].nombreCompleto
                                        const uid = resuelveResolverDatosPernoctante.rows[0].uid

                                        const detallesPernoctante = {
                                            "nombreCompleto": nombreCompleto,
                                            "tipoPernoctante": "clientePool",
                                            "uidCliente": uid
                                        }
                                        pernoctantesObjetoTemporal.push(detallesPernoctante)


                                    }


                                }


                                detalleHabitacion[habitacionIDV]["pernoctantes"] = pernoctantesObjetoTemporal



                            }






                        }


                        objetoFinal["estadoPernoctacion"] = "ocupado"
                        objetoFinal["habitaciones"] = detalleHabitacion


                        const ok = {
                            "ok": objetoFinal
                        }
                        salida.json(ok)











                    }

                    // Extraer los pernoctantes en habitaciones



                }







            }








        } catch (error) {
            const detalleError = {
                "error": error.message,
            }
            salida.json(detalleError)
        } finally {
            
        }








    }
    if (transaccion === "crearCliente") {
        const mutex = new Mutex();
        const bloqueoCrearCliente = await mutex.acquire();
        try {
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let correoElectronico = entrada.body.correo
            let notas = entrada.body.notas


            const filtroCadena = /^[a-zA-Z0-9\s]+$/;
            if (nombre?.length > 0) {
                if (!filtroCadena.test(nombre)) {
                    const error = "el campo 'nombre' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }



                nombre = nombre.trim();
                nombre = nombre.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'nombre' es obligatorio."
                throw new Error(error)
            }
            if (primerApellido?.length > 0) {
                if (!filtroCadena.test(primerApellido)) {
                    const error = "el campo 'primerApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                primerApellido = primerApellido.trim();
                primerApellido = primerApellido.replace(/\s+/g, ' ');
            }
            if (segundoApellido?.length > 0) {
                if (!filtroCadena.test(segundoApellido)) {
                    const error = "el campo 'segundoApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                segundoApellido = segundoApellido.trim();
                segundoApellido = segundoApellido.replace(/\s+/g, ' ');
            }
            if (pasaporte?.length > 0) {
                const filtroPasaporte = /^[a-zA-Z0-9]+$/;

                if (!filtroPasaporte.test(pasaporte)) {
                    const error = "el campo 'pasaporte' solo puede ser letras min√∫sculas, masculas y numeros."
                    throw new Error(error)
                }
                pasaporte = pasaporte.trim();
                pasaporte = pasaporte.replace(/\s+/g, ' ');
            } else {
                const error = "el campo 'pasaporte' es obligatorio."
                throw new Error(error)
            }
            if (telefono?.length > 0) {
                if (typeof telefono !== "number" || !Number.isInteger(telefono) || telefono <= 0) {
                    const error = "el campo 'telefono' solo puede un numero, entero y positivo"
                    throw new Error(error)
                }
                telefono = telefono.trim();
                telefono = telefono.replace(/\s+/g, '');
            }
            if (correoElectronico?.length > 0) {
                const filtroCorreoElectronico = /^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/;
                if (!filtroCorreoElectronico.test(correoElectronico)) {
                    const error = "el campo 'correoElectronico' no cumple con el formato esperado, el formado esperado es asi como usuario@servidor.com"
                    throw new Error(error)
                }
                correoElectronico = correoElectronico.trim();
                correoElectronico = correoElectronico.replace(/\s+/g, '');
            }

            let insertarCliente = `
            INSERT INTO clientes
            (nombre,"primerApellido","segundoApellido",pasaporte,telefono,email,notas)
            VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING uid
            `
            let resuelveInsertarCliente = await conexion.query(insertarCliente, [nombre, primerApellido, segundoApellido, pasaporte, telefono, correoElectronico, notas])
            if (resuelveInsertarCliente.rowCount === 0) {
                const error = "No se ha insertardo el cliente en la base de datos"
                throw new Error(error)
            }
            let nuevoUIDCliente = resuelveInsertarCliente.rows[0].uid
            if (nuevoUIDCliente) {
                let ok = {
                    "ok": "Se ha anadido correctamente el cliente",
                    "nuevoUIDCliente": nuevoUIDCliente
                }
                salida.json(ok)
            } else {
                const error = "Ha ocurrido un error interno y no se ha podido obtener el nuevo UID de cliente"
                throw new Error(error)
            }


        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoCrearCliente()
        }




    }
    if (transaccion === "detallesCliente") {
        try {
            let cliente = entrada.body.cliente
            if (!cliente || !Number.isInteger(cliente)) {
                const error = "El campo cliente solo puede ser un numero positivo y entero que haga referencia al UID del cliente"
                throw new Error(error)
            }
            let consultaDetallesCliente = `
            SELECT 
            uid, 
            nombre,
            "primerApellido",
            "segundoApellido",
            pasaporte,
            telefono,
            email,
            notas 
            FROM 
            clientes 
            WHERE 
            uid = $1`
            let resolverConsultaDetallesCliente = await conexion.query(consultaDetallesCliente, [cliente])
            if (resolverConsultaDetallesCliente.rowCount === 0) {
                const error = "No existe ningun clinete con ese UID"
                throw new Error(error)
            }

            let detallesCliente = resolverConsultaDetallesCliente.rows[0]
            let ok = {
                "ok": detallesCliente
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "eliminarClinete") {
    }
    if (transaccion === "modificarCliente") {

        const mutex = new Mutex();
        const bloqueoModificarClinete = await mutex.acquire();
        try {
            let cliente = entrada.body.cliente
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let email = entrada.body.email
            let notas = entrada.body.notas

            if (!cliente || !Number.isInteger(cliente)) {
                const error = "El campo cliente solo puede ser un numero positivo y entero que haga referencia al UID del cliente"
                throw new Error(error)
            }
            const filtroCadena = /^[a-zA-Z0-9\s]+$/;
            if (nombre?.length > 0) {
                if (!filtroCadena.test(nombre)) {
                    const error = "el campo 'nombre' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                nombre = nombre.trim();
                nombre = nombre.replace(/\s+/g, ' ');
            }
            if (primerApellido?.length > 0) {
                if (!filtroCadena.test(primerApellido)) {
                    const error = "el campo 'primerApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                primerApellido = primerApellido.trim();
                primerApellido = primerApellido.replace(/\s+/g, ' ');
            }
            if (segundoApellido?.length > 0) {
                if (!filtroCadena.test(segundoApellido)) {
                    const error = "el campo 'segundoApellido' solo puede ser letras min√∫sculas, masculas."
                    throw new Error(error)
                }
                segundoApellido = segundoApellido.trim();
                segundoApellido = segundoApellido.replace(/\s+/g, ' ');
            }
            if (pasaporte?.length > 0) {
                const filtroPasaporte = /^[a-zA-Z0-9]+$/;

                if (!filtroPasaporte.test(pasaporte)) {
                    const error = "el campo 'pasaporte' solo puede ser letras min√∫sculas, masculas y numeros."
                    throw new Error(error)
                }
                pasaporte = pasaporte.trim();
                pasaporte = pasaporte.replace(/\s+/g, ' ');
            }
            if (telefono?.length > 0) {

                if (typeof telefono !== "number" || !Number.isInteger(telefono) || telefono <= 0) {
                    const error = "el campo 'telefono' solo puede un numero, entero y positivo, vigila que el telefono sea un numero y no una candena, recuerda que en el JSON va sin comillas "
                    throw new Error(error)
                }
                telefono = telefono.trim();
                telefono = telefono.replace(/\s+/g, '');
            }
            if (email?.length > 0) {
                const filtroCorreoElectronico = /^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/;
                if (!filtroCorreoElectronico.test(email)) {
                    const error = "el campo 'correoElectronico' no cumple con el formato esperado, el formado esperado es asi como usuario@servidor.com"
                    throw new Error(error)
                }
                email = email.trim();
                email = email.replace(/\s+/g, '');
            }
            let validarCliente = `
            SELECT
            uid
            FROM 
            clientes
            WHERE
            uid = $1`
            let resuelveValidarCliente = await conexion.query(validarCliente, [cliente])
            if (resuelveValidarCliente.rowCount === 0) {
                const error = "No existe el cliente"
                throw new Error(error)

            }


            let actualizarCliente = `
            UPDATE clientes
            SET 
            nombre = COALESCE($1, nombre),
            "primerApellido" = COALESCE($2, "primerApellido"),
            "segundoApellido" = COALESCE($3, "segundoApellido"),
            pasaporte = COALESCE($4, pasaporte),
            telefono = COALESCE($5, telefono),
            email = COALESCE($6, email),
            notas = COALESCE($7, notas)
            WHERE uid = $8
            RETURNING
            nombre,
            "primerApellido",
            "segundoApellido",
            pasaporte,
            telefono,
            email,
            notas;
            `
            let resuelveActualizarCliente = await conexion.query(actualizarCliente, [nombre, primerApellido, segundoApellido, pasaporte, telefono, email, notas, cliente])
            if (resuelveActualizarCliente.rowCount === 0) {
                const error = "No se ha actualizado el cliente por que la base de datos no ha entontrado al cliente"
                throw new Error(error)
            }
            let ok = {
                "ok": "Se ha anadido correctamente el cliente",
                "detallesCliente": resuelveActualizarCliente.rows
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
            bloqueoModificarClinete()
        }


    }
    if (transaccion === "listaImpuestos") {
        try {
            let listarImpuestos = `
            SELECT
            idv, impuesto, "tipoImpositivo", "tipoValor", "aplicacionSobre", "moneda"
            FROM 
            impuestos
            `
            let resuelvelistarImpuestos = await conexion.query(listarImpuestos)
            if (resuelvelistarImpuestos.rowCount === 0) {
                const error = "No hay ningun impuesto en sl sistema"
                throw new Error(error)

            }
            let ok = {
                "ok": resuelvelistarImpuestos.rows
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "listaPreciosApartamentos") {
        try {

            const apartamentos = `
            SELECT
            "apartamentoIDV"
            FROM 
            "configuracionApartamento"
            `
            const resuelveApartamentos = await conexion.query(apartamentos)
            if (resuelveApartamentos.rowCount === 0) {
                const error = "No hay ningun apartamento en el sistema"
                throw new Error(error)
            }

            const apartamentosEncontrados = resuelveApartamentos.rows

            const seleccionarImpuestos = `
            SELECT
            impuesto, "tipoImpositivo", "tipoValor", moneda
            FROM
            impuestos
            WHERE
            "aplicacionSobre" = $1 OR "aplicacionSobre" = $2;
          
            `
            const resuelveSeleccionarImpuestos = await conexion.query(seleccionarImpuestos, ["totalNeto", "totalReservaNeto"])
            const objetoFInal = []
            for (const apartamentoEncotrado of apartamentosEncontrados) {

                const apartamentoIDV = apartamentoEncotrado.apartamentoIDV
                const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)

                const apartamento = {
                    "apartamento": apartamentoIDV,
                    "apartamentoUI": apartamentoUI

                }
                const listarPreciosApartamentos = `
                SELECT
                uid, apartamento, precio, moneda
                FROM 
                "preciosApartamentos"
                WHERE apartamento = $1
                `

                const resuelveListarPreciosApartamentos = await conexion.query(listarPreciosApartamentos, [apartamentoIDV])
                if (resuelveListarPreciosApartamentos.rowCount === 1) {

                    const precioEncontrados = resuelveListarPreciosApartamentos.rows[0]
                    const precioApartamento = precioEncontrados.precio
                    const moneda = precioEncontrados.moneda
                    const uidPrecio = precioEncontrados.uid
                    apartamento["uid"] = uidPrecio
                    apartamento["precio"] = precioApartamento
                    apartamento["moneda"] = moneda


                    if (resuelveSeleccionarImpuestos.rowCount > 0) {
                        const impuestosEncontrados = resuelveSeleccionarImpuestos.rows
                        apartamento["totalImpuestos"] = 0.00
                        let sumaTotalImpuestos = 0.00
                        impuestosEncontrados.map((detalleImpuesto) => {

                            const tipoImpositivo = detalleImpuesto.tipoImpositivo
                            const tipoValor = detalleImpuesto.tipoValor
                            if (tipoValor === "porcentaje") {
                                const resultadoApliacado = (precioApartamento * (tipoImpositivo / 100)).toFixed(2);
                                sumaTotalImpuestos += parseFloat(resultadoApliacado)
                            }
                            if (tipoValor === "tasa") {
                                sumaTotalImpuestos += parseFloat(tipoImpositivo)
                            }

                        })
                        apartamento["totalImpuestos"] = Number(sumaTotalImpuestos).toFixed(2)

                        let totalDiaBruto = Number(sumaTotalImpuestos) + Number(precioApartamento)
                        totalDiaBruto = totalDiaBruto.toFixed(2)
                        apartamento["totalDiaBruto"] = totalDiaBruto


                    }

                }


                objetoFInal.push(apartamento)





            }





            let ok = {
                "ok": objetoFInal
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "detallePrecioBaseApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadena = /^[a-z0-9]+$/;

            if (typeof apartamentoIDV !== "string" || !filtroCadena.test(apartamentoIDV)) {
                const error = "El campo apartamentoIDV solo puede ser un una cadena de min√∫sculas y numeros, ni siquera espacios"
                throw new Error(error)
            }

            const transaccionInterna = await precioBaseApartamento(apartamentoIDV)
            const ok = {
                "ok": transaccionInterna
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "previsualizarPrecioApartamento") {

        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadena = /^[a-z0-9]+$/;
            const propuestaPrecio = entrada.body.propuestaPrecio

            if (typeof apartamentoIDV !== "string") {
                const error = "El campo apartamentoIDV debe de ser una cadena"
                throw new Error(error)
            }


            if (!filtroCadena.test(apartamentoIDV)) {
                const error = "El campo apartamentoIDV solo puede ser un una cadena de min√∫sculas y numeros, ni siquera espacios"
                throw new Error(error)
            }


            const filtroPropuestaPrecio = /^\d+(\.\d{2})?$/;
            if (!filtroPropuestaPrecio.test(propuestaPrecio)) {
                const error = "El campo propuestaPrecio solo puede ser un numero con dos decimales y nada mas, los decimales deben de separarse con un punto y no una coma"
                throw new Error(error)
            }

            const validarApartamento = `
            SELECT
            "apartamentoIDV"
            FROM 
            "configuracionApartamento"
            WHERE "apartamentoIDV" = $1
            `
            const resuelveValidarApartamento = await conexion.query(validarApartamento, [apartamentoIDV])
            if (resuelveValidarApartamento.rowCount === 0) {
                const error = "No existe el apartamenro"
                throw new Error(error)
            }
            const detallesApartamento = {}
            const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)

            detallesApartamento.apartamentoUI = apartamentoUI
            detallesApartamento.apartamentoIDV = apartamentoIDV


            const precioNetoApartamentoPorDia = propuestaPrecio
            detallesApartamento.precioNetoPorDiaPropuesto = precioNetoApartamentoPorDia
            const seleccionarImpuestos = `
            SELECT
            impuesto, "tipoImpositivo", "tipoValor", moneda
            FROM
            impuestos
            WHERE
            "aplicacionSobre" = $1 OR "aplicacionSobre" = $2;
          
            `
            const resuelveSeleccionarImpuestos = await conexion.query(seleccionarImpuestos, ["totalNeto", "totalReservaNeto"])
            if (resuelveSeleccionarImpuestos.rowCount > 0) {
                detallesApartamento.impuestos = []
                const impuestosEncontrados = resuelveSeleccionarImpuestos.rows
                let impuestosFinal

                let sumaTotalImpuestos = 0.00
                impuestosEncontrados.map((detalleImpuesto) => {
                    const tipoImpositivo = detalleImpuesto.tipoImpositivo
                    const nombreImpuesto = detalleImpuesto.impuesto
                    const tipoValor = detalleImpuesto.tipoValor
                    impuestosFinal = {
                        "nombreImpuesto": nombreImpuesto,
                        "tipoImpositivo": tipoImpositivo,
                        "tipoValor": tipoValor,


                    }
                    if (tipoValor === "porcentaje") {
                        const resultadoApliacado = (precioNetoApartamentoPorDia * (tipoImpositivo / 100)).toFixed(2);
                        sumaTotalImpuestos += parseFloat(resultadoApliacado)
                        impuestosFinal.totalImpuesto = resultadoApliacado
                    }
                    if (tipoValor === "tasa") {
                        sumaTotalImpuestos += parseFloat(tipoImpositivo)
                        impuestosFinal.totalImpuesto = tipoImpositivo

                    }
                    (detallesApartamento.impuestos).push(impuestosFinal)

                })

                let totalDiaBruto = Number(sumaTotalImpuestos) + Number(precioNetoApartamentoPorDia)

                totalDiaBruto = totalDiaBruto.toFixed(2)
                detallesApartamento.totalImpuestos = sumaTotalImpuestos
                detallesApartamento.totalBrutoPordia = totalDiaBruto;


            }


            const ok = {
                "ok": detallesApartamento
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "establecerNuevoPrecioApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const nuevoPrecio = entrada.body.nuevoPrecio

            if (typeof apartamentoIDV !== "string") {
                const error = "El campo apartamentoIDV debe de ser una cadena"
                throw new Error(error)
            }
            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(apartamentoIDV)) {
                const error = "El campo apartamentoIDV solo puede ser un una cadena de min√∫sculas y numeros, ni siquera espacios"
                throw new Error(error)
            }
            const filtroPropuestaPrecio = /^\d+(\.\d{2})?$/;
            if (!filtroPropuestaPrecio.test(nuevoPrecio)) {
                const error = "El campo nuevoPrecio solo puede ser un numero con dos decimales y nada mas, los decimales deben de separarse con un punto y no una coma"
                throw new Error(error)
            }

            const validarApartamento = `
            SELECT
            "apartamentoIDV", "estadoConfiguracion"
            FROM 
            "configuracionApartamento"
            WHERE "apartamentoIDV" = $1
            `
            const resuelveValidarApartamento = await conexion.query(validarApartamento, [apartamentoIDV])
            if (resuelveValidarApartamento.rowCount === 0) {
                const error = "No existe el apartamenro"
                throw new Error(error)
            }
            if (resuelveValidarApartamento.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede puede establecer un precio a este apartmento cuadno la configuracion esta en modo disponible. Primero desactive la configuracion del apartmento dejandola en estado No disponible y luego podra hacer las modificaciones que necesite"
                throw new Error(error)
            }


            const detallesApartamento = {}
            const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)


            detallesApartamento.apartamentoUI = apartamentoUI
            detallesApartamento.apartamentoIDV = apartamentoIDV

            const insertarNuevoPrecioApartamento = `
            UPDATE "preciosApartamentos"
            SET precio = $1
            WHERE "apartamento" = $2;
            `
            const resuelveInsertarNuevoPrecioApartamento = await conexion.query(insertarNuevoPrecioApartamento, [nuevoPrecio, apartamentoIDV])
            if (resuelveInsertarNuevoPrecioApartamento.rowCount === 0) {
                const error = "No existe ningun perfil de precio que actualizar para este apartamento"
                throw new Error(error)

            }

            const listarPrecioApartamento = `
            SELECT
            uid, apartamento, precio, moneda
            FROM 
            "preciosApartamentos"
            WHERE apartamento = $1
            `
            const resuelveListarPrecioApartamento = await conexion.query(listarPrecioApartamento, [apartamentoIDV])
            if (resuelveListarPrecioApartamento.rowCount === 0) {
                const error = "No hay ningun precio de este apartamento en el sistema"
                throw new Error(error)
            }
            const precioNetoApartamentoPorDia = resuelveListarPrecioApartamento.rows[0].precio
            detallesApartamento.precioNetoPorDia = precioNetoApartamentoPorDia
            const seleccionarImpuestos = `
            SELECT
            impuesto, "tipoImpositivo", "tipoValor", moneda
            FROM
            impuestos
            WHERE
            "aplicacionSobre" = $1 OR "aplicacionSobre" = $2;
          
            `
            const resuelveSeleccionarImpuestos = await conexion.query(seleccionarImpuestos, ["totalNeto", "totalReservaNeto"])
            if (resuelveSeleccionarImpuestos.rowCount > 0) {
                detallesApartamento.impuestos = []
                const impuestosEncontrados = resuelveSeleccionarImpuestos.rows
                let impuestosFinal

                let sumaTotalImpuestos = 0.00
                impuestosEncontrados.map((detalleImpuesto) => {
                    const tipoImpositivo = detalleImpuesto.tipoImpositivo
                    const nombreImpuesto = detalleImpuesto.impuesto
                    const tipoValor = detalleImpuesto.tipoValor
                    impuestosFinal = {
                        "nombreImpuesto": nombreImpuesto,
                        "tipoImpositivo": tipoImpositivo,
                        "tipoValor": tipoValor,


                    }
                    if (tipoValor === "porcentaje") {
                        const resultadoApliacado = (precioNetoApartamentoPorDia * (tipoImpositivo / 100)).toFixed(2);
                        sumaTotalImpuestos += parseFloat(resultadoApliacado)
                        impuestosFinal.totalImpuesto = resultadoApliacado
                    }
                    if (tipoValor === "tasa") {
                        sumaTotalImpuestos += parseFloat(tipoImpositivo)
                        impuestosFinal.totalImpuesto = tipoImpositivo

                    }
                    (detallesApartamento.impuestos).push(impuestosFinal)

                })

                let totalDiaBruto = Number(sumaTotalImpuestos) + Number(precioNetoApartamentoPorDia)

                totalDiaBruto = totalDiaBruto.toFixed(2)
                detallesApartamento.totalImpuestos = sumaTotalImpuestos.toFixed(2)
                detallesApartamento.totalBrutoPordia = totalDiaBruto;


            }


            const ok = {
                "ok": detallesApartamento
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "eliminarPerfilPrecioApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV

            if (typeof apartamentoIDV !== "string") {
                const error = "El campo apartamentoIDV debe de ser una cadena"
                throw new Error(error)
            }
            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(apartamentoIDV)) {
                const error = "El campo apartamentoIDV solo puede ser un una cadena de min√∫sculas y numeros, ni siquera espacios"
                throw new Error(error)
            }

            const validarApartamento = `
            SELECT
            "apartamentoIDV", 
            "estadoConfiguracion"
            FROM 
            "configuracionApartamento"
            WHERE "apartamentoIDV" = $1
            `
            const resuelveValidarApartamento = await conexion.query(validarApartamento, [apartamentoIDV])
            if (resuelveValidarApartamento.rowCount === 0) {
                const error = "No existe el apartamenro"
                throw new Error(error)
            }
            if (resuelveValidarApartamento.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede eliminar un perfil de precio de una configuracion de apartamento mientras esta configuracion esta disponible para su uso. Por favor primero ponga la configuracion en no disponible y luego realiza las modificaciones pertinentes."
                throw new Error(error)
            }
            const eliminarPerfilPrecio = `
            DELETE FROM "preciosApartamentos"
            WHERE apartamento = $1;
            `
            const resuelveEliminarPerfilPrecio = await conexion.query(eliminarPerfilPrecio, [apartamentoIDV])
            if (resuelveEliminarPerfilPrecio.rowCount === 0) {
                const error = "No hay ningun perfil de precio que elimintar de este apartamento"
                throw new Error(error)
            }

            const ok = {
                "ok": "Se ha eliminado correctamnte el perfil de apartamento"
            }

            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "resolverMoneda") {

        try {
            let monedaIDV = entrada.body.monedaIDV
            const filtroCadena = /^[a-z]+$/;
            if (!monedaIDV || !filtroCadena.test(monedaIDV)) {
                const error = "El campo monedaIDV solo puede ser un una cadena de min√∫sculas"
                throw new Error(error)
            }

            const transaccionInterna = await resolverMoneda(monedaIDV)
            salida.json(transaccionInterna)


        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "detalleImpuesto") {
        try {
            const impuestoUID = entrada.body.impuestoUID

            if (!impuestoUID || typeof impuestoUID !== "number" || !Number.isInteger(impuestoUID) || impuestoUID <= 0) {
                const error = "El campo 'impuestoUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            const validarImpuesto = `
            SELECT
            i.impuesto AS "nombreImpuesto",
            i.idv AS "impuestoUID",
            i.impuesto,
            i."tipoImpositivo",
            i."tipoValor" AS "tipoValorIDV",
            itv."tipoValorUI" AS "tipoValorUI",
            i."aplicacionSobre" AS "aplicacionSobreIDV",
            ias."aplicacionUI" AS "aplicacionSobreUI",
            i."moneda" AS "monedaIDV",
            mon."monedaUI" AS "monedaUI"
            FROM
            impuestos i
            JOIN
            "impuestoTipoValor" itv ON i."tipoValor" = itv."tipoValorIDV"
            JOIN
            "impuestosAplicacion" ias ON i."aplicacionSobre" = ias."aplicacionIDV"
            JOIN
            "monedas" mon ON i."moneda" = mon."monedaIDV"
            WHERE
            i.idv = $1;
            `
            const resuelveValidarImpuesto = await conexion.query(validarImpuesto, [impuestoUID])
            if (resuelveValidarImpuesto.rowCount === 0) {
                const error = "No existe el perfil del impuesto"
                throw new Error(error)
            }
            const perfilImpuesto = resuelveValidarImpuesto.rows[0]

            const ok = {
                "ok": perfilImpuesto
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "guardarModificacionImpuesto") {
        try {
            const impuestoUID = entrada.body.impuestoUID
            let nombreImpuesto = entrada.body.nombreImpuesto
            let tipoImpositivo = entrada.body.tipoImpositivo
            let tipoValor = entrada.body.tipoValor
            let aplicacionSobre = entrada.body.aplicacionSobre
            let moneda = entrada.body.moneda

            if (typeof impuestoUID !== "number" || !Number.isInteger(impuestoUID) || impuestoUID <= 0) {
                const error = "El campo 'impuestoUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            const filtroCadena = /^[a-zA-Z0-9 ]+$/;
            if (nombreImpuesto?.length > 0 && !filtroCadena.test(nombreImpuesto)) {
                const error = "El campo nombreImpuesto solo puede ser un una cadena de min√∫sculas"
                throw new Error(error)
            }
            const filtroTipoImpositivo = /^\d+(\.\d{2})?$/;
            if (tipoImpositivo?.length > 0 && (typeof tipoImpositivo !== "string" || !filtroTipoImpositivo.test(tipoImpositivo))) {
                const error = "El campo tipoImpositivo solo puede ser una cadena con un numero y dos decimlaes"
                throw new Error(error)
            }
            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;
            if (tipoValor?.length > 0 && !filtroCadenaSinEspacio.test(tipoValor)) {
                const error = "El campo tipoValor solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }
            const filtroCadena_mMN = /^[a-zA-Z0-9]+$/;

            if (aplicacionSobre?.length > 0 && !filtroCadena_mMN.test(aplicacionSobre)) {
                const error = "El campo aplicacionSobre solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }
            if (moneda?.length > 0 && !filtroCadenaSinEspacio.test(moneda)) {
                const error = "El campo moneda solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }

            if (tipoValor) {

                const validarTipoValor = `
                SELECT 
                "tipoValorIDV"
                FROM "impuestoTipoValor"
                WHERE "tipoValorIDV" = $1
                `
                const resuelveValidarTipoValor = await conexion.query(validarTipoValor, [tipoValor])
                if (resuelveValidarTipoValor.rowCount === 0) {
                    const error = "No existe el tipo valor verifica el campor tipoValor"
                    throw new Error(error)
                }
            }

            if (aplicacionSobre) {
                const validarAplicacionSobre = `
                SELECT 
                "aplicacionIDV"
                FROM "impuestosAplicacion"
                WHERE "aplicacionIDV" = $1
                `
                const resuelveValidarAplicacionSobre = await conexion.query(validarAplicacionSobre, [aplicacionSobre])
                if (resuelveValidarAplicacionSobre.rowCount === 0) {
                    const error = "No existe el contexto de aplicacion verifica el campor resuelveValidarAplicacionSobre"
                    throw new Error(error)
                }
            }

            if (moneda) {

                const validarMoneda = `
                SELECT 
                "monedaIDV"
                FROM monedas
                WHERE "monedaIDV" = $1
                `
                const resuelveValidarMoneda = await conexion.query(validarMoneda, [moneda])
                if (resuelveValidarMoneda.rowCount === 0) {
                    const error = "No existe la moneda, verifica el campo moneda"
                    throw new Error(error)
                }
            }


            const validarImpuestoYActualizar = `
            UPDATE impuestos
            SET 
            impuesto = COALESCE($1, impuesto),
            "tipoImpositivo" = COALESCE($2, "tipoImpositivo"),
            "tipoValor" = COALESCE($3, "tipoValor"),
            "aplicacionSobre" = COALESCE($4, "aplicacionSobre"),
            moneda = COALESCE($5, moneda)
            WHERE idv = $6
            RETURNING
            impuesto,
            "tipoImpositivo",
            "tipoValor",
            "aplicacionSobre",
            moneda
            `
            const resuelveValidarImpuesto = await conexion.query(validarImpuestoYActualizar, [nombreImpuesto, tipoImpositivo, tipoValor, aplicacionSobre, moneda, impuestoUID])
            if (resuelveValidarImpuesto.rowCount === 0) {
                const error = "No existe el perfil del impuesto"
                throw new Error(error)
            }

            const validarImpuesto = `
            SELECT
            i.impuesto AS "nombreImpuesto",
            i.idv AS "impuestoUID",
            i."tipoImpositivo",
            i."tipoValor" AS "tipoValorIDV",
            itv."tipoValorUI" AS "tipoValorUI",
            i."aplicacionSobre" AS "aplicacionSobreIDV",
            ias."aplicacionUI" AS "aplicacionSobreUI",
            i."moneda" AS "monedaIDV",
            mon."monedaUI" AS "monedaUI"
            FROM
            impuestos i
            JOIN
            "impuestoTipoValor" itv ON i."tipoValor" = itv."tipoValorIDV"
            JOIN
            "impuestosAplicacion" ias ON i."aplicacionSobre" = ias."aplicacionIDV"
            JOIN
            "monedas" mon ON i."moneda" = mon."monedaIDV"
            WHERE
            i.idv = $1;
            `
            const resuelveObtenerDetallesImpuesto = await conexion.query(validarImpuesto, [impuestoUID])
            if (resuelveObtenerDetallesImpuesto.rowCount === 0) {
                const error = "No existe el perfil del impuesto"
                throw new Error(error)
            }


            const perfilImpuesto = resuelveObtenerDetallesImpuesto.rows[0]



            const ok = {
                "ok": "El impuesto se ha actualizado correctamente",
                "detallesImpuesto": perfilImpuesto
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "opcionesEditarImpuesto") {
        try {
            const impuestoUID = entrada.body.impuestoUID

            if (typeof impuestoUID !== "number" || !Number.isInteger(impuestoUID) || impuestoUID <= 0) {
                const error = "El campo 'impuestoUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            const validarImpuesto = `
            SELECT
            "tipoValor", "aplicacionSobre", moneda
            FROM 
            impuestos
            WHERE idv = $1
            `
            const resuelveValidarImpuesto = await conexion.query(validarImpuesto, [impuestoUID])
            if (resuelveValidarImpuesto.rowCount === 0) {
                const error = "No existe el perfil del impuesto"
                throw new Error(error)
            }
            const perfilImpuesto = resuelveValidarImpuesto.rows[0]

            impuestoUID = perfilImpuesto.idv

            const opcionesTipoValor = []
            const opcionesAplicacionSobre = []
            const opcionesMonedas = []

            const validarTipoValor = `
            SELECT 
            "tipoValorIDV", "tipoValorUI", simbolo
            FROM "impuestoTipoValor"
            `
            const resuelveValidarTipoValor = await conexion.query(validarTipoValor)
            if (resuelveValidarTipoValor.rowCount > 0) {

                opcionesTipoValor = resuelveValidarTipoValor.rows

            }
            const validarAplicacionSobre = `
            SELECT 
            "aplicacionIDV", "aplicacionUI"
            FROM "impuestosAplicacion"
            `
            const resuelveValidarAplicacionSobre = await conexion.query(validarAplicacionSobre)
            if (resuelveValidarAplicacionSobre.rowCount > 0) {
                opcionesAplicacionSobre = resuelveValidarAplicacionSobre.rows

            }

            const validarMoneda = `
            SELECT 
            "monedaIDV", "monedaUI", simbolo
            FROM monedas
            `
            const resuelveValidarMoneda = await conexion.query(validarMoneda)
            if (resuelveValidarMoneda.rowCount > 0) {
                opcionesMonedas = resuelveValidarMoneda.rows
            }


            const detallesImpuesto = {
                "tipoValor": opcionesTipoValor,
                "aplicacionSobre": opcionesAplicacionSobre,
                "moneda": opcionesMonedas
            }

            const ok = {
                "ok": detallesImpuesto
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "eliminarPerfilImpuesto") {
        try {
            const impuestoUID = entrada.body.impuestoUID
            if (typeof impuestoUID !== "number" || !Number.isInteger(impuestoUID) || impuestoUID <= 0) {
                const error = "El campo 'impuestoUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }

            const validarYEliminarImpuesto = `
            DELETE FROM impuestos
            WHERE idv = $1;
            `
            const resuelveValidarYEliminarImpuesto = await conexion.query(validarYEliminarImpuesto, [impuestoUID])
            if (resuelveValidarYEliminarImpuesto.rowCount === 0) {
                const error = "No existe el perfil del impuesto que deseas eliminar"
                throw new Error(error)
            }
            const ok = {
                "ok": "Perfil del impuesto eliminado"
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "crearNuevoImpuesto") {
        try {
            const nombreImpuesto = entrada.body.nombreImpuesto
            const tipoImpositivo = entrada.body.tipoImpositivo
            const tipoValor = entrada.body.tipoValor
            const aplicacionSobre = entrada.body.aplicacionSobre
            const moneda = entrada.body.moneda

            const filtroCadena = /^[a-zA-Z0-9 ]+$/;
            if (!nombreImpuesto || !filtroCadena.test(nombreImpuesto)) {
                const error = "El campo nombreImpuesto solo puede ser un una cadena de min√∫sculas"
                throw new Error(error)
            }
            const filtroTipoImpositivo = /^\d+(\.\d{2})?$/;
            if (!tipoImpositivo || (typeof tipoImpositivo !== "string" || !filtroTipoImpositivo.test(tipoImpositivo))) {
                const error = "El campo tipoImpositivo solo puede ser una cadena con un numero y dos decimlaes"
                throw new Error(error)
            }
            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;
            if (!tipoValor || !filtroCadenaSinEspacio.test(tipoValor)) {
                const error = "El campo tipoValor solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }
            const filtroCadena_mMN = /^[a-zA-Z0-9]+$/;
            if (!aplicacionSobre || !filtroCadena_mMN.test(aplicacionSobre)) {
                const error = "El campo aplicacionSobre solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }
            if (!moneda || !filtroCadenaSinEspacio.test(moneda)) {
                const error = "El campo moneda solo puede ser un una cadena de min√∫sculas y numeros sin espacios"
                throw new Error(error)
            }

            if (tipoValor) {

                const validarTipoValor = `
                SELECT 
                "tipoValorIDV"
                FROM "impuestoTipoValor"
                WHERE "tipoValorIDV" = $1
                `
                const resuelveValidarTipoValor = await conexion.query(validarTipoValor, [tipoValor])
                if (resuelveValidarTipoValor.rowCount === 0) {
                    const error = "No existe el tipo valor verifica el campor tipoValor"
                    throw new Error(error)
                }
            }

            if (aplicacionSobre) {
                const validarAplicacionSobre = `
                SELECT 
                "aplicacionIDV"
                FROM "impuestosAplicacion"
                WHERE "aplicacionIDV" = $1
                `
                const resuelveValidarAplicacionSobre = await conexion.query(validarAplicacionSobre, [aplicacionSobre])
                if (resuelveValidarAplicacionSobre.rowCount === 0) {
                    const error = "No existe el contexto de aplicacion verifica el campor resuelveValidarAplicacionSobre"
                    throw new Error(error)
                }
            }

            if (moneda) {

                const validarMoneda = `
                SELECT 
                "monedaIDV"
                FROM monedas
                WHERE "monedaIDV" = $1
                `
                const resuelveValidarMoneda = await conexion.query(validarMoneda, [moneda])
                if (resuelveValidarMoneda.rowCount === 0) {
                    const error = "No existe la moneda, verifica el campo moneda"
                    throw new Error(error)
                }
            }


            const validarImpuestoYActualizar = `
            INSERT INTO impuestos
            (
            impuesto,
            "tipoImpositivo",
            "tipoValor",
            "aplicacionSobre",
            moneda
            )
            VALUES ($1, $2, $3, $4, $5)
            RETURNING idv
            `
            const resuelveValidarImpuesto = await conexion.query(validarImpuestoYActualizar, [nombreImpuesto, tipoImpositivo, tipoValor, aplicacionSobre, moneda])
            const nuevoUIDImpuesto = resuelveValidarImpuesto.rows[0].idv


            const ok = {
                "ok": "Sea creado el nuevo impuesto",
                "nuevoImpuestoUID": nuevoUIDImpuesto
            }
            salida.json(ok)
        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }


    }
    if (transaccion === "opcionesCrearImpuesto") {
        try {
            let opcionesTipoValor = []
            let opcionesAplicacionSobre = []
            let opcionesMonedas = []

            const validarTipoValor = `
            SELECT 
            "tipoValorIDV", "tipoValorUI", simbolo
            FROM "impuestoTipoValor"
            `
            const resuelveValidarTipoValor = await conexion.query(validarTipoValor)
            if (resuelveValidarTipoValor.rowCount > 0) {

                opcionesTipoValor = resuelveValidarTipoValor.rows

            }
            const validarAplicacionSobre = `
            SELECT 
            "aplicacionIDV", "aplicacionUI"
            FROM "impuestosAplicacion"
            `
            const resuelveValidarAplicacionSobre = await conexion.query(validarAplicacionSobre)
            if (resuelveValidarAplicacionSobre.rowCount > 0) {
                opcionesAplicacionSobre = resuelveValidarAplicacionSobre.rows

            }

            const validarMoneda = `
            SELECT 
            "monedaIDV", "monedaUI", simbolo
            FROM monedas
            `
            const resuelveValidarMoneda = await conexion.query(validarMoneda)
            if (resuelveValidarMoneda.rowCount > 0) {
                opcionesMonedas = resuelveValidarMoneda.rows
            }


            const detallesImpuesto = {
                "tipoValor": opcionesTipoValor,
                "aplicacionSobre": opcionesAplicacionSobre,
                "moneda": opcionesMonedas
            }

            const ok = {
                "ok": detallesImpuesto
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "crearOferta") {
        try {
            const nombreOferta = entrada.body.nombreOferta
            const fechaInicio = entrada.body.fechaInicio
            const fechaFin = entrada.body.fechaFin
            const tipoOferta = entrada.body.tipoOferta
            const tipoDescuento = entrada.body.tipoDescuento ? entrada.body.tipoDescuento : null
            let cantidad = entrada.body.cantidad
            const contextoAplicacion = entrada.body.contextoAplicacion
            const apartamentosSeleccionados = entrada.body.apartamentosSeleccionados
            const simboloNumero = entrada.body.simboloNumero
            const numero = entrada.body.numero

            const filtroCantidad = /^\d+(\.\d{1,2})?$/;
            const filtroNombre = /^[a-zA-Z0-9\s]+$/;
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;


            if (!nombreOferta || !filtroNombre.test(nombreOferta)) {
                const error = "El campo nombreOferta solo admite min√∫sculas, may√∫sculas, numeros y espacios"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaInicio)) {
                const error = "el formato fecha de inicio no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaFin)) {
                const error = "el formato fecha de fin no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }

            if (tipoOferta !== "porNumeroDeApartamentos" &&
                tipoOferta !== "porApartamentosEspecificos" &&
                tipoOferta !== "porDiasDeAntelacion" &&
                tipoOferta !== "porRangoDeFechas" &&
                tipoOferta !== "porDiasDeReserva"
            ) {
                const error = "No se reconoce el tipo de oferta"
                throw new Error(error)
            }

            // Validar nombre unico oferta
            const validarNombreOfertaUnico = `
            SELECT "nombreOferta"
            FROM ofertas
            WHERE "nombreOferta" = $1
            `
            const consultaValidarNombreOfertaUnico = await conexion.query(validarNombreOfertaUnico, [nombreOferta])
            if (consultaValidarNombreOfertaUnico.rowCount > 0) {
                const error = "Ya existe un nombre de oferta exactamente igual a este, por favor elige otro nombre para esta oferta con el fin de evitar confusiones"
                throw new Error(error)
            }



            if (tipoDescuento === "precioEstablecido") {

                const controlPrecioEstablecido = `
                SELECT 
                *
                FROM ofertas
                WHERE ("fechaInicio" <= $1 AND "fechaFin" >= $2) AND "tipoDescuento" = $3;
                `
                const resuelveControlPrecioEstablecido = await conexion.query(controlPrecioEstablecido, [fechaInicio, fechaFin, tipoDescuento]);

            }







            const validadoresCompartidos = {
                numero: (numero) => {
                    numero = Number(numero)
                    if (!numero || !Number.isInteger(numero) || numero <= 0) {
                        const error = "El campo numero debe de ser un numer entero y positivo1"
                        throw new Error(error)
                    }
                },
                simboloNumero: (simboloNumero) => {
                    if (!simboloNumero || (simboloNumero !== "numeroExacto" && simboloNumero !== "aPartirDe")) {
                        const error = "El campo simboloNumero debe de ser un numer entero y positivo"
                        throw new Error(error)
                    }
                },
                tipoDescuento: (tipoDescuento) => {
                    if (!tipoDescuento || (tipoDescuento !== "cantidadFija" && tipoDescuento !== "porcentaje")) {
                        const error = `El tipo de descuento solo puede ser cantidadFija, porcentable o precioEstablecido`
                        throw new Error(error)
                    }
                },
                contextoAplicacion: (contextoAplicacion) => {
                    if (!contextoAplicacion || (contextoAplicacion !== "totalNetoReserva" && contextoAplicacion !== "totalNetoApartmentoDedicado")) {
                        const error = `El campo contexto de aplicacion solo puede ser, totalNetoReserva, totalNetoApartamentoDedicado`
                        throw new Error(error)
                    }
                },
                cantidad: (cantidad) => {
                    if (!cantidad || !filtroCantidad.test(cantidad)) {
                        const error = "El campo cantidad debe ser un n√∫mero con un m√°ximo de dos decimales separados por punto. Recuerda que number es sin comillas.";
                        throw new Error(error);
                    }
                    cantidad = Number(cantidad)

                },
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const inertarOfertaValidada = async (metadatos) => {
                const nombreOferta = metadatos.nombreOferta
                const fechaInicio = metadatos.fechaInicio
                const fechaFin = metadatos.fechaFin

                const simboloNumero = metadatos.simboloNumero
                const numero = metadatos.numero

                const contextoAplicacion = metadatos.contextoAplicacion
                const estadoInicalDesactivado = "desactivada"
                const tipoOferta = metadatos.tipoOferta
                const cantidad = metadatos.cantidad
                const tipoDescuento = metadatos.tipoDescuento

                const crearOfertaDesactivada = `
                INSERT INTO ofertas
                (
                    "nombreOferta",
                    "fechaInicio",
                    "fechaFin",
                    "simboloNumero",
                    "numero",
                    "descuentoAplicadoA",
                    "estadoOferta",
                    "tipoOferta",
                    cantidad,
                    "tipoDescuento"
                )
                VALUES
                (
                    COALESCE($1, NULL),
                    COALESCE($2::date, NULL),
                    COALESCE($3::date, NULL),
                    NULLIF($4, NULL),
                    NULLIF($5::numeric, NULL),
                    COALESCE($6, NULL),
                    COALESCE($7, NULL),
                    COALESCE($8, NULL),
                    NULLIF($9::numeric, NULL),
                    NULLIF($10, NULL)
                )
                RETURNING uid;
                `
                const datos = [
                    nombreOferta,
                    fechaInicio,
                    fechaFin,
                    simboloNumero,
                    numero,
                    contextoAplicacion,
                    estadoInicalDesactivado,
                    tipoOferta,
                    cantidad,
                    tipoDescuento
                ]
                const resuelveCrearOfertaDesactivada = await conexion.query(crearOfertaDesactivada, datos)
                if (resuelveCrearOfertaDesactivada.rowCount === 1) {
                    const estructuraFinal = {
                        "ok": "Se ha creado la oferta correctamente",
                        "nuevoUIDOferta": resuelveCrearOfertaDesactivada.rows[0].uid
                    }
                    return estructuraFinal
                }
                if (resuelveCrearOfertaDesactivada.rowCount === 0) {
                    const error = "Ha ocurrido un error y no se ha insertado la oferta"
                    throw new Error(error)
                }

            }

            if (tipoOferta === "porNumeroDeApartamentos") {

                validadoresCompartidos.simboloNumero(simboloNumero)
                validadoresCompartidos.numero(numero)
                validadoresCompartidos.cantidad(cantidad)
                validadoresCompartidos.tipoDescuento(tipoDescuento)

                const oferta = {
                    "nombreOferta": nombreOferta,
                    "fechaInicio": fechaInicio,
                    "fechaFin": fechaFin,
                    "simboloNumero": simboloNumero,
                    "numero": numero,
                    "tipoOferta": tipoOferta,
                    "cantidad": cantidad,
                    "tipoDescuento": tipoDescuento
                }
                const resolutor = await inertarOfertaValidada(oferta)
                salida.json(resolutor)



            }
            if (tipoOferta === "porApartamentosEspecificos") {

                const filtroCadena = /^[a-zA-Z0-9]+$/;
                const filtroCadenaUI = /^[a-zA-Z0-9\s]+$/;

                if (typeof apartamentosSeleccionados !== 'object' && !Array.isArray(apartamentosSeleccionados)) {
                    const error = "El campo apartamentosSeleccionados solo admite un arreglo"
                    throw new Error(error)
                }
                if (apartamentosSeleccionados.length === 0) {
                    const error = "Anada al menos un apartmento dedicado"
                    throw new Error(error)
                }

                validadoresCompartidos.contextoAplicacion(contextoAplicacion)

                if (contextoAplicacion === "totalNetoReserva") {
                    validadoresCompartidos.cantidad(cantidad)
                    validadoresCompartidos.tipoDescuento(tipoDescuento)
                }

                for (const apartamentoSeleccionado of apartamentosSeleccionados) {
                    const apartamentoIDV = apartamentoSeleccionado.apartamentoIDV
                    const apartamentoUI = apartamentoSeleccionado.apartamentoUI
                    const tipoDescuentoApartamento = apartamentoSeleccionado.tipoDescuento
                    const cantidadPorApartamento = apartamentoSeleccionado.cantidad
                    if (!apartamentoIDV || !filtroCadena.test(apartamentoIDV)) {
                        const error = "El campo apartamentoIDV solo admite min√∫sculas, may√∫sculas y numeros nada mas ni espacios"
                        throw new Error(error)
                    }
                    if (!apartamentoUI || !filtroCadenaUI.test(apartamentoUI)) {
                        const error = "El campo apartamentoUI solo admite min√∫sculas, may√∫sculas, numeros y espacios nada mas ni espacios"
                        throw new Error(error)
                    }
                    if (contextoAplicacion === "totalNetoApartmentoDedicado") {
                        if (!tipoDescuentoApartamento || (tipoDescuentoApartamento !== "cantidadFija" && tipoDescuentoApartamento !== "porcentaje") && tipoDescuentoApartamento !== "precioEstablecido") {
                            const error = `El apartamento ${apartamentoUI} debe de tener un tipo de descuente seleccionado, revisa los apartamentos para ver si en alguno falta un tipo de descuente`
                            throw new Error(error)
                        }
                        if (!cantidadPorApartamento || typeof cantidadPorApartamento !== "string" || !filtroCantidad.test(cantidadPorApartamento)) {
                            const error = `El campo cantidad del ${apartamentoUI} dedicado debe ser un n√∫mero con un m√°ximo de dos decimales separados por punto. Escribe los decimales igualmente, ejemplo 10.00`
                            throw new Error(error);
                        }
                    }

                }

                if (contextoAplicacion === "totalNetoApartmentoDedicado") {

                    cantidad = null

                }
                const oferta = {
                    "nombreOferta": nombreOferta,
                    "fechaInicio": fechaInicio,
                    "fechaFin": fechaFin,
                    "contextoAplicacion": contextoAplicacion,
                    "tipoOferta": tipoOferta,
                    "cantidad": cantidad,
                    "tipoDescuento": tipoDescuento
                }


                const resolutor = await inertarOfertaValidada(oferta)

                const nuevoUIDOferta = resolutor.nuevoUIDOferta



                for (const apartamentoDedicado of apartamentosSeleccionados) {
                    const apartamentoIDV = apartamentoDedicado.apartamentoIDV

                    let tipoDescuento = null
                    let cantidadPorApartamento = null
                    if (contextoAplicacion === "totalNetoApartmentoDedicado") {
                        tipoDescuento = apartamentoDedicado.tipoDescuento
                        cantidadPorApartamento = apartamentoDedicado.cantidad
                        cantidadPorApartamento = Number(cantidadPorApartamento)
                    }



                    const ofertaApartamentosDedicados = `
                    INSERT INTO "ofertasApartamentos"
                    (
                        oferta,
                        apartamento,
                        "tipoDescuento",
                        cantidad
                    )
                    VALUES
                    (
                        NULLIF($1::numeric, NULL),
                        NULLIF($2, NULL),
                        NULLIF($3, NULL),
                        NULLIF($4::numeric, NULL)
                    )
                    `
                    const detallesApartamentoDedicado = [
                        nuevoUIDOferta,
                        apartamentoIDV,
                        tipoDescuento,
                        cantidadPorApartamento
                    ]
                    await conexion.query(ofertaApartamentosDedicados, detallesApartamentoDedicado)

                }
                const ok = {
                    "ok": "La oferta se ha creado bien",
                    "nuevoUIDOferta": nuevoUIDOferta
                }
                salida.json(ok)

            }
            if (tipoOferta === "porDiasDeAntelacion") {

                validadoresCompartidos.simboloNumero(simboloNumero)
                validadoresCompartidos.numero(numero)
                validadoresCompartidos.cantidad(cantidad)
                validadoresCompartidos.tipoDescuento(tipoDescuento)

                let oferta = {
                    "nombreOferta": nombreOferta,
                    "fechaInicio": fechaInicio,
                    "fechaFin": fechaFin,
                    "simboloNumero": simboloNumero,
                    "contextoAplicacion": contextoAplicacion,
                    "tipoOferta": tipoOferta,
                    "cantidad": cantidad,
                    "tipoDescuento": tipoDescuento
                }
                let resolutor = await inertarOfertaValidada(oferta)
                salida.json(resolutor)


            }
            if (tipoOferta === "porDiasDeReserva") {
                validadoresCompartidos.simboloNumero(simboloNumero)
                validadoresCompartidos.numero(numero)

                validadoresCompartidos.cantidad(cantidad)

                validadoresCompartidos.tipoDescuento(tipoDescuento)


                //    simboloNumero = entrada.body.simboloNumero

                let oferta = {
                    "nombreOferta": nombreOferta,
                    "fechaInicio": fechaInicio,
                    "fechaFin": fechaFin,
                    "simboloNumero": simboloNumero,
                    "contextoAplicacion": contextoAplicacion,
                    "tipoOferta": tipoOferta,
                    "cantidad": cantidad,
                    "tipoDescuento": tipoDescuento
                }
                let resolutor = await inertarOfertaValidada(oferta)
                salida.json(resolutor)

            }
            if (tipoOferta === "porRangoDeFechas") {
                validadoresCompartidos.cantidad(cantidad)
                validadoresCompartidos.tipoDescuento(tipoDescuento)

                let oferta = {
                    "nombreOferta": nombreOferta,
                    "fechaInicio": fechaInicio,
                    "fechaFin": fechaFin,
                    "tipoOferta": tipoOferta,
                    "cantidad": cantidad,
                    "tipoDescuento": tipoDescuento
                }
                let resolutor = await inertarOfertaValidada(oferta)
                salida.json(resolutor)
            }

            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "listasOfertasAdministracion") {
        try {
            const listarOfertas = `
            SELECT
            o."nombreOferta",
            o.uid,
            to_char("fechaInicio", 'DD/MM/YYYY') as "fechaInicio", 
            to_char("fechaFin", 'DD/MM/YYYY') as "fechaFin",
            o."numero",
            oa."aplicacionUI" AS "descuentoAplicadoAUI",
            o."simboloNumero",
            o."descuentoAplicadoA" AS "descuentoAplicadoAIDV",
            oe."estadoUI" AS "estadoOferta",
            ot."tipoOfertaUI" AS "tipoOfertaUI",
            o."tipoOferta" AS "tipoOfertaIDV",
            o."cantidad",
            o."tipoDescuento"
            FROM 
            ofertas o
            LEFT JOIN
            "ofertasAplicacion" oa ON o."descuentoAplicadoA" = oa."aplicacionIDV"
            LEFT JOIN
            "ofertasEstado" oe ON o."estadoOferta" = oe."estadoIDV"
            LEFT JOIN
            "ofertasTipo" ot ON o."tipoOferta" = ot."tipoOfertaIDV"
            LEFT JOIN
            "ofertasTipoDescuento" otd ON o."tipoDescuento" = otd."tipoDescuentoIDV"
            ORDER BY 
            "fechaInicio" ASC;
            `
            const resuelveListarOfertas = await conexion.query(listarOfertas)
            if (resuelveListarOfertas.rowCount === 0) {
                const ok = {
                    "ok": "No hay ofertas configuradas"
                }
                salida.json(ok)
            }
            const ofertasEntonctradas = []
            if (resuelveListarOfertas.rowCount > 0) {
                const ofertas = resuelveListarOfertas.rows
                const ofertaDetalle = {}
                for (const ofertaDetalles of ofertas) {
                    const uid = ofertaDetalles.uid
                    const nombreOferta = ofertaDetalles.nombreOferta
                    const fechaInicio = ofertaDetalles.fechaInicio
                    const fechaFin = ofertaDetalles.fechaFin
                    const estadoOferta = ofertaDetalles.estadoOferta
                    const numero = ofertaDetalles.numero
                    const simboloNumero = ofertaDetalles.simboloNumero
                    const tipoOfertaIDV = ofertaDetalles.tipoOfertaIDV
                    const tipoOfertaUI = ofertaDetalles.tipoOfertaUI
                    const cantidad = ofertaDetalles.cantidad
                    const tipoDescuento = ofertaDetalles.tipoDescuento

                    const descuentoAplicadoAIDV = ofertaDetalles.descuentoAplicadoAIDV
                    const descuentoAplicadoAUI = ofertaDetalles.descuentoAplicadoAUI

                    ofertaDetalle.uid = uid
                    ofertaDetalle.nombreOferta = nombreOferta
                    ofertaDetalle.fechaInicio = fechaInicio
                    ofertaDetalle.fechaFin = fechaFin
                    ofertaDetalle.estadoOferta = estadoOferta
                    ofertaDetalle.tipoOfertaIDV = tipoOfertaIDV
                    ofertaDetalle.tipoOfertaUI = tipoOfertaUI
                    ofertaDetalle.descuentoAplicadoAIDV = descuentoAplicadoAIDV
                    ofertaDetalle.descuentoAplicadoAUI = descuentoAplicadoAUI
                    ofertaDetalle.simboloNumero = simboloNumero
                    ofertaDetalle.numero = numero
                    ofertaDetalle.cantidad = cantidad
                    ofertaDetalle.tipoDescuento = tipoDescuento

                    if (tipoOfertaIDV === "porNumeroDeApartamentos" || tipoOfertaIDV === "porDiasDeAntelacion" || tipoOfertaIDV === "porDiasDeReserva") {


                    }

                    if (tipoOfertaIDV === "porApartamentosEspecificos") {


                        //Arreglar esto, esto esta bien es una resolucion en modo joint
                        const detallesApartamentosDedicados = `
                        SELECT
                        oa.apartamento AS "apartamentoIDV",
                        a."apartamentoUI",
                        oa."tipoDescuento",
                        oa."cantidad"
                        FROM 
                        "ofertasApartamentos" oa
                        LEFT JOIN
                        "apartamentos" a ON oa.apartamento = a.apartamento
                        WHERE oferta = $1
                        `
                        const resuelveDetallesApartamentosDedicados = await conexion.query(detallesApartamentosDedicados, [uid])
                        if (resuelveDetallesApartamentosDedicados.rowCount === 0) {
                            ofertaDetalle.apartamentosDedicados = []
                        }

                        if (resuelveDetallesApartamentosDedicados.rowCount > 0) {
                            const apartamentosDedicados = resuelveDetallesApartamentosDedicados.rows
                            ofertaDetalle.apartamentosDedicados = []
                            apartamentosDedicados.map((apartamento) => {
                                const apartamentoIDV = apartamento.apartamentoIDV
                                const apartamentoUI = apartamento.apartamentoUI
                                const tipoDescuentoApartamento = apartamento.tipoDescuento
                                const cantidadApartamento = apartamento.cantidad
                                const detallesApartamentoDedicado = {
                                    "apartamentoIDV": apartamentoIDV,
                                    "apartamentoUI": apartamentoUI,
                                    "tipoDescuento": tipoDescuentoApartamento,
                                    "cantidadApartamento": cantidadApartamento

                                }
                                ofertaDetalle.apartamentosDedicados.push(detallesApartamentoDedicado)
                            })
                        }
                    }
                    ofertasEntonctradas.push(ofertaDetalle)
                }

                const ok = {
                    "ok": ofertasEntonctradas
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "detallesOferta") {

        try {
            const ofertaUID = entrada.body.ofertaUID
            if (!ofertaUID || typeof ofertaUID !== "number" || !Number.isInteger(ofertaUID) || ofertaUID <= 0) {
                const error = "El campo 'ofertaUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const consultaDetallesOferta = `
            SELECT
            o.uid,
            to_char(o."fechaInicio", 'DD/MM/YYYY') as "fechaInicio", 
            to_char(o."fechaFin", 'DD/MM/YYYY') as "fechaFin", 
            o."numero",
            o."simboloNumero",
            o."descuentoAplicadoA" as "descuentoAplicadoAIDV",
            oa."aplicacionUI" as "descuentoAplicadoAUI",
            o."estadoOferta" as "estadoOfertaIDV",
            oe."estadoUI" as "estadoOfertaUI",
            o."tipoOferta" as "tipoOfertaIDV",
            ot."tipoOfertaUI" as "tipoOfertaUI",
            o."tipoDescuento" as "tipoDescuentoIDV",
            otd."tipoDescuentoUI" as "tipoDescuentoUI",
            o.cantidad AS "cantidad",
            o."nombreOferta"
            FROM
            ofertas o
            LEFT JOIN
            "ofertasAplicacion" oa ON o."descuentoAplicadoA" = oa."aplicacionIDV"
            LEFT JOIN
            "ofertasEstado" oe ON o."estadoOferta" = oe."estadoIDV"
            LEFT JOIN
            "ofertasTipo" ot ON o."tipoOferta" = ot."tipoOfertaIDV"
            LEFT JOIN
            "ofertasTipoDescuento" otd ON o."tipoDescuento" = otd."tipoDescuentoIDV"
            WHERE
            o.uid = $1;
            `
            const resuelveConsultaDetallesOferta = await conexion.query(consultaDetallesOferta, [ofertaUID])
            const oferta = resuelveConsultaDetallesOferta.rows[0]
            if (resuelveConsultaDetallesOferta.rowCount === 0) {
                const error = "No existe ninguna reserva con ese UID"
                throw new Error(error)
            }

            if (resuelveConsultaDetallesOferta.rowCount === 1) {
                if (oferta.tipoOfertaIDV === "porNumeroDeApartamentos" || oferta.tipoOfertaIDV === "porDiasDeAntelacion" || oferta.tipoOfertaIDV === "porDiasDeReserva" || oferta.tipoOfertaIDV === "porRangoDeFechas") {
                    const ok = {
                        "ok": oferta
                    }
                    salida.json(ok)
                }

                if (oferta.tipoOfertaIDV === "porApartamentosEspecificos") {
                    const detallesOferta = oferta
                    detallesOferta["apartamentosDedicados"] = []
                    const detallesApartamentosDedicados = `
                    SELECT
                    oa.apartamento AS "apartamentoIDV",
                    a."apartamentoUI",
                    oa."tipoDescuento",
                    oa."cantidad"
                    FROM 
                    "ofertasApartamentos" oa
                    LEFT JOIN
                    "apartamentos" a ON oa.apartamento = a.apartamento
                    WHERE oferta = $1
                    `
                    const resuelveDetallesApartamentosDedicados = await conexion.query(detallesApartamentosDedicados, [oferta.uid])

                    if (resuelveDetallesApartamentosDedicados.rowCount > 0) {

                        let apartamentosDedicados = resuelveDetallesApartamentosDedicados.rows
                        detallesOferta["apartamentosDedicados"] = []

                        apartamentosDedicados.map((apartamento) => {
                            let apartamentoIDV = apartamento.apartamentoIDV
                            let apartamentoUI = apartamento.apartamentoUI
                            let tipoDescuentoApartamento = apartamento.tipoDescuento
                            let cantidadApartamento = apartamento.cantidad
                            let detallesApartamentoDedicado = {
                                "apartamentoIDV": apartamentoIDV,
                                "apartamentoUI": apartamentoUI,
                                "tipoDescuento": tipoDescuentoApartamento,
                                "cantidadApartamento": cantidadApartamento

                            }
                            detallesOferta["apartamentosDedicados"].push(detallesApartamentoDedicado)
                        })
                    }
                    const ok = {
                        "ok": detallesOferta
                    }
                    salida.json(ok)


                }
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "opcionesCrearOferta") {
        try {
            let opcionesCrearOferta = {}
            let listaAplicacionOferta = `
            SELECT
            "aplicacionIDV", "aplicacionUI"
            FROM 
            "ofertasAplicacion"
            `
            let resuelveListaAplicacionOferta = await conexion.query(listaAplicacionOferta)
            opcionesCrearOferta.aplicacionSobre = resuelveListaAplicacionOferta.rows

            let listaTipoOfertas = `
            SELECT
            "tipoOfertaIDV", "tipoOfertaUI"
            FROM 
            "ofertasTipo"
            `
            let resuelveListaTipoOfertas = await conexion.query(listaTipoOfertas)
            opcionesCrearOferta.tipoOfertas = resuelveListaTipoOfertas.rows

            let listaTipoDescuento = `
            SELECT
            "tipoDescuentoIDV", "tipoDescuentoUI"
            FROM 
            "ofertasTipoDescuento"
            `
            let resuelveListaTipoDescuento = await conexion.query(listaTipoDescuento)
            opcionesCrearOferta.tipoDescuento = resuelveListaTipoDescuento.rows


            let ok = {
                "ok": opcionesCrearOferta
            }
            salida.json(ok)

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "actualizarOferta") {
        try {
            const nombreOferta = entrada.body.nombreOferta
            const fechaInicio = entrada.body.fechaInicio
            const fechaFin = entrada.body.fechaFin
            const tipoOferta = entrada.body.tipoOferta
            const ofertaUID = entrada.body.ofertaUID
            const tipoDescuento = entrada.body.tipoDescuento ? entrada.body.tipoDescuento : null
            let cantidad = entrada.body.cantidad
            const numero = entrada.body.numero
            const simboloNumero = entrada.body.simboloNumero
            const contextoAplicacion = entrada.body.contextoAplicacion
            const apartamentosSeleccionados = entrada.body.apartamentosSeleccionados
            const filtroCantidad = /^\d+\.\d{2}$/;
            const filtroNombre = /^[a-zA-Z0-9\s]+$/;

            if (!ofertaUID || !Number.isInteger(ofertaUID) || ofertaUID <= 0) {
                const error = "El campo ofertaUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            if (!nombreOferta || !filtroNombre.test(nombreOferta)) {
                const error = "El campo nombreOferta solo admite min√∫sculas, may√∫sculas, numeros y espacios"
                throw new Error(error)
            }
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaInicio)) {
                const error = "el formato fecha de inicio no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaFin)) {
                const error = "el formato fecha de fin no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }


            if (tipoOferta !== "porNumeroDeApartamentos" &&
                tipoOferta !== "porApartamentosEspecificos" &&
                tipoOferta !== "porDiasDeAntelacion" &&
                tipoOferta !== "porRangoDeFechas" &&
                tipoOferta !== "porDiasDeReserva") {
                const error = "No se reconoce el tipo de oferta"
                throw new Error(error)
            }

            const validadoresCompartidos = {
                numero: (numero) => {
                    numero = Number(numero)
                    if (!numero || !Number.isInteger(numero) || numero <= 0) {
                        const error = "El campo numero debe de ser un numer entero y positivo1"
                        throw new Error(error)
                    }
                },
                simboloNumero: (simboloNumero) => {
                    if (!simboloNumero || (simboloNumero !== "numeroExacto" && simboloNumero !== "aPartirDe")) {
                        const error = "El campo simboloNumero debe de ser un numer entero y positivo"
                        throw new Error(error)
                    }
                },
                tipoDescuento: (tipoDescuento) => {
                    if (!tipoDescuento || (tipoDescuento !== "cantidadFija" && tipoDescuento !== "porcentaje")) {
                        const error = `El tipo de descuento solo puede ser cantidadFija, porcentable o precioEstablecido`
                        throw new Error(error)
                    }
                },
                contextoAplicacion: (contextoAplicacion) => {
                    if (!contextoAplicacion || (contextoAplicacion !== "totalNetoReserva" && contextoAplicacion !== "totalNetoApartmentoDedicado")) {
                        const error = `El campo contexto de aplicacion solo puede ser, totalNetoReserva, totalNetoApartamentoDedicado`
                        throw new Error(error)
                    }
                },
                cantidad: (cantidad) => {
                    if (!cantidad || !filtroCantidad.test(cantidad)) {
                        const error = "El campo cantidad debe ser un n√∫mero con un m√°ximo de dos decimales separados por punto. Recuerda que number es sin comillas.";
                        throw new Error(error);
                    }
                },
            }

            // Validar nombre unico oferta
            const validarNombreOfertaUnico = `
            SELECT "nombreOferta"
            FROM ofertas
            WHERE "nombreOferta" = $1 AND uid <> $2
            `
            const consultaValidarNombreOfertaUnico = await conexion.query(validarNombreOfertaUnico, [nombreOferta, ofertaUID])
            if (consultaValidarNombreOfertaUnico.rowCount > 0) {
                const error = "Ya existe un nombre de oferta exactamente igual a este, por favor elige otro nombre para esta oferta con el fin de evitar confusiones"
                throw new Error(error)
            }

            const consultaActualizarCompartido = async (metadatos) => {
                const nombreOferta = metadatos.nombreOferta
                const fechaInicio = metadatos.fechaInicio
                const fechaFin = metadatos.fechaFin
                const numero = metadatos.numero
                const simboloNumero = metadatos.simboloNumero
                const contextoAplicacion = metadatos.contextoAplicacion
                const tipoOferta = metadatos.tipoOferta
                const cantidad = metadatos.cantidad ? metadatos.cantidad : null
                const tipoDescuento = metadatos.tipoDescuento
                const ofertaUID = metadatos.ofertaUID

                const actualizarOferta = `
                UPDATE ofertas
                SET
                "nombreOferta" = COALESCE($1, NULL),
                "fechaInicio" = COALESCE($2::date, NULL),
                "fechaFin" = COALESCE($3::date, NULL),
                "numero" = COALESCE($4::numeric, NULL),
                "simboloNumero" = COALESCE($5, NULL),
                "descuentoAplicadoA" = COALESCE($6, NULL),
                "tipoOferta" = COALESCE($7, NULL),
                cantidad = COALESCE($8::numeric, NULL),
                "tipoDescuento" = COALESCE($9, NULL)
                WHERE uid = $10;
                
                
                `
                const datos = [
                    nombreOferta,
                    fechaInicio,
                    fechaFin,
                    numero,
                    simboloNumero,
                    contextoAplicacion,
                    tipoOferta,
                    cantidad,
                    tipoDescuento,
                    ofertaUID
                ]

                const resuelveActualizarOferta = await conexion.query(actualizarOferta, datos)
            }

            const eliminaPerfilApartamentoEspecificos = async (ofertaUID) => {
                const eliminarApartamentosDedicados = `
                DELETE FROM "ofertasApartamentos"
                WHERE oferta = $1 ;
                `
                await conexion.query(eliminarApartamentosDedicados, [ofertaUID])
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            // validadoresCompartidos.contextoAplicacion(contextoAplicacion)
            if (tipoOferta === "porNumeroDeApartamentos" ||
                tipoOferta === "porDiasDeAntelacion" ||
                tipoOferta === "porDiasDeReserva") {

                validadoresCompartidos.cantidad(cantidad)
                cantidad = Number(cantidad)
                validadoresCompartidos.tipoDescuento(tipoDescuento)
                validadoresCompartidos.numero(numero)
                validadoresCompartidos.simboloNumero(simboloNumero)


                eliminaPerfilApartamentoEspecificos(ofertaUID)
                const metadatos = {
                    nombreOferta: nombreOferta,
                    fechaInicio: fechaInicio,
                    fechaFin: fechaFin,
                    numero: numero,
                    simboloNumero: simboloNumero,
                    // contextoAplicacion: contextoAplicacion,
                    tipoOferta: tipoOferta,
                    cantidad: cantidad,
                    tipoDescuento: tipoDescuento,
                    ofertaUID: ofertaUID,
                }
                await consultaActualizarCompartido(metadatos)
                const ok = {
                    "ok": "Se ha acualizado correctamente la oferta"
                }
                salida.json(ok)
            }


            if (tipoOferta === "porRangoDeFechas") {

                validadoresCompartidos.cantidad(cantidad)
                cantidad = Number(cantidad)
                validadoresCompartidos.tipoDescuento(tipoDescuento)

                eliminaPerfilApartamentoEspecificos(ofertaUID)
                const metadatos = {
                    nombreOferta: nombreOferta,
                    fechaInicio: fechaInicio,
                    fechaFin: fechaFin,
                    numero: numero,
                    simboloNumero: simboloNumero,
                    // contextoAplicacion: contextoAplicacion,
                    tipoOferta: tipoOferta,
                    cantidad: cantidad,
                    tipoDescuento: tipoDescuento,
                    ofertaUID: ofertaUID,
                }
                await consultaActualizarCompartido(metadatos)
                const ok = {
                    "ok": "Se ha acualizado correctamente la oferta"
                }
                salida.json(ok)
            }



            if (tipoOferta === "porApartamentosEspecificos") {

                validadoresCompartidos.contextoAplicacion(contextoAplicacion)

                if (contextoAplicacion === "totalNetoReserva") {

                    validadoresCompartidos.cantidad(cantidad)
                    cantidad = Number(cantidad)

                    validadoresCompartidos.tipoDescuento(tipoDescuento)
                }

                if (typeof apartamentosSeleccionados !== 'object' && !Array.isArray(apartamentosSeleccionados)) {
                    const error = "El campo apartamentosSeleccionados solo admite un arreglo"
                    throw new Error(error)
                }
                if (apartamentosSeleccionados.length === 0) {
                    const error = "Anada al menos un apartmento dedicado"
                    throw new Error(error)
                }
                const filtroCadena = /^[a-zA-Z0-9]+$/;
                const filtroCadenaUI = /^[a-zA-Z0-9\s]+$/;;
                for (const apartamentoSeleccionado of apartamentosSeleccionados) {
                    const apartamentoIDV = apartamentoSeleccionado.apartamentoIDV
                    const apartamentoUI = apartamentoSeleccionado.apartamentoUI
                    const tipoDescuentoApartamento = apartamentoSeleccionado.tipoDescuento
                    const cantidadPorApartamento = apartamentoSeleccionado.cantidad
                    if (!apartamentoIDV || !filtroCadena.test(apartamentoIDV)) {
                        const error = "El campo apartamentoIDV solo admite min√∫sculas, may√∫sculas y numeros nada mas ni espacios"
                        throw new Error(error)
                    }
                    if (!apartamentoUI || !filtroCadenaUI.test(apartamentoUI)) {
                        const error = "El campo apartamentoUI solo admite min√∫sculas, may√∫sculas, numeros y espacios nada mas ni espacios"
                        throw new Error(error)
                    }
                    if (contextoAplicacion === "totalNetoApartmentoDedicado") {
                        if (!tipoDescuentoApartamento || (tipoDescuentoApartamento !== "cantidadFija" && tipoDescuentoApartamento !== "porcentaje") && tipoDescuentoApartamento !== "precioEstablecido") {
                            const error = `El apartamento ${apartamentoUI} debe de tener un tipo de descuente seleccionado, revisa los apartamentos para ver si en alguno falta un tipo de descuente`
                            throw new Error(error)
                        }
                        if (!cantidadPorApartamento || typeof cantidadPorApartamento !== "string" || !filtroCantidad.test(cantidadPorApartamento)) {
                            const error = `El campo cantidad del ${apartamentoUI} dedicado debe ser un n√∫mero con un m√°ximo de dos decimales separados por punto. Escribe los decimales igualmente, ejemplo 10.00`
                            throw new Error(error);
                        }
                    }

                }
                eliminaPerfilApartamentoEspecificos(ofertaUID)
                const metadatos_ = {
                    nombreOferta: nombreOferta,
                    fechaInicio: fechaInicio,
                    fechaFin: fechaFin,
                    contextoAplicacion: contextoAplicacion,
                    tipoOferta: tipoOferta,
                    cantidad: cantidad,
                    tipoDescuento: tipoDescuento,
                    ofertaUID: ofertaUID,
                }


                await consultaActualizarCompartido(metadatos_)




                eliminaPerfilApartamentoEspecificos(ofertaUID)
                let metadatos = {
                    nombreOferta: nombreOferta,
                    fechaInicio: fechaInicio,
                    fechaFin: fechaFin,
                    numero: numero,
                    simboloNumero: simboloNumero,
                    contextoAplicacion: contextoAplicacion,
                    tipoOferta: tipoOferta,
                    cantidad: cantidad,
                    tipoDescuento: tipoDescuento,
                    ofertaUID: ofertaUID,
                }


                await consultaActualizarCompartido(metadatos)


                for (const apartamentoDedicado of apartamentosSeleccionados) {
                    const apartamentoIDV = apartamentoDedicado.apartamentoIDV
                    let tipoDescuento = null
                    let cantidadPorApartamento = null
                    if (contextoAplicacion === "totalNetoApartmentoDedicado") {
                        tipoDescuento = apartamentoDedicado.tipoDescuento
                        cantidadPorApartamento = apartamentoDedicado.cantidad
                    }



                    const ofertaApartamentosDedicados = `
                        INSERT INTO "ofertasApartamentos"
                        (
                            oferta,
                            apartamento,
                            "tipoDescuento",
                            cantidad
                        )
                        VALUES
                        (
                            NULLIF($1::numeric, NULL),
                            COALESCE($2, NULL),
                            COALESCE($3, NULL),
                            NULLIF($4::numeric, NULL)
                        )
                        RETURNING uid;
                        `
                    let detallesApartamentoDedicado = [
                        Number(ofertaUID),
                        apartamentoIDV,
                        tipoDescuento,
                        Number(cantidadPorApartamento)
                    ]
                    await conexion.query(ofertaApartamentosDedicados, detallesApartamentoDedicado)
                }
                const ok = {
                    "ok": "La oferta actualizado bien junto con los apartamentos dedicados"
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarEstadoOferta") {
        try {
            const ofertaUID = entrada.body.ofertaUID
            const estadoOferta = entrada.body.estadoOferta
            const filtroCadena = /^[a-z]+$/;

            if (!ofertaUID || !Number.isInteger(ofertaUID) || ofertaUID <= 0) {
                const error = "El campo ofertaUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            if (!estadoOferta || !filtroCadena.test(estadoOferta) || (estadoOferta !== "activada" && estadoOferta !== "desactivada")) {
                const error = "El campo estadoOferta solo admite min√∫sculas y nada mas, debe de ser un estado activada o desactivada"
                throw new Error(error)
            }
            // Validar nombre unico oferta
            const validarOferta = `
            SELECT uid
            FROM ofertas
            WHERE uid = $1;
            `
            const resuelveValidarOferta = await conexion.query(validarOferta, [ofertaUID])
            if (resuelveValidarOferta.rowCount === 0) {
                const error = "No existe al oferta, revisa el UID introducie en el campo ofertaUID, recuerda que debe de ser un number"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarEstadoOferta = `
            UPDATE ofertas
            SET "estadoOferta" = $2
            WHERE uid = $1
            RETURNING "estadoOferta";
            `
            const datos = [
                ofertaUID,
                estadoOferta,
            ]
            const resuelveEstadoOferta = await conexion.query(actualizarEstadoOferta, datos)

            const ok = {
                "ok": "El estado de la oferta se ha actualziado correctamente",
                "estadoOferta": resuelveEstadoOferta.rows[0].estadoOferta
            }
            salida.json(ok)
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "eliminarOferta") {
        try {
            const ofertaUID = entrada.body.ofertaUID
            if (!ofertaUID || !Number.isInteger(ofertaUID) || ofertaUID <= 0) {
                const error = "El campo ofertaUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            // Validar nombre unico oferta
            const validarOferta = `
            SELECT uid
            FROM ofertas
            WHERE uid = $1;
            `
            let resuelveValidarOferta = await conexion.query(validarOferta, [ofertaUID])
            if (resuelveValidarOferta.rowCount === 0) {
                const error = "No existe al oferta, revisa el UID introducie en el campo ofertaUID, recuerda que debe de ser un number"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            let eliminarEstadoOferta = `
            DELETE FROM ofertas
            WHERE uid = $1;
            `
            let resuelveEliminarEstadoOferta = await conexion.query(eliminarEstadoOferta, [ofertaUID])
            const ok = {
                "ok": "Se ha eliminado la oferta correctamente",
            }
            salida.json(ok)
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "listaComportamientosPrecios") {
        try {
            const listaComportamientoPrecios = `
            SELECT
            "nombreComportamiento",
            uid,
            to_char("fechaInicio", 'DD/MM/YYYY') as "fechaInicio", 
            to_char("fechaFinal", 'DD/MM/YYYY') as "fechaFinal",
            explicacion
            FROM 
            "comportamientoPrecios"
            ORDER BY 
            "fechaInicio" ASC;
            `
            const resuelveListaComportamientoPrecios = await conexion.query(listaComportamientoPrecios)
            if (resuelveListaComportamientoPrecios.rowCount === 0) {
                const ok = {
                    "ok": "No hay comportamiento de precios configurados"
                }
                salida.json(ok)
            }
            if (resuelveListaComportamientoPrecios.rowCount > 0) {
                const ok = {
                    "ok": resuelveListaComportamientoPrecios.rows
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "crearComportamiento") {
        try {
            const nombreComportamiento = entrada.body.nombreComportamiento
            let fechaInicio = entrada.body.fechaInicio
            let fechaFin = entrada.body.fechaFin
            const comportamientos = entrada.body.comportamientos

            const filtroCantidad = /^\d+(\.\d{1,2})?$/;
            const filtroNombre = /^[a-zA-Z0-9\s]+$/;
            const filtroCadenaSinEspacui = /^[a-z0-9]+$/;
            if (!nombreComportamiento || !filtroNombre.test(nombreComportamiento)) {
                const error = "El campo nombreComportamiento solo admite min√∫sculas, may√∫sculas, numeros y espacios"
                throw new Error(error)
            }
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaInicio)) {
                const error = "el formato fecha de inicio no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaFin)) {
                const error = "el formato fecha de fin no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }

            const fechaInicioArreglo = fechaInicio.split("/")
            const diaEntrada = fechaInicioArreglo[0]
            const mesEntrada = fechaInicioArreglo[1]
            const anoEntrada = fechaInicioArreglo[2]



            const fechaFinArreglo = fechaFin.split("/")
            const diaSalida = fechaFinArreglo[0]
            const mesSalida = fechaFinArreglo[1]
            const anoSalida = fechaFinArreglo[2]

            const constructorFechaEntradaFormatoMDA = `${mesEntrada}/${diaEntrada}/${anoEntrada}`
            const constructorFechaSalidaFormatoMDA = `${mesSalida}/${diaSalida}/${anoSalida}`

            const controlFechaEntrada = new Date(constructorFechaEntradaFormatoMDA); // El formato es d√≠a/mes/ano
            const controlFechaSalida = new Date(constructorFechaSalidaFormatoMDA);


            // validacion: la fecha de entrada no puede ser superior a la fecha de salida y al mimso tiempo la fecha de salida no puede ser inferior a la fecha de entrada
            if (controlFechaEntrada >= controlFechaSalida) {
                const error = "La fecha de entrada no puede ser igual o superior que la fecha de salida"
                throw new Error(error)
            }


            if (typeof comportamientos !== 'object' && !Array.isArray(comportamientos)) {
                const error = "El campo comportamientos solo admite un arreglo"
                throw new Error(error)
            }

            if (comportamientos.length === 0) {
                const error = "Anada al menos un apartmento dedicado"
                throw new Error(error)
            }
            const apartamentosArreglo = []
            for (const comportamiento of comportamientos) {
                const apartamentoIDV = comportamiento.apartamentoIDV
                let cantidad = comportamiento.cantidad
                const simbolo = comportamiento.simbolo

                if (!apartamentoIDV || !filtroCadenaSinEspacui.test(apartamentoIDV)) {
                    const error = "El campo apartamentoIDV solo admite min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
                const consultaValidarApartamentoIDV = `
                SELECT *
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
                const resuelveConfiguraValidarApartamentoIDV = await conexion.query(consultaValidarApartamentoIDV, [apartamentoIDV])
                if (resuelveConfiguraValidarApartamentoIDV.rowCount === 0) {
                    const error = "No exista el apartmento" + String(apartamentoIDV)
                    throw new Error(error)
                }


                if (!simbolo ||
                    (
                        simbolo !== "aumentoPorcentaje" &&
                        simbolo !== "aumentoCantidad" &&
                        simbolo !== "reducirCantidad" &&
                        simbolo !== "reducirPorcentaje" &&
                        simbolo !== "precioEstablecido"
                    )) {
                    const error = "El campo simbolo solo admite aumentoPorcentaje,aumentoCantidad,reducirCantidad,reducirPorcentaje y precioEstablecido"
                    throw new Error(error)
                }

                if (!cantidad || !filtroCantidad.test(cantidad)) {
                    const error = "El campo cantidad solo admite min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }

                cantidad = Number(cantidad)
                if (cantidad === 0) {
                    const error = "No se puede asignar una cantidad de cero por logica y por seguridad"
                    throw new Error(error)
                }
                apartamentosArreglo.push(apartamentoIDV)
            }


            // Validar nombre unico oferta
            const validarNombreComportamiento = `
            SELECT "nombreComportamiento"
            FROM "comportamientoPrecios"
            WHERE "nombreComportamiento" = $1
            `
            const consultaValidarNombreComportamiento = await conexion.query(validarNombreComportamiento, [nombreComportamiento])
            if (consultaValidarNombreComportamiento.rowCount > 0) {
                const error = "Ya existe un nombre exactamente igual a este comportamiento de precio, por favor elige otro nombre con el fin de evitar confusiones"
                throw new Error(error)
            }


            const validarEspacioTemporalUnico = `
            SELECT uid 
            FROM "comportamientoPrecios" 
            WHERE "fechaInicio" <= $1::DATE AND "fechaFinal" >= $2::DATE;`


            const resuelveVevalidarEspacioTemporalUnico = await conexion.query(validarEspacioTemporalUnico, [fechaFin, fechaInicio])
            if (resuelveVevalidarEspacioTemporalUnico.rowCount > 0) {
                const detallesApartamentosEntontradosPorValidas = []
                const comportamientoPreciosCocheTemporalPorAnalizar = resuelveVevalidarEspacioTemporalUnico.rows

                for (const apartmentosEnComportamiento of comportamientoPreciosCocheTemporalPorAnalizar) {
                    const UIDComportamientoChoque = apartmentosEnComportamiento.uid

                    const seleccionarApartamentosPorComportamiento = `
                    SELECT
                    cpa."apartamentoIDV", 
                    cpa.uid,
                    a."apartamentoUI",
                    cp."nombreComportamiento"
                    FROM
                    "comportamientoPreciosApartamentos" cpa
                    JOIN 
                    apartamentos a ON cpa."apartamentoIDV" = a.apartamento
                    JOIN 
                    "comportamientoPrecios" cp ON cpa."comportamientoUID" = cp.uid
                    WHERE "comportamientoUID" = $1;`
                    const resuelveSeleccionarApartamentosPorComportamiento = await conexion.query(seleccionarApartamentosPorComportamiento, [UIDComportamientoChoque])


                    if (resuelveSeleccionarApartamentosPorComportamiento.rowCount > 0) {

                        // Aqui falta un loop
                        let apartamentoExistentes = resuelveSeleccionarApartamentosPorComportamiento.rows
                        apartamentoExistentes.map((apartamentoExistente) => {

                            let apartamentoIDVEntonctrado = apartamentoExistente.apartamentoIDV
                            let apartamentoUIEncontrado = apartamentoExistente.apartamentoUI
                            let nombreComportamiento = apartamentoExistente.nombreComportamiento

                            let apartamentoCoincidenteDetalles = {
                                "apartamentoIDV": apartamentoIDVEntonctrado,
                                "apartamentoUI": apartamentoUIEncontrado,
                                "nombreComportamiento": nombreComportamiento,
                            }
                            detallesApartamentosEntontradosPorValidas.push(apartamentoCoincidenteDetalles)



                        })


                    }
                }

                const coincidenciasExistentes = []


                for (const detalleApartemtno of comportamientos) {
                    const apartamentoIDVSolicitante = detalleApartemtno.apartamentoIDV


                    for (const detalleApartamentoYaExistente of detallesApartamentosEntontradosPorValidas) {
                        let apartamentoIDVExistente = detalleApartamentoYaExistente.apartamentoIDV
                        let nombreComportamiento = detalleApartamentoYaExistente.nombreComportamiento
                        let apartamentoUIExistente = detalleApartamentoYaExistente.apartamentoUI




                        if (apartamentoIDVSolicitante === apartamentoIDVExistente) {

                            let apartamentoImposibleDeGuardar = {
                                "apartamentoIDV": apartamentoIDVExistente,
                                "apartamentoUI": apartamentoUIExistente,
                                "nombreComportamiento": nombreComportamiento,
                            }
                            coincidenciasExistentes.push(apartamentoImposibleDeGuardar)
                        }
                    }
                }



                const coincidenciaAgrupdasPorNombreComportamiento = {}

                coincidenciasExistentes.map((coincidencia) => {
                    let apartamentoUI = coincidencia.apartamentoUI
                    let nombreComportamiento = coincidencia.nombreComportamiento

                    if (coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento]) {
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento].push(apartamentoUI)
                    } else {
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento] = []
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento].push(apartamentoUI)
                    }

                })


                const infoFinal = []
                for (const coincidenciaAgrupada of Object.entries(coincidenciaAgrupdasPorNombreComportamiento)) {
                    const nombreComportamiento = coincidenciaAgrupada[0]
                    let apartamentosCoincidentes = coincidenciaAgrupada[1]
                    apartamentosCoincidentes = apartamentosCoincidentes.join(", ")
                    infoFinal.push(`${nombreComportamiento} (${apartamentosCoincidentes})`)


                }
                infoFinal.join(", ")
                if (coincidenciasExistentes.length > 0) {

                    const error = `No se puede crear este comportamiento de precio por que hay apartamentos en este comportamiento que existen en otros comportamientos cuyos rangos de fechas se pisan. Concretamente en: ${infoFinal}`
                    throw new Error(error)
                }


            }








            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const estadoInicalDesactivado = "desactivado"

            const crearComportamiento = `
            INSERT INTO "comportamientoPrecios"
            (
                "nombreComportamiento",
                "fechaInicio",
                "fechaFinal",
                 estado
            )
            VALUES
            (
                COALESCE($1, NULL),
                COALESCE($2::date, NULL),
                COALESCE($3::date, NULL),
                COALESCE($4, NULL)
            )
            RETURNING uid;
            `
            const datos = [
                nombreComportamiento,
                fechaInicio,
                fechaFin,
                estadoInicalDesactivado
            ]
            const resuelveCrearComportamiento = await conexion.query(crearComportamiento, datos)


            if (resuelveCrearComportamiento.rowCount === 1) {
                const nuevoUIDComportamiento = resuelveCrearComportamiento.rows[0].uid

                for (const comportamiento of comportamientos) {
                    const apartamentoIDV = comportamiento.apartamentoIDV
                    let cantidad = comportamiento.cantidad
                    const simbolo = comportamiento.simbolo


                    const insertarComportamiento = `
                    INSERT INTO "comportamientoPreciosApartamentos"
                    (
                        "comportamientoUID",
                        "apartamentoIDV",
                         cantidad,
                         simbolo
                    )
                    VALUES
                    (
                        NULLIF($1::numeric, NULL),
                        NULLIF($2, NULL),
                        NULLIF($3::numeric, NULL),
                        NULLIF($4, NULL)
                    )
                    `
                    let detalleComportamiento = [
                        nuevoUIDComportamiento,
                        apartamentoIDV,
                        cantidad,
                        simbolo
                    ]
                    let resuelveInsertarComportamiento = await conexion.query(insertarComportamiento, detalleComportamiento)
                    if (resuelveInsertarComportamiento.rowCount === 0) {
                        const error = `Ha ocurrido un error y no se ha podido insertar el apartamento ${apartamentoIDV} en el comportamiento`
                        throw new Error(error)
                    }

                }
                const ok = {
                    "ok": "Se ha creado correctamente el comportamiento",
                    "nuevoUIDComportamiento": nuevoUIDComportamiento
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "detallesComportamiento") {

        try {
            const comportamientoUID = entrada.body.comportamientoUID
            if (!comportamientoUID || typeof comportamientoUID !== "number" || !Number.isInteger(comportamientoUID) || comportamientoUID <= 0) {
                const error = "El campo 'comportamientoUID' debe ser un tipo numero, entero y positivo"
                throw new Error(error)
            }
            const consultaDetallesComportamiento = `
            SELECT
            uid,
            to_char("fechaInicio", 'DD/MM/YYYY') as "fechaInicio", 
            to_char("fechaFinal", 'DD/MM/YYYY') as "fechaFinal", 
            "nombreComportamiento",
            "estado"
            FROM
            "comportamientoPrecios" 
            WHERE
            uid = $1;
            `
            const resuelveConsultaDetallesComportamiento = await conexion.query(consultaDetallesComportamiento, [comportamientoUID])
            const detallesComportamiento = {
                "uid": resuelveConsultaDetallesComportamiento.rows[0].uid,
                "fechaInicio": resuelveConsultaDetallesComportamiento.rows[0].fechaInicio,
                "fechaFinal": resuelveConsultaDetallesComportamiento.rows[0].fechaFinal,
                "nombreComportamiento": resuelveConsultaDetallesComportamiento.rows[0].nombreComportamiento,
                "estado": resuelveConsultaDetallesComportamiento.rows[0].estado
            }
            comportamientoUID = resuelveConsultaDetallesComportamiento.rows[0].uid
            if (resuelveConsultaDetallesComportamiento.rowCount === 0) {
                const error = "No existe ninguna comportamiento de precio con ese UID"
                throw new Error(error)
            }

            if (resuelveConsultaDetallesComportamiento.rowCount === 1) {
                detallesComportamiento["apartamentos"] = []
                const detallesApartamentosDedicados = `
                    SELECT
                    cpa.uid,
                    cpa."apartamentoIDV",
                    cpa."cantidad",
                    cpa."comportamientoUID",
                    a."apartamentoUI",
                    cpa."simbolo"
                    FROM 
                    "comportamientoPreciosApartamentos" cpa
                    JOIN
                    apartamentos a ON cpa."apartamentoIDV" = a.apartamento
                    WHERE "comportamientoUID" = $1;
                    `
                const resuelveDetallesApartamentosDedicados = await conexion.query(detallesApartamentosDedicados, [comportamientoUID])
                if (resuelveDetallesApartamentosDedicados.rowCount > 0) {
                    const apartamentosDedicados = resuelveDetallesApartamentosDedicados.rows
                    apartamentosDedicados.map((apartamento) => {
                        const cantidad = apartamento.cantidad
                        const apartamentoIDV = apartamento.apartamentoIDV
                        const comportamientoUID = apartamento.comportamientoUID
                        const simbolo = apartamento.simbolo
                        const apartamentoUI = apartamento.apartamentoUI
                        const detallesApartamentoDedicado = {
                            "apartamentoIDV": apartamentoIDV,
                            "apartamentoUI": apartamentoUI,
                            "cantidad": cantidad,
                            "comportamientoUID": comportamientoUID,
                            "simbolo": simbolo
                        }
                        detallesComportamiento["apartamentos"].push(detallesApartamentoDedicado)
                    })
                }
                const ok = {
                    "ok": detallesComportamiento
                }
                salida.json(ok)

            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "actualizarComportamiento") {
        try {
            const nombreComportamiento = entrada.body.nombreComportamiento
            let fechaInicio = entrada.body.fechaInicio
            let fechaFinal = entrada.body.fechaFinal
            const comportamientoUID = entrada.body.comportamientoUID
            let comportamientos = entrada.body.comportamientos
            const filtroCantidad = /^\d+\.\d{2}$/;
            const filtroNombre = /^[a-zA-Z0-9\s]+$/;
            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;

            if (!comportamientoUID || !Number.isInteger(comportamientoUID) || comportamientoUID <= 0) {
                const error = "El campo comportamientoUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            if (!nombreComportamiento || !filtroNombre.test(nombreComportamiento)) {
                const error = "El campo nombreComportamiento solo admite min√∫sculas, may√∫sculas, numeros y espacios"
                throw new Error(error)
            }
            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaInicio)) {
                const error = "el formato fecha de inicio no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaFinal)) {
                const error = "el formato fecha de fin no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }

            if (typeof comportamientos !== 'object' && !Array.isArray(comportamientos)) {
                const error = "El campo comportamientos solo admite un arreglo"
                throw new Error(error)
            }

            if (comportamientos.length === 0) {
                const error = "Anada al menos un apartmento dedicado"
                throw new Error(error)
            }


            const fechaInicioArreglo = fechaInicio.split("/")
            const diaEntrada = fechaInicioArreglo[0]
            const mesEntrada = fechaInicioArreglo[1]
            const anoEntrada = fechaInicioArreglo[2]


            const fechaFinArreglo = fechaFinal.split("/")
            const diaSalida = fechaFinArreglo[0]
            const mesSalida = fechaFinArreglo[1]
            const anoSalida = fechaFinArreglo[2]

            const constructorFechaEntradaFormatoMDA = `${mesEntrada}/${diaEntrada}/${anoEntrada}`
            const constructorFechaSalidaFormatoMDA = `${mesSalida}/${diaSalida}/${anoSalida}`

            const controlFechaEntrada = new Date(constructorFechaEntradaFormatoMDA); // El formato es d√≠a/mes/ano
            const controlFechaSalida = new Date(constructorFechaSalidaFormatoMDA);


            // validacion: la fecha de entrada no puede ser superior a la fecha de salida y al mimso tiempo la fecha de salida no puede ser inferior a la fecha de entrada
            if (controlFechaEntrada >= controlFechaSalida) {
                const error = "La fecha de entrada no puede ser igual o superior que la fecha de salida"
                throw new Error(error)
            }

            if (typeof comportamientos !== 'object' && !Array.isArray(comportamientos)) {
                const error = "El campo comportamientos solo admite un arreglo"
                throw new Error(error)
            }

            if (comportamientos.length === 0) {
                const error = "Anada al menos un apartmento dedicado"
                throw new Error(error)
            }
            const apartamentosArreglo = []
            for (const comportamiento of comportamientos) {
                const apartamentoIDV = comportamiento.apartamentoIDV
                let cantidad = comportamiento.cantidad
                const simbolo = comportamiento.simbolo

                if (!apartamentoIDV || !filtroCadenaSinEspacio.test(apartamentoIDV)) {
                    const error = "El campo apartamentoIDV solo admite min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
                if (!simbolo ||
                    (
                        simbolo !== "aumentoPorcentaje" &&
                        simbolo !== "aumentoCantidad" &&
                        simbolo !== "reducirCantidad" &&
                        simbolo !== "reducirPorcentaje" &&
                        simbolo !== "precioEstablecido"
                    )) {
                    const error = "El campo simbolo solo admite aumentoPorcentaje,aumentoCantidad,reducirCantidad,reducirPorcentaje y precioEstablecido"
                    throw new Error(error)
                }

                if (!cantidad || !filtroCantidad.test(cantidad)) {
                    const error = "El campo cantidad solo admite min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }

                cantidad = Number(cantidad)
                if (cantidad === 0) {
                    const error = "No se puede asignar una cantidad de cero por logica y por seguridad"
                    throw new Error(error)
                }
                apartamentosArreglo.push(apartamentoIDV)
            }

            // Validar nombre unico oferta
            const validarNombreComportamiento = `
            SELECT "nombreComportamiento"
            FROM "comportamientoPrecios"
            WHERE "nombreComportamiento" = $1 AND uid <> $2
            `
            const consultaValidarNombreComportamiento = await conexion.query(validarNombreComportamiento, [nombreComportamiento, comportamientoUID])
            if (consultaValidarNombreComportamiento.rowCount > 0) {
                const error = "Ya existe un nombre de comportamiento exactamente igual a este, por favor elige otro con el fin de evitar confusiones"
                throw new Error(error)
            }

            const validarEspacioTemporalUnico = `
            SELECT uid 
            FROM "comportamientoPrecios" 
            WHERE "fechaInicio" <= $1::DATE AND "fechaFinal" >= $2::DATE AND uid <> $3;`

            const resuelveVevalidarEspacioTemporalUnico = await conexion.query(validarEspacioTemporalUnico, [fechaFinal, fechaInicio, comportamientoUID])
            if (resuelveVevalidarEspacioTemporalUnico.rowCount > 0) {
                const detallesApartamentosEntontradosPorValidas = []
                const comportamientoPreciosCocheTemporalPorAnalizar = resuelveVevalidarEspacioTemporalUnico.rows

                for (const apartmentosEnComportamiento of comportamientoPreciosCocheTemporalPorAnalizar) {
                    const UIDComportamientoChoque = apartmentosEnComportamiento.uid

                    const seleccionarApartamentosPorComportamiento = `
                    SELECT
                    cpa."apartamentoIDV", 
                    cpa.uid,
                    a."apartamentoUI",
                    cp."nombreComportamiento"
                    FROM
                    "comportamientoPreciosApartamentos" cpa
                    JOIN 
                    apartamentos a ON cpa."apartamentoIDV" = a.apartamento
                    JOIN 
                    "comportamientoPrecios" cp ON cpa."comportamientoUID" = cp.uid
                    WHERE "comportamientoUID" = $1;`
                    const resuelveSeleccionarApartamentosPorComportamiento = await conexion.query(seleccionarApartamentosPorComportamiento, [UIDComportamientoChoque])
                    if (resuelveSeleccionarApartamentosPorComportamiento.rowCount > 0) {

                        // Aqui falta un loop
                        let apartamentoExistentes = resuelveSeleccionarApartamentosPorComportamiento.rows
                        apartamentoExistentes.map((apartamentoExistente) => {

                            let apartamentoIDVEntonctrado = apartamentoExistente.apartamentoIDV
                            let apartamentoUIEncontrado = apartamentoExistente.apartamentoUI
                            let nombreComportamiento = apartamentoExistente.nombreComportamiento

                            let apartamentoCoincidenteDetalles = {
                                "apartamentoIDV": apartamentoIDVEntonctrado,
                                "apartamentoUI": apartamentoUIEncontrado,
                                "nombreComportamiento": nombreComportamiento,
                            }
                            detallesApartamentosEntontradosPorValidas.push(apartamentoCoincidenteDetalles)

                        })
                    }
                }

                const coincidenciasExistentes = []


                for (const detalleApartemtno of comportamientos) {
                    const apartamentoIDVSolicitante = detalleApartemtno.apartamentoIDV

                    for (const detalleApartamentoYaExistente of detallesApartamentosEntontradosPorValidas) {
                        const apartamentoIDVExistente = detalleApartamentoYaExistente.apartamentoIDV
                        const nombreComportamiento = detalleApartamentoYaExistente.nombreComportamiento
                        const apartamentoUIExistente = detalleApartamentoYaExistente.apartamentoUI




                        if (apartamentoIDVSolicitante === apartamentoIDVExistente) {

                            const apartamentoImposibleDeGuardar = {
                                "apartamentoIDV": apartamentoIDVExistente,
                                "apartamentoUI": apartamentoUIExistente,
                                "nombreComportamiento": nombreComportamiento,
                            }
                            coincidenciasExistentes.push(apartamentoImposibleDeGuardar)
                        }
                    }
                }



                const coincidenciaAgrupdasPorNombreComportamiento = {}

                coincidenciasExistentes.map((coincidencia) => {
                    const apartamentoUI = coincidencia.apartamentoUI
                    const nombreComportamiento = coincidencia.nombreComportamiento

                    if (coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento]) {
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento].push(apartamentoUI)
                    } else {
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento] = []
                        coincidenciaAgrupdasPorNombreComportamiento[nombreComportamiento].push(apartamentoUI)
                    }

                })


                const infoFinal = []
                for (const coincidenciaAgrupada of Object.entries(coincidenciaAgrupdasPorNombreComportamiento)) {
                    const nombreComportamiento = coincidenciaAgrupada[0]
                    const apartamentosCoincidentes = coincidenciaAgrupada[1]
                    apartamentosCoincidentes = apartamentosCoincidentes.join(", ")
                    infoFinal.push(`${nombreComportamiento} (${apartamentosCoincidentes})`)


                }
                infoFinal.join(", ")
                if (coincidenciasExistentes.length > 0) {

                    const error = `No se puede crear este comportamiento de precio por que hay apartamentos en este comportamiento que existen en otros comportamientos cuyos rangos de fechas se pisan. Concretamente en: ${infoFinal}`
                    throw new Error(error)
                }
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarComportamiento = `
            UPDATE "comportamientoPrecios"
            SET "nombreComportamiento" = $1, "fechaInicio" = $2 ,"fechaFinal" = $3
            WHERE uid = $4;

            `
            const datos = [
                nombreComportamiento,
                fechaInicio,
                fechaFinal,
                comportamientoUID
            ]
            const resuelveActualizarComportamiento = await conexion.query(actualizarComportamiento, datos)
            if (resuelveActualizarComportamiento.rowCount === 1) {

                const eliminarComportamiento = `
                DELETE FROM "comportamientoPreciosApartamentos"
                WHERE "comportamientoUID" = $1 ;
                `
                await conexion.query(eliminarComportamiento, [comportamientoUID])
                const filtroCadenaSinEspacui = /^[a-z0-9]+$/;

                for (const comportamiento of comportamientos) {

                    const apartamentoIDV = comportamiento.apartamentoIDV
                    const simbolo = comportamiento.simbolo
                    let cantidadPorApartamento = comportamiento.cantidad

                    if (!apartamentoIDV || !filtroCadenaSinEspacui.test(apartamentoIDV)) {
                        const error = "El campo apartamentoIDV solo admite min√∫sculas, numeros y espacios"
                        throw new Error(error)
                    }
                    if (!simbolo ||
                        (
                            simbolo !== "aumentoPorcentaje" &&
                            simbolo !== "aumentoCantidad" &&
                            simbolo !== "reducirCantidad" &&
                            simbolo !== "reducirPorcentaje" &&
                            simbolo !== "precioEstablecido"
                        )) {
                        const error = "El campo simbolo solo admite aumentoPorcentaje,aumentoCantidad,reducirCantidad,reducirPorcentaje y precioEstablecido"
                        throw new Error(error)
                    }

                    if (!cantidadPorApartamento || !filtroCantidad.test(cantidadPorApartamento)) {
                        const error = "El campo cantidad solo admite una cadena con un numero con dos decimales separados por punto. Asegurate de escribir los decimales"
                        throw new Error(error)
                    }

                    cantidadPorApartamento = Number(cantidadPorApartamento)
                    if (cantidadPorApartamento === 0) {
                        const error = "No se puede asignar una cantidad de cero por seguridad"
                        throw new Error(error)
                    }

                    let actualizarComportamientoDedicado = `
                        INSERT INTO "comportamientoPreciosApartamentos"
                        (
                            "apartamentoIDV",
                            simbolo,
                            cantidad,
                            "comportamientoUID"
                        )
                        VALUES
                        (
                            NULLIF($1, NULL),
                            COALESCE($2, NULL),
                            COALESCE($3::numeric, NULL),
                            NULLIF($4::numeric, NULL)
                        );
                        `
                    let comportamientoDedicado = [
                        apartamentoIDV,
                        simbolo,
                        cantidadPorApartamento,
                        comportamientoUID

                    ]

                    await conexion.query(actualizarComportamientoDedicado, comportamientoDedicado)


                }
                const ok = {
                    "ok": "El comportamiento se ha actualizado bien junto con los apartamentos dedicados"
                }
                salida.json(ok)



            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "eliminarComportamiento") {
        try {
            const comportamientoUID = entrada.body.comportamientoUID
            if (!comportamientoUID || !Number.isInteger(comportamientoUID) || comportamientoUID <= 0) {
                const error = "El campo ofertaUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            // Validar nombre unico oferta
            const validarComportamiento = `
            SELECT uid
            FROM "comportamientoPrecios"
            WHERE uid = $1;
            `
            let resuelveValidarComportamiento = await conexion.query(validarComportamiento, [comportamientoUID])
            if (resuelveValidarComportamiento.rowCount === 0) {
                const error = "No existe el comportamiento, revisa el UID introducie en el campo comportamientoUID, recuerda que debe de ser un numero"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            let eliminarComportamiento = `
            DELETE FROM "comportamientoPrecios"
            WHERE uid = $1;
            `
            let resuelveEliminarComportamiento = await conexion.query(eliminarComportamiento, [comportamientoUID])
            if (resuelveEliminarComportamiento.rowCount === 1) {
                const ok = {
                    "ok": "Se ha eliminado el comportamiento correctamente",
                }
                salida.json(ok)
            }

            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarEstadoComportamiento") {
        try {
            const comportamientoUID = entrada.body.comportamientoUID
            const estadoPropuesto = entrada.body.estadoPropuesto
            const filtroCadena = /^[a-z]+$/;

            if (!comportamientoUID || !Number.isInteger(comportamientoUID) || comportamientoUID <= 0) {
                const error = "El campo comportamientoUID tiene que ser un numero, positivo y entero"
                throw new Error(error)
            }
            if (!estadoPropuesto || !filtroCadena.test(estadoPropuesto) || (estadoPropuesto !== "activado" && estadoPropuesto !== "desactivado")) {
                const error = "El campo estadoPropuesto solo admite min√∫sculas y nada mas, debe de ser un estado activado o desactivado"
                throw new Error(error)
            }
            // Validar nombre unico oferta
            const validarOferta = `
            SELECT uid
            FROM "comportamientoPrecios"
            WHERE uid = $1;
            `
            let resuelveValidarOferta = await conexion.query(validarOferta, [comportamientoUID])
            if (resuelveValidarOferta.rowCount === 0) {
                const error = "No existe al oferta, revisa el UID introducie en el campo comportamientoUID, recuerda que debe de ser un number"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            let actualizarEstadoOferta = `
            UPDATE "comportamientoPrecios"
            SET estado = $1
            WHERE uid = $2
            RETURNING estado;
            `
            let datos = [
                estadoPropuesto,
                comportamientoUID
            ]
            let resuelveEstadoOferta = await conexion.query(actualizarEstadoOferta, datos)

            const ok = {
                "ok": "El estado del comportamiento se ha actualziado correctamente",
                "estadoComportamiento": resuelveEstadoOferta.rows[0].estado
            }
            salida.json(ok)
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "precioRangoApartamentos") {
        try {
            let fechaEntrada = entrada.body.fechaEntrada
            let fechaSalida = entrada.body.fechaSalida
            const apartamentosIDVArreglo = entrada.body.apartamentosIDVArreglo

            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;

            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            if (!filtroFecha.test(fechaEntrada)) {
                const error = "el formato fecha de inicio no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }
            if (!filtroFecha.test(fechaSalida)) {
                const error = "el formato fecha de fin no esta correctametne formateado debe ser una cadena asi 00/00/0000"
                throw new Error(error)
            }

            if (typeof apartamentosIDVArreglo !== 'object' && !Array.isArray(apartamentosIDVArreglo)) {
                const error = "El campo apartamentosIDVArreglo solo admite un arreglo"
                throw new Error(error)
            }

            if (apartamentosIDVArreglo.length === 0) {
                const error = "Anada al menos un apartmentoIDV en el arreglo"
                throw new Error(error)
            }

            for (const apartamentoIDV of apartamentosIDVArreglo) {
                if (!filtroCadenaSinEspacio.test(apartamentoIDV)) {
                    const error = "El identificador visual del apartmento, el apartmentoIDV solo puede estar hecho de minuscuals y numeros y nada mas, ni espacios"
                    throw new Error(error)
                }

            }

            const metadatos = {
                "fechaEntrada": fechaEntrada,
                "fechaSalida": fechaSalida,
                "apartamentosIDVArreglo": apartamentosIDVArreglo
            }

            const preciosApartamentosResuelos = await precioRangoApartamento(metadatos)

            const ok = {
                "ok": preciosApartamentosResuelos
            }
            salida.json(ok)





        } catch (errorCapturado) {
            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        }

    }
    if (transaccion === "listarApartamentosConBloqueos") {
        try {
            const consultaApartamentosConBloqueo = `
            SELECT
            uid,
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida, 
            apartamento,
            "tipoBloqueo"
            FROM "bloqueosApartamentos";`
            const resuelveApartamentosBloqueados = await conexion.query(consultaApartamentosConBloqueo)
            const ok = {}
            if (resuelveApartamentosBloqueados.rowCount === 0) {
                ok.ok = "No hay ningun bloqueo"
            }
            if (resuelveApartamentosBloqueados.rowCount > 0) {
                const bloqueosEncontrados = resuelveApartamentosBloqueados.rows
                const apartamentosEncontradosConDuplicados = []
                bloqueosEncontrados.map((detalleBloqueo) => {
                    const apartamento = detalleBloqueo.apartamento
                    apartamentosEncontradosConDuplicados.push(apartamento)

                })
                const apartamentosEncontrados = [...new Set(apartamentosEncontradosConDuplicados)];
                const estructuraSalidaFinal = []
                for (const apartamento of apartamentosEncontrados) {

                    const apartamentoUI = await resolverApartamentoUI(apartamento)


                    const conteoDeBloqueosPorApartamento = `
                    SELECT
                    apartamento
                    FROM "bloqueosApartamentos"
                    WHERE apartamento = $1;`
                    const resuelveConteoDeBloqueosPorApartamento = await conexion.query(conteoDeBloqueosPorApartamento, [apartamento])
                    const numeroDeBloqueosPorApartamento = resuelveConteoDeBloqueosPorApartamento.rowCount
                    const estructuraFinal = {
                        "apartamentoIDV": apartamento,
                        "apartamentoUI": apartamentoUI,
                        "numeroDeBloqueos": numeroDeBloqueosPorApartamento,
                    }
                    estructuraSalidaFinal.push(estructuraFinal)
                }

                ok.ok = estructuraSalidaFinal
            }



            salida.json(ok)


        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        }

    }
    if (transaccion === "listaBloquoeosDelApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(apartamentoIDV) || typeof apartamentoIDV !== "string") {
                const error = "el campo 'apartmentoIDV' solo puede ser una cadena de letras min√∫sculas y numeros sin espacios."
                throw new Error(error)
            }

            const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)

            const consultaDetallesBloqueoApartamento = `
            SELECT
            uid,
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida, 
            apartamento,
            "tipoBloqueo",
            motivo,
            zona
            FROM "bloqueosApartamentos"
            WHERE apartamento = $1;`
            const resuelveBloqueosPorApartmento = await conexion.query(consultaDetallesBloqueoApartamento, [apartamentoIDV])
            const ok = {}

            if (resuelveBloqueosPorApartmento.rowCount === 0) {
                ok.ok = "No hay ningun bloqueo para el apartamento " + apartamentoUI
            }


            if (resuelveBloqueosPorApartmento.rowCount > 0) {
                const bloqueosEncontradosDelApartamento = resuelveBloqueosPorApartmento.rows
                const bloqueosDelApartamentoEntonctrado = []
                bloqueosEncontradosDelApartamento.map((bloqueoDelApartamento) => {
                    const uidBloqueo = bloqueoDelApartamento.uid
                    const tipoBloqueo = bloqueoDelApartamento.tipoBloqueo
                    const entrada = bloqueoDelApartamento.entrada
                    const salida = bloqueoDelApartamento.salida
                    const motivo = bloqueoDelApartamento.motivo
                    const zona = bloqueoDelApartamento.zona

                    const estructuraBloqueo = {

                        uidBloqueo: uidBloqueo,
                        tipoBloqueo: tipoBloqueo,
                        entrada: entrada,
                        salida: salida,
                        motivo: motivo,
                        zona: zona
                    }


                    bloqueosDelApartamentoEntonctrado.push(estructuraBloqueo)

                })
                ok.apartamentoIDV = apartamentoIDV
                ok.apartamentoUI = apartamentoUI
                ok.ok = bloqueosDelApartamentoEntonctrado
            }



            salida.json(ok)


        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        }

    }
    if (transaccion === "detallesDelBloqueo") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const bloqueoUID = entrada.body.bloqueoUID
            const filtroCadena = /^[a-z0-9]+$/;
            if (!filtroCadena.test(apartamentoIDV) || typeof apartamentoIDV !== "string") {
                const error = "el campo 'apartmentoIDV' solo puede ser una cadena de letras min√∫sculas y numeros sin espacios."
                throw new Error(error)
            }

            if (typeof bloqueoUID !== "number" || !Number.isInteger(bloqueoUID) && bloqueoUID <= 0) {
                const error = "la clave 'bloqueoUID' debe de tener un dato tipo 'number', positivo y entero"
                throw new Error(error)
            }


            const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)

            const consultaDetallesBloqueo = `
            SELECT
            uid,
            to_char(entrada, 'DD/MM/YYYY') as entrada, 
            to_char(salida, 'DD/MM/YYYY') as salida, 
            apartamento,
            "tipoBloqueo",
            motivo,
            zona
            FROM "bloqueosApartamentos"
            WHERE apartamento = $1 AND uid = $2;`
            const resuelveConsultaDetallesBloqueo = await conexion.query(consultaDetallesBloqueo, [apartamentoIDV, bloqueoUID])

            if (resuelveConsultaDetallesBloqueo.rowCount === 0) {
                const error = "No existe el bloqueo, comprueba el apartamentoIDV y el bloqueoUID"
                throw new Error(error)
            }

            if (resuelveConsultaDetallesBloqueo.rowCount === 1) {
                const bloqueosEncontradosDelApartamento = resuelveConsultaDetallesBloqueo.rows[0]

                const uidBloqueo = bloqueosEncontradosDelApartamento.uid
                const tipoBloqueo = bloqueosEncontradosDelApartamento.tipoBloqueo
                const entrada = bloqueosEncontradosDelApartamento.entrada
                const salida_ = bloqueosEncontradosDelApartamento.salida
                const motivo = bloqueosEncontradosDelApartamento.motivo
                const zona = bloqueosEncontradosDelApartamento.zona

                const estructuraBloqueo = {
                    uidBloqueo: uidBloqueo,
                    tipoBloqueo: tipoBloqueo,
                    entrada: entrada,
                    salida: salida_,
                    motivo: motivo,
                    zona: zona
                }
                const ok = {}
                ok.apartamentoIDV = apartamentoIDV
                ok.apartamentoUI = apartamentoUI
                ok.ok = estructuraBloqueo
                salida.json(ok)

            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)

        }

    }
    if (transaccion === "eliminarBloqueo") {
        try {
            const bloqueoUID = entrada.body.bloqueoUID
            if (typeof bloqueoUID !== "number" || !Number.isInteger(bloqueoUID) && bloqueoUID <= 0) {
                const error = "la clave 'bloqueoUID' debe de tener un dato tipo 'number', positivo y entero"
                throw new Error(error)
            }

            const seleccionarBloqueo = await conexion.query(`SELECT uid, apartamento FROM "bloqueosApartamentos" WHERE uid = $1`, [bloqueoUID])
            if (seleccionarBloqueo.rowCount === 0) {
                const error = "No existe el bloqueo que se desea eliminar"
                throw new Error(error)
            }
            const apartmamentoIDV = seleccionarBloqueo.rows[0].apartamento
            const ContarBloqueosPorApartamento = await conexion.query(`SELECT apartamento FROM "bloqueosApartamentos" WHERE apartamento = $1`, [apartmamentoIDV])
            let tipoDeRetroceso

            if (ContarBloqueosPorApartamento.rowCount === 1) {
                tipoDeRetroceso = "aPortada"
            }
            if (ContarBloqueosPorApartamento.rowCount > 1) {
                tipoDeRetroceso = "aApartamento"
            }
            const eliminarBloqueo = `
            DELETE FROM "bloqueosApartamentos"
            WHERE uid = $1;
            `
            const resuelveEliminarBloqueo = await conexion.query(eliminarBloqueo, [bloqueoUID])
            if (resuelveEliminarBloqueo.rowCount === 0) {
                const error = "No se ha eliminado el bloqueo"
                throw new Error(error)
            }
            if (resuelveEliminarBloqueo.rowCount === 1) {
                const ok = {
                    "ok": "Se ha eliminado el bloqueo correctamente",
                    "tipoRetroceso": tipoDeRetroceso
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "modificarBloqueo") {
        try {
            const bloqueoUID = entrada.body.bloqueoUID
            const tipoBloqueo = entrada.body.tipoBloqueo

            let motivo = entrada.body.motivo
            let zona = entrada.body.zona

            if (typeof bloqueoUID !== "number" || !Number.isInteger(bloqueoUID) && bloqueoUID <= 0) {
                const error = "la clave 'bloqueoUID' debe de tener un dato tipo 'number', positivo y entero"
                throw new Error(error)
            }

            if (tipoBloqueo !== "permanente" && tipoBloqueo !== "rangoTemporal") {
                const error = "tipoBloqueo solo puede ser permanente o rangoTemporal"
                throw new Error(error)
            }
            if (zona !== "global" && zona !== "publico" && zona !== "privado") {
                const error = "zona solo puede ser global, publico o privado"
                throw new Error(error)
            }

            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            const filtroTextoSimple = /^[a-zA-Z0-9\s]+$/;

            const validadores = {
                fechaInicio: (fecha) => {
                    if (!filtroFecha.test(fecha)) {
                        const error = "el formato fechaInicio de bloqueo no esta correctamente formateado"
                        throw new Error(error)
                    }
                },
                fechaFin: (fecha) => {
                    if (!filtroFecha.test(fecha)) {
                        const error = "el formato fechaFin de bloqueo no esta correctamente formateado"
                        throw new Error(error)
                    }

                },
                validarFechaInicioSuperiorFechaFinal: (fechaInicio, fechaFin) => {
                    const fechaInicioArray = fechaInicio.split("/")
                    const fechaFinArray = fechaFin.split("/")

                    const constructorFechaEntradaFormatoMDA = `${fechaInicioArray[1]}/${fechaInicioArray[0]}/${fechaInicioArray[2]}`
                    const constructorFechaSalidaFormatoMDA = `${fechaFinArray[1]}/${fechaFinArray[0]}/${fechaFinArray[2]}`

                    const controlFechaEntrada = new Date(constructorFechaEntradaFormatoMDA);
                    const controlFechaSalida = new Date(constructorFechaSalidaFormatoMDA);

                    if (controlFechaEntrada > controlFechaSalida) {
                        const error = "La fecha de inicio del bloqueo no puede ser inferior a la fecha de fin del bloqueo, si puede ser igual para determinar un solo dia"
                        throw new Error(error)
                    }
                }
            }

            let fechaInicio = null
            let fechaFin = null
            if (tipoBloqueo === "rangoTemporal") {
                fechaInicio = entrada.body.fechaInicio
                fechaFin = entrada.body.fechaFin
                let controlFechaInicio
                let controlFechaFin

                if (fechaInicio === null) {
                    const validarFechaInicioExistente = await conexion.query(`SELECT to_char(entrada, 'DD/MM/YYYY') as entrada FROM "bloqueosApartamentos" WHERE uid = $1`, [bloqueoUID])
                    const fechaInicioExistente = validarFechaInicioExistente.rows[0].entrada
                    controlFechaInicio = fechaInicioExistente
                    if (!fechaInicioExistente) {
                        validadores.fechaInicio(fechaInicio)
                        controlFechaInicio = fechaInicio

                    }
                } else {
                    validadores.fechaInicio(fechaInicio)
                    controlFechaInicio = fechaInicio

                }

                if (fechaFin === null) {
                    const validarFechaFinExistente = await conexion.query(`SELECT to_char(salida, 'DD/MM/YYYY') as salida FROM "bloqueosApartamentos" WHERE uid = $1`, [bloqueoUID])
                    const fechaFinExistente = validarFechaFinExistente.rows[0].salida
                    controlFechaFin = fechaFinExistente
                    if (!fechaFinExistente) {
                        validadores.fechaFin(fechaFin)
                        controlFechaFin = fechaFin

                    }
                } else {
                    validadores.fechaFin(fechaFin)
                    controlFechaFin = fechaFin
                }
                validadores.validarFechaInicioSuperiorFechaFinal(controlFechaInicio, controlFechaFin)
            }
            if (motivo) {
                if (!filtroTextoSimple.test(motivo)) {
                    const error = "Por temas de seguridad ahora mismo en el campo motivo, solo pueden aceptarse min√∫sculas, may√∫sculas, espacio y numeros. Mas adelante se aceptaran todos los caracteres"
                    throw new Error(error)
                }

            } else {
                motivo = null
            }
            const seleccionarBloqueo = await conexion.query(`SELECT uid FROM "bloqueosApartamentos" WHERE uid = $1`, [bloqueoUID])
            if (seleccionarBloqueo.rowCount === 0) {
                const error = "No existe el bloqueo, revisa el bloqueoUID"
                throw new Error(error)
            }

            const modificarBloqueo = `
            UPDATE "bloqueosApartamentos"
            SET 
            "tipoBloqueo" = COALESCE($1, "tipoBloqueo"),
            entrada = COALESCE($2, entrada),
            salida = COALESCE($3, salida),
            motivo = COALESCE($4, motivo),
            zona = COALESCE($5, zona)
            WHERE uid = $6;
            `

            const datosParaActualizar = [
                tipoBloqueo,
                fechaInicio,
                fechaFin,
                motivo,
                zona,
                bloqueoUID
            ]
            const resuelveModificarBloqueo = await conexion.query(modificarBloqueo, datosParaActualizar)
            if (resuelveModificarBloqueo.rowCount === 0) {
                const error = "No se ha podido actualizar el bloqueo con los nuevo datos."
                throw new Error(error)
            }
            if (resuelveModificarBloqueo.rowCount === 1) {
                const ok = {
                    "ok": "Se ha actualizado el bloqueo correctamente"
                }
                salida.json(ok)
            }
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "crearNuevoBloqueo") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            let tipoBloqueo = entrada.body.tipoBloqueo
            let motivo = entrada.body.motivo
            let zona = entrada.body.zona
            const filtroApartamentoIDV = /^[a-z0-9]+$/;
            if (!apartamentoIDV || typeof apartamentoIDV !== "string" || !filtroApartamentoIDV.test(apartamentoIDV)) {
                const error = "el campo 'apartmentoIDV' solo puede ser letras min√∫sculas y numeros. Sin pesacios en formato cadena"
                throw new Error(error)
            }

            const validarApartamenotIDV = `
            SELECT
            *
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;`
            const resuelveValidarApartmento = await conexion.query(validarApartamenotIDV, [apartamentoIDV])
            if (resuelveValidarApartmento.rowCount === 0) {
                const error = "No existe el identificador del apartamento"
                throw new Error(error)
            }

            if (tipoBloqueo !== "permanente" && tipoBloqueo !== "rangoTemporal") {
                const error = "tipoBloqueo solo puede ser permanente o rangoTemporal"
                throw new Error(error)
            }
            if (zona !== "global" && zona !== "publico" && zona !== "privado") {
                const error = "zona solo puede ser global, publico o privado"
                throw new Error(error)
            }


            const filtroFecha = /^(?:(?:31(\/)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/)(?:0?[1,3-9]|1[0-2]))\2|(?:(?:0?[1-9])|(?:1[0-9])|(?:2[0-8]))(\/)(?:0?[1-9]|1[0-2]))\3(?:(?:19|20)[0-9]{2})$/;
            const filtroTextoSimple = /^[a-zA-Z0-9\s]+$/;

            let fechaInicio = null
            let fechaFin = null
            if (tipoBloqueo === "rangoTemporal") {
                fechaInicio = entrada.body.fechaInicio
                fechaFin = entrada.body.fechaFin
                if (!filtroFecha.test(fechaInicio)) {
                    const error = "el formato fechaInicio de bloqueo no esta correctamente formateado"
                    throw new Error(error)
                }

                if (!filtroFecha.test(fechaFin)) {
                    const error = "el formato fechaFin de bloqueo no esta correctamente formateado"
                    throw new Error(error)
                }

                const fechaInicioArray = fechaInicio.split("/")
                const fechaFinArray = fechaFin.split("/")

                const constructorFechaEntradaFormatoMDA = `${fechaInicioArray[1]}/${fechaInicioArray[0]}/${fechaInicioArray[2]}`
                const constructorFechaSalidaFormatoMDA = `${fechaFinArray[1]}/${fechaFinArray[0]}/${fechaFinArray[2]}`

                const controlFechaEntrada = new Date(constructorFechaEntradaFormatoMDA);
                const controlFechaSalida = new Date(constructorFechaSalidaFormatoMDA);

                if (controlFechaEntrada > controlFechaSalida) {
                    const error = "La fecha de inicio del bloqueo no puede ser inferior a la fecha de fin del bloqueo, si puede ser igual para determinar un solo dia"
                    throw new Error(error)
                }

            }

            if (motivo) {
                if (!filtroTextoSimple.test(motivo)) {
                    const error = "Por temas de seguridad ahora mismo en el campo motivo, solo pueden aceptarse min√∫sculas, may√∫sculas, espacio y numeros. Mas adelante se aceptaran todos los caracteres"
                    throw new Error(error)
                }

            } else {
                motivo = null
            }

            const insertarNuevoBloqueo = `
                INSERT INTO "bloqueosApartamentos"
                (
                apartamento,
                "tipoBloqueo",
                entrada,
                salida,
                motivo,
                zona
                )
                VALUES ($1, $2, $3, $4, $5, $6) RETURNING uid
                `
            const datosNuevoBloqueo = [
                apartamentoIDV,
                tipoBloqueo,
                fechaInicio,
                fechaFin,
                motivo,
                zona
            ]
            const resuelveInsertarNuevoBloqueo = await conexion.query(insertarNuevoBloqueo, datosNuevoBloqueo)
            if (resuelveInsertarNuevoBloqueo.rowCount === 0) {
                const error = "No se ha podido insertar el nuevo bloqueo"
                throw new Error(error)
            }

            if (resuelveInsertarNuevoBloqueo.rowCount === 1) {
                const nuevoUIDBloqueo = resuelveInsertarNuevoBloqueo.rows[0].uid
                const ok = {
                    "ok": "Se ha creado el bloqueo correctamente",
                    "nuevoBloqueoUID": nuevoUIDBloqueo,
                    "apartamentoIDV": apartamentoIDV
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "listarEntidadesAlojamiento") {
        try {
            const estructuraFinal = {}
            const consultaApartamento = `
            SELECT
            apartamento,
            superficie,
            "apartamentoUI",
            estado
            FROM apartamentos
            ;`
            const resuleveConsultaApartamento = await conexion.query(consultaApartamento)
            if (resuleveConsultaApartamento.rowCount > 0) {
                const apartamentoEntidad = resuleveConsultaApartamento.rows
                estructuraFinal.apartamentos = apartamentoEntidad
            }
            const consultaHabitaciones = `
            SELECT
            habitacion,
            "habitacionUI"
            FROM habitaciones
            ;`
            const resuelveConsultaHabitaciones = await conexion.query(consultaHabitaciones)
            if (resuelveConsultaHabitaciones.rowCount > 0) {
                const habitacionEntidad = resuelveConsultaHabitaciones.rows
                estructuraFinal.habitaciones = habitacionEntidad
            }
            const consultaCamas = `
            SELECT
            cama,
            "camaUI"
            FROM camas
            ;`
            const resuelveConsultaCamas = await conexion.query(consultaCamas)
            if (resuelveConsultaCamas.rowCount > 0) {
                const camaEntidades = resuelveConsultaCamas.rows
                estructuraFinal.camas = camaEntidades
            }
            const ok = {
                "ok": estructuraFinal
            }
            salida.json(ok)
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "listarApartamentosComoEntidades") {
        try {
            const estructuraApartamentosObjeto = {}
            const consultaApartamento = `
            SELECT
            apartamento,
            "apartamentoUI"
            FROM apartamentos;`
            const resuleveConsultaApartamento = await conexion.query(consultaApartamento)
            if (resuleveConsultaApartamento.rowCount === 0) {
                const ok = {
                    "ok": "No existe ningun apartamento como entidad, por favor crea uno para poder construir una configuracion de alojamiento sobre el",
                    "apartamentosComoEntidadesDisponibles": []
                }
                salida.json(ok)
            }

            if (resuleveConsultaApartamento.rowCount > 0) {
                const apartamentoEntidades = resuleveConsultaApartamento.rows

                apartamentoEntidades.map((detallesApartamento) => {
                    const apartamentoIDV = detallesApartamento.apartamento
                    const apartamentoUI = detallesApartamento.apartamento
                    estructuraApartamentosObjeto[apartamentoIDV] = apartamentoUI


                })

                const apartamentosComoEntidades_formatoArrayString = []

                apartamentoEntidades.map((detallesDelApartamento) => {
                    const apartamentoIDV = detallesDelApartamento.apartamento
                    apartamentosComoEntidades_formatoArrayString.push(apartamentoIDV)
                })


                const consultaConfiguraciones = `
                SELECT
                "apartamentoIDV"
                FROM "configuracionApartamento"
                ;`
                const resuelveConsultaApartamento = await conexion.query(consultaConfiguraciones)
                const apartamentoConfiguraciones = resuelveConsultaApartamento.rows

                const apartamentosIDVConfiguraciones_formatoArrayString = []

                apartamentoConfiguraciones.map((detallesapartamento) => {
                    const apartamentoIDV = detallesapartamento.apartamentoIDV
                    apartamentosIDVConfiguraciones_formatoArrayString.push(apartamentoIDV)


                })



                
                const apartamentosDisponiblesParaConfigurar = apartamentosComoEntidades_formatoArrayString.filter(entidad => !apartamentosIDVConfiguraciones_formatoArrayString.includes(entidad));
                
                const estructuraFinal = []

                for (const apartamentoDisponible of apartamentosDisponiblesParaConfigurar) {
                    if (estructuraApartamentosObjeto[apartamentoDisponible]) {
                        const estructuraFinalObjeto = {
                            apartamentoIDV: apartamentoDisponible,
                            apartamentoUI: estructuraApartamentosObjeto[apartamentoDisponible]
                        }
                        estructuraFinal.push(estructuraFinalObjeto)
                    }

                }
                const ok = {
                    "ok": "Apartamento especificos disponbiles",
                    "apartamentosComoEntidadesDisponibles": estructuraFinal
                }
                salida.json(ok)


            }







        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "detallesDeEntidadDeAlojamiento") {
        try {
            const tipoEntidad = entrada.body.tipoEntidad
            const entidadIDV = entrada.body.entidadIDV

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            const filtroCadenaMinusculasMayusculasSinEspacios = /^[a-zA-Z0-9]+$/;
            const filtroCadenaMinusculasConEspacios = /^[a-z0-9\s]+$/i;
            const filtroCadenaMinusculasMayusculasYEspacios = /^[a-zA-Z0-9\s]+$/;


            if (!tipoEntidad || !filtroCadenaMinusculasSinEspacios.test(tipoEntidad)) {
                const error = "el campo 'tipoEntidad' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }
            if (!entidadIDV || !filtroCadenaMinusculasSinEspacios.test(entidadIDV)) {
                const error = "el campo 'entidadIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }


            if (tipoEntidad === "apartamento") {
                const consultaDetalles = `
                SELECT 
                apartamento,
                "apartamentoUI",
                superficie
                FROM apartamentos 
                WHERE apartamento = $1;`
                const resuelveConsultaDetalles = await conexion.query(consultaDetalles, [entidadIDV])
                if (resuelveConsultaDetalles.rowCount === 0) {
                    const ok = {
                        ok: "No existe el apartamento"
                    }
                    salida.json(ok)
                }
                if (resuelveConsultaDetalles.rowCount === 1) {
                    const ok = {
                        ok: resuelveConsultaDetalles.rows
                    }
                    salida.json(ok)
                }
            }

            if (tipoEntidad === "habitacion") {
                const consultaDetalles = `
                SELECT 
                habitacion,
                "habitacionUI"
                FROM habitaciones 
                WHERE habitacion = $1;`
                const resuelveConsultaDetalles = await conexion.query(consultaDetalles, [entidadIDV])
                if (resuelveConsultaDetalles.rowCount === 0) {
                    const ok = {
                        ok: "No existe la habitacion"
                    }
                    salida.json(ok)
                }
                if (resuelveConsultaDetalles.rowCount === 1) {
                    const ok = {
                        ok: resuelveConsultaDetalles.rows
                    }
                    salida.json(ok)
                }
            }
            if (tipoEntidad === "cama") {
                const consultaDetalles = `
                SELECT 
                cama,
                "camaUI",
                capacidad
                FROM camas
                WHERE cama = $1;`
                const resuelveConsultaDetalles = await conexion.query(consultaDetalles, [entidadIDV])
                if (resuelveConsultaDetalles.rowCount === 0) {
                    const ok = {
                        ok: "No existe la cama"
                    }
                    salida.json(ok)
                }
                if (resuelveConsultaDetalles.rowCount === 1) {
                    const ok = {
                        ok: resuelveConsultaDetalles.rows
                    }
                    salida.json(ok)
                }
            }
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }








    }
    if (transaccion === "crearEntidadAlojamiento") {
        try {
            const tipoEntidad = entrada.body.tipoEntidad

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            const filtroCadenaMinusculasMayusculasSinEspacios = /^[a-zA-Z0-9]+$/;
            const filtroCadenaMinusculasConEspacios = /^[a-z0-9\s]+$/i;
            const filtroCadenaMinusculasMayusculasYEspacios = /^[a-zA-Z0-9\s]+$/;


            if (!tipoEntidad || !filtroCadenaMinusculasSinEspacios.test(tipoEntidad)) {
                const error = "el campo 'tipoEntidad' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }

            if (tipoEntidad === "apartamento") {

                const apartamentoIDV = entrada.body.apartamentoIDV
                const apartamentoUI = entrada.body.apartamentoUI
                const superficie = entrada.body.superficie

                if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV) || apartamentoIDV.length > 50) {
                    const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios. No puede tener mas de 50 caracteres"
                    throw new Error(error)
                }

                if (!apartamentoUI || !filtroCadenaMinusculasMayusculasYEspacios.test(apartamentoUI)) {
                    const error = "el campo 'apartamentoUI' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }

                if (!superficie || !filtroCadenaMinusculasMayusculasYEspacios.test(superficie)) {
                    const error = "el campo 'superficie' solo puede ser letras min√∫sculas, numeros y pesacios"
                    throw new Error(error)
                }

                const validarIDV = `
                SELECT 
                *
                FROM apartamentos
                WHERE apartamento = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [apartamentoIDV])
                if (resuelveValidarIDV.rowCount === 1) {
                    const error = "Ya existe un identificador visual igual que el apartamento que propones, escoge otro"
                    throw new Error(error)
                }


                const validarUI = `
                SELECT 
                *
                FROM apartamentos
                WHERE "apartamentoUI" = $1
                `
                const resuelveValidarUI = await conexion.query(validarUI, [apartamentoUI])
                if (resuelveValidarUI.rowCount === 1) {
                    const error = "Ya existe un apartamento con ese nombre, por tema de legibilidad escoge otro"
                    throw new Error(error)
                }


                const crearEntidad = `
                INSERT INTO apartamentos
                (
                apartamento,
                "apartamentoUI",
                superficie,
                estado
                )
                VALUES 
                (
                $1,
                $2,
                $3,
                $4
                )
                RETURNING apartamento
                `
                const matriozDatosNuevaEntidad = [
                    apartamentoIDV,
                    apartamentoUI,
                    superficie,
                    "noDisponible"
                ]
                const resuelveCrearEntidad = await conexion.query(crearEntidad, matriozDatosNuevaEntidad)
                if (resuelveCrearEntidad.rowCount === 0) {
                    const error = "No se ha podido crear la nueva entidad"
                    throw new Error(error)
                }
                if (resuelveCrearEntidad.rowCount === 1) {
                    const ok = {
                        ok: "Se ha creado correctament la nuevo entidad como apartamento",
                        nuevoUID: resuelveCrearEntidad.rows[0].apartamento
                    }
                    salida.json(ok)
                }
            }

            if (tipoEntidad === "habitacion") {

                const habitacionIDV = entrada.body.habitacionIDV
                const habitacionUI = entrada.body.habitacionUI

                if (!habitacionIDV || !filtroCadenaMinusculasSinEspacios.test(habitacionIDV) || habitacionIDV.length > 50) {
                    const error = "el campo 'habitacionIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios. No puede tener mas de 50 caracteres"
                    throw new Error(error)
                }

                if (!habitacionUI || !filtroCadenaMinusculasMayusculasYEspacios.test(habitacionUI)) {
                    const error = "el campo 'habitacionUI' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }


                const validarIDV = `
                SELECT 
                *
                FROM habitaciones
                WHERE habitacion = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [habitacionIDV])
                if (resuelveValidarIDV.rowCount === 1) {
                    const error = "Ya existe un identificador visual igual que el que propones, escoge otro"
                    throw new Error(error)
                }


                const validarUI = `
                SELECT 
                *
                FROM habitaciones
                WHERE "habitacionUI" = $1
                `
                const resuelveValidarUI = await conexion.query(validarUI, [habitacionUI])
                if (resuelveValidarUI.rowCount === 1) {
                    const error = "Ya existe un nombre de la habitacion exactamente igual, por tema de legibilidad escoge otro"
                    throw new Error(error)
                }


                const crearEntidad = `
                INSERT INTO habitaciones
                (
                habitacion,
                "habitacionUI"
                )
                VALUES 
                (
                $1,
                $2
                )
                RETURNING habitacion
                `
                const matriozDatosNuevaEntidad = [
                    habitacionIDV,
                    habitacionUI,
                ]
                let resuelveCrearEntidad = await conexion.query(crearEntidad, matriozDatosNuevaEntidad)
                if (resuelveCrearEntidad.rowCount === 0) {
                    const error = "No se ha podido crear la nueva entidad"
                    throw new Error(error)
                }
                if (resuelveCrearEntidad.rowCount === 1) {
                    const ok = {
                        ok: "Se ha creado correctament la nuevo entidad como habitacion",
                        nuevoUID: resuelveCrearEntidad.rows[0].habitacion
                    }
                    salida.json(ok)
                }
            }
            if (tipoEntidad === "cama") {
                const camaIDV = entrada.body.camaIDV
                const camaUI = entrada.body.camaUI
                let capacidad = entrada.body.capacidad

                if (!camaIDV || !filtroCadenaMinusculasSinEspacios.test(camaIDV) || camaIDV.length > 50) {
                    const error = "el campo 'camaIDV' solo puede ser letras min√∫sculas, numeros y sin espacios. No puede tener mas de 50 caracteres."
                    throw new Error(error)
                }

                if (!camaUI || !filtroCadenaMinusculasMayusculasYEspacios.test(camaUI)) {
                    const error = "el campo 'camaUI' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
                const filtroSoloNumeros = /^\d+$/;
                if (filtroSoloNumeros.test(capacidad)) {
                    capacidad = parseInt(capacidad);
                }
                if (!capacidad || !Number.isInteger(capacidad) || capacidad < 0) {
                    const error = "el campo 'capacidad' solo puede ser numeros, entero y positivo"
                    throw new Error(error)
                }


                const validarIDV = `
                SELECT 
                *
                FROM camas
                WHERE cama = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [camaIDV])
                if (resuelveValidarIDV.rowCount === 1) {
                    const error = "Ya existe un identificador visual igual que la cama que propones, escoge otro"
                    throw new Error(error)
                }

                const validarUI = `
                SELECT 
                *
                FROM camas
                WHERE "camaUI" = $1
                `
                const resuelveValidarUI = await conexion.query(validarUI, [camaUI])
                if (resuelveValidarUI.rowCount === 1) {
                    const error = "Ya existe una cama con ese nombre, por tema de legibilidad escoge otro"
                    throw new Error(error)
                }

                const crearEntidad = `
                INSERT INTO camas
                (
                cama,
                "camaUI",
                capacidad
                )
                VALUES 
                (
                $1,
                $2,
                $3
                )
                RETURNING cama
                `
                const matriozDatosNuevaEntidad = [
                    camaIDV,
                    camaUI,
                    capacidad
                ]
                const resuelveCrearEntidad = await conexion.query(crearEntidad, matriozDatosNuevaEntidad)
                if (resuelveCrearEntidad.rowCount === 0) {
                    const error = "No se ha podido crear la nueva entidad"
                    throw new Error(error)
                }
                if (resuelveCrearEntidad.rowCount === 1) {
                    const ok = {
                        ok: "Se ha creado correctament la nuevo entidad como cama",
                        nuevoUID: resuelveCrearEntidad.rows[0].cama
                    }
                    salida.json(ok)
                }
            }





        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "modificarEntidadAlojamiento") {
        try {
            const tipoEntidad = entrada.body.tipoEntidad
            const entidadIDV = entrada.body.entidadIDV

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            const filtroCadenaMinusculasMayusculasSinEspacios = /^[a-zA-Z0-9]+$/;

            const filtroCadenaMinusculasConEspacios = /^[a-z0-9\s]+$/i;
            const filtroCadenaMinusculasMayusculasYEspacios = /^[a-zA-Z0-9\s]+$/;

            if (!tipoEntidad || !filtroCadenaMinusculasSinEspacios.test(tipoEntidad)) {
                const error = "el campo 'tipoEntidad' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }
            if (!entidadIDV || !filtroCadenaMinusculasSinEspacios.test(entidadIDV)) {
                const error = "el campo 'entidadIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            if (tipoEntidad === "apartamento") {

                const apartamentoIDV = entrada.body.apartamentoIDV
                const apartamentoUI = entrada.body.apartamentoUI
                const superficie = entrada.body.superficie

                if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV) || apartamentoIDV.length > 50) {
                    const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios. No puede tener mas de 50 caracteres."
                    throw new Error(error)
                }

                if (!apartamentoUI || !filtroCadenaMinusculasMayusculasYEspacios.test(apartamentoUI)) {
                    const error = "el campo 'apartamentoUI' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }



                if (!superficie || !filtroCadenaMinusculasMayusculasYEspacios.test(superficie)) {
                    const error = "el campo 'superficie' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }



                const validarIDV = `
                SELECT 
                *
                FROM apartamentos
                WHERE apartamento = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe el apartamento, revisa el apartamentopIDV"
                    throw new Error(error)
                }

                // Comprobar que no existe el nuevo IDV
                if (entidadIDV !== apartamentoIDV) {
                    const validarNuevoIDV = `
                    SELECT 
                    *
                    FROM apartamentos
                    WHERE apartamento = $1
                    `
                    const resuelveValidarNuevoIDV = await conexion.query(validarNuevoIDV, [apartamentoIDV])
                    if (resuelveValidarNuevoIDV.rowCount === 1) {
                        const error = "El nuevo identificador de la entidad ya existe, escoge otro por favor"
                        throw new Error(error)
                    }
                }

                const guardarCambios = `
                UPDATE apartamentos
                SET 
                apartamento= COALESCE($1, apartamento),
                "apartamentoUI" = COALESCE($2, "apartamentoUI"),
                superficie = COALESCE($4, superficie)
                WHERE apartamento = $3
                `
                const matrizCambios = [
                    apartamentoIDV,
                    apartamentoUI,
                    entidadIDV,
                    superficie
                ]
                const resuelveGuardarCambios = await conexion.query(guardarCambios, matrizCambios)
                if (resuelveGuardarCambios.rowCount === 0) {
                    const error = "No se ha podido guardar los datos por que no se han encontrado la habitacion"
                    throw new Error(error)
                }
                if (resuelveGuardarCambios.rowCount === 1) {
                    const ok = {
                        ok: "Se ha actualizado correctamente el apartamento"
                    }
                    salida.json(ok)
                }
            }
            if (tipoEntidad === "habitacion") {

                const habitacionIDV = entrada.body.habitacionIDV
                const habitacionUI = entrada.body.habitacionUI

                if (!habitacionIDV || !filtroCadenaMinusculasSinEspacios.test(habitacionIDV) || habitacionIDV.length > 50) {
                    const error = "el campo 'habitacionIDV' solo puede ser letras min√∫sculas, numeros y sin espacios. No puede tener mas de 50 caracteres"
                    throw new Error(error)
                }

                if (!habitacionUI || !filtroCadenaMinusculasMayusculasYEspacios.test(habitacionUI)) {
                    const error = "el campo 'habitacionUI' solo puede ser letras may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }

                const validarIDV = `
                SELECT 
                *
                FROM habitaciones
                WHERE habitacion = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe la habitacion, revisa el habitacionIDV"
                    throw new Error(error)
                }

                // Comprobar que no existe el nuevo IDV
                if (entidadIDV !== habitacionIDV) {
                    const validarNuevoIDV = `
                    SELECT 
                    *
                    FROM habitaciones
                    WHERE habitacion = $1
                    `
                    const resuelveValidarNuevoIDV = await conexion.query(validarNuevoIDV, [habitacionIDV])
                    if (resuelveValidarNuevoIDV.rowCount === 1) {
                        const error = "El nuevo identificador de la entidad ya existe, escoge otro por favor"
                        throw new Error(error)
                    }
                }

                const guardarCambios = `
                UPDATE habitaciones
                SET 
                habitacion = COALESCE($1, habitacion),
                "habitacionUI" = COALESCE($2, "habitacionUI")
                WHERE habitacion = $3
                `
                const matrizCambios = [
                    habitacionIDV,
                    habitacionUI,
                    entidadIDV
                ]
                const resuelveGuardarCambios = await conexion.query(guardarCambios, matrizCambios)
                if (resuelveGuardarCambios.rowCount === 0) {
                    const error = "No se ha podido guardar los datosd por que no se han encontrado la habitacion"
                    throw new Error(error)
                }
                if (resuelveGuardarCambios.rowCount === 1) {
                    const ok = {
                        ok: "Se ha actualizado correctamente la habitacion"
                    }
                    salida.json(ok)
                }
            }
            if (tipoEntidad === "cama") {
                const camaIDV = entrada.body.camaIDV
                const camaUI = entrada.body.camaUI
                let capacidad = entrada.body.capacidad





                if (!camaIDV || !filtroCadenaMinusculasSinEspacios.test(camaIDV) || camaIDV.length > 50) {
                    const error = "el campo 'camaIDV' solo puede ser letras min√∫sculas, numeros y sin espacios. No puede tener mas de 50 caracteres"
                    throw new Error(error)
                }

                if (!camaUI || !filtroCadenaMinusculasMayusculasYEspacios.test(camaUI)) {
                    const error = "el campo 'camaUI' solo puede ser letras min√∫sculas, may√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
                const filtroSoloNumeros = /^\d+$/;
                if (filtroSoloNumeros.test(capacidad)) {
                    capacidad = parseInt(capacidad);
                }
                if (!capacidad || !Number.isInteger(capacidad) || capacidad < 0) {
                    const error = "el campo 'capacidad' solo puede ser numeros, entero y positivo"
                    throw new Error(error)
                }


                const validarIDV = `
                SELECT 
                *
                FROM camas
                WHERE cama = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe la habitacion, revisa el habitacionIDV"
                    throw new Error(error)
                }

                // Comprobar que no existe el nuevo IDV
                if (entidadIDV !== camaIDV) {
                    const validarNuevoIDV = `
                    SELECT 
                    *
                    FROM camas
                    WHERE cama = $1
                    `
                    const resuelveValidarNuevoIDV = await conexion.query(validarNuevoIDV, [camaIDV])
                    if (resuelveValidarNuevoIDV.rowCount === 1) {
                        const error = "El nuevo identificador de la entidad ya existe, escoge otro por favor"
                        throw new Error(error)
                    }
                }

                const guardarCambios = `
                UPDATE camas
                SET 
                cama = COALESCE($1, cama),
                "camaUI" = COALESCE($2, "camaUI"),
                capacidad = COALESCE($3, "capacidad")
                WHERE cama = $4
                `
                const matrizCambios = [
                    camaIDV,
                    camaUI,
                    capacidad,
                    entidadIDV,
                ]
                const resuelveGuardarCambios = await conexion.query(guardarCambios, matrizCambios)
                if (resuelveGuardarCambios.rowCount === 0) {
                    const error = "No se ha podido guardar los datosd por que no se han encontrado la cama"
                    throw new Error(error)
                }
                if (resuelveGuardarCambios.rowCount === 1) {
                    const ok = {
                        ok: "Se ha actualizado correctamente la cama"
                    }
                    salida.json(ok)
                }
            }
        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "eliminarEntidadAlojamiento") {
        try {
            const tipoEntidad = entrada.body.tipoEntidad
            const entidadIDV = entrada.body.entidadIDV

            const filtroCadenaSinEspacios = /^[a-z0-9]+$/;
            const filtroCadenaConEspacios = /^[a-z0-9\s]+$/i;


            if (!tipoEntidad || !filtroCadenaSinEspacios.test(tipoEntidad)) {
                const error = "el campo 'tipoEntidad' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }
            if (!entidadIDV || !filtroCadenaSinEspacios.test(entidadIDV)) {
                const error = "el campo 'entidadIDV' solo puede ser letras min√∫sculas y numeros. sin pesacios"
                throw new Error(error)
            }

            if (tipoEntidad === "apartamento") {

                const validarIDV = `
                SELECT 
                *
                FROM apartamentos
                WHERE apartamento = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe el apartamento que desea borrar, revisa el apartamentoIDV"
                    throw new Error(error)
                }

                const eliminarEntidad = `
                DELETE FROM apartamentos
                WHERE apartamento = $1;
                `
                const resuelveEliminarBloqueo = await conexion.query(eliminarEntidad, [entidadIDV])
                if (resuelveEliminarBloqueo.rowCount === 0) {
                    const error = "No se ha eliminado el apartamento por que no se ha encontrado el registo en la base de datos"
                    throw new Error(error)
                }
                if (resuelveEliminarBloqueo.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha eliminado correctamente el apartamento como entidad",
                    }
                    salida.json(ok)
                }

            }

            if (tipoEntidad === "habitacion") {

                const validarIDV = `
                SELECT 
                *
                FROM habitaciones
                WHERE habitacion = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe la habitacion, revisa el habitacionIDV"
                    throw new Error(error)
                }

                const eliminarEntidad = `
                DELETE FROM habitaciones
                WHERE habitacion = $1;
                `
                const resuelveEliminarBloqueo = await conexion.query(eliminarEntidad, [entidadIDV])
                if (resuelveEliminarBloqueo.rowCount === 0) {
                    const error = "No se ha eliminado la habitacion por que no se ha entonctrado el registo en la base de datos"
                    throw new Error(error)
                }
                if (resuelveEliminarBloqueo.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha eliminado correctamente la habitacion como entidad",
                    }
                    salida.json(ok)
                }



            }
            if (tipoEntidad === "cama") {
                const validarIDV = `
                SELECT 
                *
                FROM camas
                WHERE cama = $1
                `
                const resuelveValidarIDV = await conexion.query(validarIDV, [entidadIDV])
                if (resuelveValidarIDV.rowCount === 0) {
                    const error = "No existe la cama, revisa el camaIDV"
                    throw new Error(error)
                }

                const eliminarEntidad = `
                DELETE FROM camas
                WHERE cama = $1;
                `
                const resuelveEliminarBloqueo = await conexion.query(eliminarEntidad, [entidadIDV])
                if (resuelveEliminarBloqueo.rowCount === 0) {
                    const error = "No se ha eliminado la cama por que no se ha entonctrado el registo en la base de datos"
                    throw new Error(error)
                }
                if (resuelveEliminarBloqueo.rowCount === 1) {
                    const ok = {
                        "ok": "Se ha eliminado correctamente la cama como entidad",
                    }
                    salida.json(ok)
                }

            }





        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "listarConfiguracionApartamentos") {
        try {
            const seleccionaApartamentos = `
            SELECT 
            uid,
            "apartamentoIDV",
            "estadoConfiguracion"
            FROM "configuracionApartamento"
            `
            const resuelveSeleccionaApartamentos = await conexion.query(seleccionaApartamentos)
            const apartamentosConConfiguracion = []
            if (resuelveSeleccionaApartamentos.rowCount > 0) {
                const apartamentoEntidad = resuelveSeleccionaApartamentos.rows
                for (const detallesDelApartamento of apartamentoEntidad) {

                    const apartamentoIDV = detallesDelApartamento.apartamentoIDV
                    const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)
                    const estadoConfiguracion = detallesDelApartamento.estadoConfiguracion

                    const estructuraFinal = {
                        apartamentoIDV: apartamentoIDV,
                        apartamentoUI: apartamentoUI,
                        estadoConfiguracion: estadoConfiguracion
                    }
                    apartamentosConConfiguracion.push(estructuraFinal)


                }
            }
            const ok = {
                ok: apartamentosConConfiguracion
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "detalleConfiguracionAlojamiento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }


            const consultaPerfilConfiguracion = `
            SELECT 
            uid,
            "apartamentoIDV",
            "estadoConfiguracion",
            imagen
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveConsultaPerfilConfiguracion = await conexion.query(consultaPerfilConfiguracion, [apartamentoIDV])
            if (resuelveConsultaPerfilConfiguracion.rowCount === 0) {
                const ok = {
                    ok: "No hay ninguna configuracion disponible para este apartamento"
                }
                salida.json(ok)
            }
            if (resuelveConsultaPerfilConfiguracion.rowCount > 0) {

                const estadoConfiguracion = resuelveConsultaPerfilConfiguracion.rows[0].estadoConfiguracion
                const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)

                const consultaHabitaciones = `
                SELECT 
                uid,
                apartamento,
                habitacion
                FROM "configuracionHabitacionesDelApartamento"
                WHERE apartamento = $1;
                `
                const resuelveConsultaHabitaciones = await conexion.query(consultaHabitaciones, [apartamentoIDV])
                const habitacionesEncontradas = resuelveConsultaHabitaciones.rows


                for (const detalleHabitacion of habitacionesEncontradas) {
                    const uidHabitacion = detalleHabitacion.uid
                    const apartamentoIDV = detalleHabitacion.apartamento
                    const habitacionIDV = detalleHabitacion.habitacion

                    const resolucionNombreHabitacion = await conexion.query(`SELECT "habitacionUI" FROM habitaciones WHERE habitacion = $1`, [habitacionIDV])
                    if (resolucionNombreHabitacion.rowCount === 0) {
                        const error = "No existe el identificador de la habitacionIDV"
                        throw new Error(error)
                    }
                    const habitacionUI = resolucionNombreHabitacion.rows[0].habitacionUI
                    detalleHabitacion.habitacionUI = habitacionUI


                    const consultaCamas = `
                    SELECT
                    uid,
                    habitacion, 
                    cama
                    FROM
                    "configuracionCamasEnHabitacion"
                    WHERE
                    habitacion = $1
                    `
                    const resolverConsultaCamas = await conexion.query(consultaCamas, [uidHabitacion])
                    detalleHabitacion.camas = []
                    if (resolverConsultaCamas.rowCount > 0) {


                        const camasEntontradas = resolverConsultaCamas.rows
                        for (const detallesCama of camasEntontradas) {

                            const uidCama = detallesCama.uid
                            const camaIDV = detallesCama.cama

                            const resolucionNombreCama = await conexion.query(`SELECT "camaUI", capacidad FROM camas WHERE cama = $1`, [camaIDV])
                            if (resolucionNombreCama.rowCount === 0) {
                                const error = "No existe el identificador de la camaIDV"
                                throw new Error(error)
                            }

                            const camaUI = resolucionNombreCama.rows[0].camaUI
                            const capacidad = resolucionNombreCama.rows[0].capacidad

                            const estructuraCama = {
                                uid: uidCama,
                                camaIDV: camaIDV,
                                camaUI: camaUI,
                                capacidad: capacidad

                            }
                            detalleHabitacion.camas.push(estructuraCama)

                        }
                    }
                }

                const ok = {
                    ok: habitacionesEncontradas,
                    apartamentoIDV: apartamentoIDV,
                    apartamentoUI: apartamentoUI,
                    estadoConfiguracion: estadoConfiguracion,
                }
                salida.json(ok)



            }





        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "obtenerImagenConfiguracionAdministracion") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }
            const consultaPerfilConfiguracion = `
            SELECT 
            imagen
            imagen
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveConsultaPerfilConfiguracion = await conexion.query(consultaPerfilConfiguracion, [apartamentoIDV])
            if (resuelveConsultaPerfilConfiguracion.rowCount === 0) {
                const ok = {
                    ok: "No hay ninguna configuracion disponible para este apartamento"
                }
                salida.json(ok)
            }
            if (resuelveConsultaPerfilConfiguracion.rowCount === 1) {
                const imagen = resuelveConsultaPerfilConfiguracion.rows[0].imagen

                const ok = {
                    ok: "Imagen de la configuracion adminsitrativa del apartamento, png codificado en base64",
                    imagen: imagen
                }
                salida.json(ok)

            }


        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }

    }
    if (transaccion === "listarHabitacionesDisponbilesApartamentoConfiguracion") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            const consultaDetallesConfiguracion = `
            SELECT 
            *
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const metadatos = [
                apartamentoIDV
            ]
            const resuelveConsultaDetallesConfiguracion = await conexion.query(consultaDetallesConfiguracion, metadatos)
            if (resuelveConsultaDetallesConfiguracion.rowCount === 0) {
                const ok = {
                    ok: "No hay ninguna configuracion disponible para este apartamento"
                }
                salida.json(ok)
            }
            

            if (resuelveConsultaDetallesConfiguracion.rowCount > 0) {


                const consultaHabitacionesEnConfiguracion = await conexion.query(`SELECT habitacion FROM "configuracionHabitacionesDelApartamento" WHERE apartamento = $1`, [apartamentoIDV])
                const habitacionesEnConfiguracionArrayLimpio = []
                const habitacionesEnConfiguracion = consultaHabitacionesEnConfiguracion.rows
                for (const detalleHabitacion of habitacionesEnConfiguracion) {
                    const habitacionIDV = detalleHabitacion.habitacion
                    habitacionesEnConfiguracionArrayLimpio.push(habitacionIDV)
                }


                const resuelveHabitacionesComoEntidad = await conexion.query(`SELECT habitacion, "habitacionUI" FROM habitaciones`)
                const habitacionesComoEntidad = resuelveHabitacionesComoEntidad.rows
                const habitacionComoEntidadArrayLimpio = []
                const habitacionesComoEntidadEstructuraFinal = {}
                for (const detalleHabitacion of habitacionesComoEntidad) {
                    const habitacionUI = detalleHabitacion.habitacionUI
                    const habitacionIDV = detalleHabitacion.habitacion

                    habitacionComoEntidadArrayLimpio.push(habitacionIDV)

                    habitacionesComoEntidadEstructuraFinal[habitacionIDV] = habitacionUI

                }
                

                const habitacionesDisponiblesNoInsertadas = habitacionComoEntidadArrayLimpio.filter(entidad => !habitacionesEnConfiguracionArrayLimpio.includes(entidad));
                
                const estructuraFinal = []

                for (const habitacionDisponible of habitacionesDisponiblesNoInsertadas) {
                    if (habitacionesComoEntidadEstructuraFinal[habitacionDisponible]) {

                        const estructuraFinalObjeto = {
                            habitacionIDV: habitacionDisponible,
                            habitacionUI: habitacionesComoEntidadEstructuraFinal[habitacionDisponible]

                        }

                        estructuraFinal.push(estructuraFinalObjeto)

                    }

                }
                const ok = {
                    ok: estructuraFinal
                }
                salida.json(ok)

            }





        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }


    }
    if (transaccion === "addHabitacionToConfiguracionApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const habitacionIDV = entrada.body.habitacionIDV
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            if (!habitacionIDV || !filtroCadenaMinusculasSinEspacios.test(habitacionIDV)) {
                const error = "el campo 'habitacionIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            const consultaApartamento = `
            SELECT 
            "estadoConfiguracion"
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveConsultaApartamento = await conexion.query(consultaApartamento, [apartamentoIDV])
            if (resuelveConsultaApartamento.rowCount === 0) {
                const error = "No hay ningun apartamento con ese identificador visual"
                throw new Error(error)
            }
            if (resuelveConsultaApartamento.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede anadir una habitacion cuando el estado de la configuracion es Disponible, cambie el estado a no disponible para realizar anadir una cama"
                throw new Error(error)
            }


            if (resuelveConsultaApartamento.rowCount === 1) {


                const apartamentoUI = await resolverApartamentoUI(apartamentoIDV)


                const resolucionNombreHabitacion = await conexion.query(`SELECT "habitacionUI" FROM habitaciones WHERE habitacion = $1`, [habitacionIDV])
                if (resolucionNombreHabitacion.rowCount === 0) {
                    const error = "No existe el identificador visual de la habitacion"
                    throw new Error(error)
                }
                const habitacionUI = resolucionNombreHabitacion.rows[0].habitacionUI

                const validarInexistenciaHabitacionEnConfiguracionDeApartamento = await conexion.query(`SELECT * FROM "configuracionHabitacionesDelApartamento" WHERE apartamento = $1 AND habitacion = $2 `, [apartamentoIDV, habitacionIDV])
                if (validarInexistenciaHabitacionEnConfiguracionDeApartamento.rowCount === 1) {
                    const error = `Ya existe la ${habitacionUI} en esta configuracion del ${apartamentoUI}`
                    throw new Error(error)
                }

                const insertarHabitacion = `
                INSERT INTO "configuracionHabitacionesDelApartamento"
                (
                apartamento,
                habitacion
                )
                VALUES ($1, $2) RETURNING uid
                `
                const resuelveInsertarHabitacion = await conexion.query(insertarHabitacion, [apartamentoIDV, habitacionIDV])
                if (resuelveInsertarHabitacion.rowCount === 0) {
                    const error = `Se han pasado las validaciones pero la base de datos no ha insertado el registro`
                    throw new Error(error)
                }

                if (resuelveInsertarHabitacion.rowCount === 1) {
                    const ok = {
                        ok: "Se ha insertado correctament la nueva habitacion",
                        habitacionUID: resuelveInsertarHabitacion.rows[0].uid,
                        habitacionIDV: habitacionIDV,
                        habitacionUI: habitacionUI
                    }
                    salida.json(ok)
                }
            }


        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }


    }
    if (transaccion === "listarCamasDisponbilesApartamentoConfiguracion") {
        try {
            const habitacionUID = entrada.body.habitacionUID
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!habitacionUID || !Number.isInteger(habitacionUID) || habitacionUID < 0) {
                const error = "el campo 'habitacionUID' solo puede ser numeros"
                throw new Error(error)
            }

            const validarHabitacionUID = `
            SELECT 
            habitacion
            FROM "configuracionHabitacionesDelApartamento"
            WHERE uid = $1;
            `
            const metadatos = [
                habitacionUID
            ]
            const resuelveConsultaDetallesConfiguracion = await conexion.query(validarHabitacionUID, metadatos)
            if (resuelveConsultaDetallesConfiguracion.rowCount === 0) {
                const ok = {
                    ok: "No hay ninguna habitacion con ese identificador disponible para este apartamento"
                }
                salida.json(ok)
            }
            

            if (resuelveConsultaDetallesConfiguracion.rowCount > 0) {


                const consultaCamasEnHabitacion = await conexion.query(`SELECT cama FROM "configuracionCamasEnHabitacion" WHERE habitacion = $1`, [habitacionUID])
                const camasArrayLimpioEnHabitacion = []
                const camasEncontradasEnHabitacion = consultaCamasEnHabitacion.rows
                for (const detalleHabitacion of camasEncontradasEnHabitacion) {
                    const camaIDV = detalleHabitacion.cama
                    camasArrayLimpioEnHabitacion.push(camaIDV)
                }


                const resuelveCamasComoEntidad = await conexion.query(`SELECT cama, "camaUI" FROM camas`)
                const camasComoEntidad = resuelveCamasComoEntidad.rows
                const camasComoEntidadArrayLimpio = []
                const camasComoEntidadEstructuraFinal = {}
                for (const detalleHabitacion of camasComoEntidad) {
                    const camaUI = detalleHabitacion.camaUI
                    const camaIDV = detalleHabitacion.cama

                    camasComoEntidadArrayLimpio.push(camaIDV)
                    camasComoEntidadEstructuraFinal[camaIDV] = camaUI

                }

                const camasDisponiblesNoInsertadas = camasComoEntidadArrayLimpio.filter(entidad => !camasArrayLimpioEnHabitacion.includes(entidad));
                const estructuraFinal = []

                for (const camaDisponible of camasDisponiblesNoInsertadas) {
                    if (camasComoEntidadEstructuraFinal[camaDisponible]) {
                        const estructuraFinalObjeto = {
                            camaIDV: camaDisponible,
                            camaUI: camasComoEntidadEstructuraFinal[camaDisponible]
                        }
                        estructuraFinal.push(estructuraFinalObjeto)
                    }

                }
                const ok = {
                    ok: estructuraFinal
                }
                salida.json(ok)

            }





        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }


    }
    if (transaccion === "addCamaToConfiguracionApartamentoHabitacion") {
        try {
            const camaIDV = entrada.body.camaIDV
            const habitacionUID = entrada.body.habitacionUID
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!camaIDV || !filtroCadenaMinusculasSinEspacios.test(camaIDV)) {
                const error = "el campo 'camaIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            if (!habitacionUID || !Number.isInteger(habitacionUID) || habitacionUID < 0) {
                const error = "el campo 'habitacionUID' solo puede ser numeros"
                throw new Error(error)
            }

            // validar la cama
            const consultaCamaIDV = `
            SELECT
            capacidad,
            "camaUI", 
            cama
            FROM camas
            WHERE cama = $1;
            `
            const resuelveConsultaCamaIDV = await conexion.query(consultaCamaIDV, [camaIDV])
            if (resuelveConsultaCamaIDV.rowCount === 0) {
                const error = "No existe ninguna cama con ese identificador visual"
                throw new Error(error)
            }
            const camaUI = resuelveConsultaCamaIDV.rows[0].camaUI
            const capacidad = resuelveConsultaCamaIDV.rows[0].capacidad


            const consultaHabitacion = `
            SELECT 
            habitacion, apartamento
            FROM "configuracionHabitacionesDelApartamento"
            WHERE uid = $1;
            `
            const resuelveConsultaHabitacion = await conexion.query(consultaHabitacion, [habitacionUID])
            if (resuelveConsultaHabitacion.rowCount === 0) {
                const error = "No hay ninguna habitac√≠on con ese UID"
                throw new Error(error)
            }
            if (resuelveConsultaHabitacion.rowCount === 1) {
                const apartamentoIDV = resuelveConsultaHabitacion.rows[0].apartamento
                const consultaApartamento = `
                SELECT 
                "estadoConfiguracion"
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1;
                `
                const resuelveConsultaApartamento = await conexion.query(consultaApartamento, [apartamentoIDV])
                if (resuelveConsultaApartamento.rows[0].estadoConfiguracion === "disponible") {
                    const error = "No se puede anadir una habitacion cuando el estado de la configuracion es Disponible, cambie el estado a no disponible para realizar anadir una cama"
                    throw new Error(error)
                }




                const habitacionIDV = resuelveConsultaHabitacion.rows[0].habitacion

                const resuelveCamasEnHabitacion = await conexion.query(`SELECT cama FROM "configuracionCamasEnHabitacion" WHERE habitacion = $1 AND cama = $2 `, [habitacionUID, camaIDV])
                if (resuelveCamasEnHabitacion.rowCount > 0) {
                    const error = "Esta cama ya existe"
                    throw new Error(error)
                }

                if (resuelveCamasEnHabitacion.rowCount === 0) {

                    const insertarCamaEnHabitacion = `
                    INSERT INTO "configuracionCamasEnHabitacion"
                    (
                    habitacion,
                    cama
                    )
                    VALUES ($1, $2) RETURNING uid
                    `
                    const resuelveInsertarHabitacion = await conexion.query(insertarCamaEnHabitacion, [habitacionUID, camaIDV])
                    if (resuelveInsertarHabitacion.rowCount === 0) {
                        const error = `Se han pasado las validaciones pero la base de datos no ha insertado el registro`
                        throw new Error(error)
                    }

                    if (resuelveInsertarHabitacion.rowCount === 1) {
                        const nuevoUID = resuelveInsertarHabitacion.rows[0].uid
                        const ok = {
                            ok: "Se ha insertardo la cama correctamente en la habitacion",
                            nuevoUID: nuevoUID,
                            camaUI: camaUI,
                            camaIDV: camaIDV,
                            capaciad: capacidad
                        }
                        salida.json(ok)
                    }



                }




            }


        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }


    }
    if (transaccion === "eliminarHabitacionDeConfiguracionDeAlojamiento") {
        try {
            const habitacionUID = entrada.body.habitacionUID

            if (!habitacionUID || !Number.isInteger(habitacionUID) || habitacionUID < 0) {
                const error = "el campo 'habitacionUID' solo puede ser numeros"
                throw new Error(error)
            }

            const validarHabitacionUID = `
                SELECT 
                apartamento
                FROM "configuracionHabitacionesDelApartamento"
                WHERE uid = $1
                `
            const resuelveValidarHabitacionUID = await conexion.query(validarHabitacionUID, [habitacionUID])
            if (resuelveValidarHabitacionUID.rowCount === 0) {
                const error = "No existe la habitacion, revisa el habitacionUID"
                throw new Error(error)
            }

            const apartamentoIDV = resuelveValidarHabitacionUID.rows[0].apartamento
            const consultaApartamento = `
            SELECT 
            "estadoConfiguracion"
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveConsultaApartamento = await conexion.query(consultaApartamento, [apartamentoIDV])
            if (resuelveConsultaApartamento.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede eliminar una habitacion cuando el estado de la configuracion es Disponible, cambie el estado a no disponible para realizar anadir una cama"
                throw new Error(error)
            }


            const eliminarHabitacion = `
                DELETE FROM "configuracionHabitacionesDelApartamento"
                WHERE uid = $1;
                `
            const resuelveEliminarHabitacion = await conexion.query(eliminarHabitacion, [habitacionUID])
            if (resuelveEliminarHabitacion.rowCount === 0) {
                const error = "No se ha eliminado la habitacion por que no se ha entonctrado el registo en la base de datos"
                throw new Error(error)
            }
            if (resuelveEliminarHabitacion.rowCount === 1) {
                const ok = {
                    "ok": "Se ha eliminado correctamente la habitacion como entidad",
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "eliminarCamaDeConfiguracionDeAlojamiento") {
        try {
            const camaUID = entrada.body.camaUID

            if (!camaUID || !Number.isInteger(camaUID) || camaUID < 0) {
                const error = "el campo 'camaUID' solo puede ser numeros"
                throw new Error(error)
            }

            const validarHabitacionUID = `
                SELECT 
                habitacion
                FROM "configuracionCamasEnHabitacion"
                WHERE uid = $1
                `
            const resuelveValidarHabitacionUID = await conexion.query(validarHabitacionUID, [camaUID])
            if (resuelveValidarHabitacionUID.rowCount === 0) {
                const error = "No existe la cama, revisa el camaUID"
                throw new Error(error)
            }

            const habitacionUID = resuelveValidarHabitacionUID.rows[0].habitacion
            const consultaIntermediaEscaleraHaciaArriba = `
            SELECT 
            apartamento
            FROM "configuracionHabitacionesDelApartamento"
            WHERE uid = $1;
            `
            const resuelveConsultaIntermediaEscaleraHaciaArriba = await conexion.query(consultaIntermediaEscaleraHaciaArriba, [habitacionUID])
            const apartamentoIDV = resuelveConsultaIntermediaEscaleraHaciaArriba.rows[0].apartamento
            const consultaApartamento = `
            SELECT 
            "estadoConfiguracion"
            FROM "configuracionApartamento"
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveConsultaApartamento = await conexion.query(consultaApartamento, [apartamentoIDV])
            if (resuelveConsultaApartamento.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede eliminar una habitacion cuando el estado de la configuracion es Disponible, cambie el estado a no disponible para realizar anadir una cama"
                throw new Error(error)
            }





            const eliminarCama = `
                DELETE FROM "configuracionCamasEnHabitacion"
                WHERE uid = $1;
                `
            const resuelveEliminarCama = await conexion.query(eliminarCama, [camaUID])
            if (resuelveEliminarCama.rowCount === 0) {
                const error = "No se ha eliminado la cama por que no se ha entcontrado el registro en la base de datos"
                throw new Error(error)
            }
            if (resuelveEliminarCama.rowCount === 1) {
                const ok = {
                    "ok": "Se ha eliminado correctamente la cama de la habitacion",
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "eliminarConfiguracionDeAlojamiento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;

            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin espacios"
                throw new Error(error)
            }

            const validarApartamentoUID = `
                SELECT 
                *
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveValidarApartamentoUID = await conexion.query(validarApartamentoUID, [apartamentoIDV])
            if (resuelveValidarApartamentoUID.rowCount === 0) {
                const error = "No existe el perfil de configuracion del apartamento"
                throw new Error(error)
            }

            const eliminarConfiguracionDeApartamento = `
                DELETE FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveEliminarApartamento = await conexion.query(eliminarConfiguracionDeApartamento, [apartamentoIDV])
            if (resuelveEliminarApartamento.rowCount === 0) {
                const error = "No se ha eliminado la configuracion del apartamenro por que no se ha encontrado el registro en la base de datos"
                throw new Error(error)
            }
            if (resuelveEliminarApartamento.rowCount > 0) {
                const ok = {
                    "ok": "Se ha eliminado correctamente la configuracion de apartamento",
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "crearConfiguracionAlojamiento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV) || apartamentoIDV.length > 50) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios. No puede tener mas de 50 caracteres"
                throw new Error(error)
            }

            const validarIDV = `
                SELECT 
                "apartamentoUI"
                FROM apartamentos
                WHERE apartamento = $1
                `
            const resuelveValidarIDV = await conexion.query(validarIDV, [apartamentoIDV])
            if (resuelveValidarIDV.rowCount === 0) {
                const error = "No existe el apartamento como entidad. Primero crea la entidad y luego podras crear la configuirac√≠on"
                throw new Error(error)
            }

            const validarUnicidadConfigurativa = `
                SELECT 
                *
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveValidarUnicidadConfigurativa = await conexion.query(validarUnicidadConfigurativa, [apartamentoIDV])
            if (resuelveValidarUnicidadConfigurativa.rowCount > 0) {
                const error = "Ya existe una configuracion para la entidad del apartamento por favor selecciona otro apartamento como entidad"
                throw new Error(error)
            }

            const estadoInicial = "nodisponible"
            const crearConfiguracion = `
                INSERT INTO "configuracionApartamento"
                (
                "apartamentoIDV",
                "estadoConfiguracion"
                )
                VALUES 
                (
                $1,
                $2
                )
                RETURNING "apartamentoIDV"
                `
            const resuelveCrearConfiguracion = await conexion.query(crearConfiguracion, [apartamentoIDV, estadoInicial])
            if (resuelveCrearConfiguracion.rowCount === 0) {
                const error = "No se ha podido crear la nueva configuracion"
                throw new Error(error)
            }
            if (resuelveCrearConfiguracion.rowCount === 1) {
                const ok = {
                    ok: "Se ha creado correctament la nuevo configuracion del apartamento",
                    apartamentoIDV: resuelveCrearConfiguracion.rows[0].apartamentoIDV
                }
                salida.json(ok)
            }




        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "cambiarEstadoConfiguracionAlojamiento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const nuevoEstado = entrada.body.nuevoEstado
            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }


            if (!nuevoEstado || !filtroCadenaMinusculasSinEspacios.test(nuevoEstado)) {
                const error = "el campo 'nuevoEstado' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }

            const validarIDV = `
                SELECT 
                "estadoConfiguracion"
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveValidarIDV = await conexion.query(validarIDV, [apartamentoIDV])
            if (resuelveValidarIDV.rowCount === 0) {
                const error = "No existe el apartamento como entidad. Primero crea la entidad y luego podras crear la configuirac√≠on"
                throw new Error(error)
            }
            const estadoConfiguracionActual = resuelveValidarIDV.rows[0].estadoConfiguracion
            const validarEstadoIDV = `
                SELECT 
                *
                FROM "estadoApartamentos"
                WHERE estado = $1
                `
            const resuelveValidarEstadoIDV = await conexion.query(validarEstadoIDV, [nuevoEstado])
            if (resuelveValidarEstadoIDV.rowCount === 0) {
                const error = "Revisa el estado que has introducido por que no se conoce este estado para la configuracion del apartamento"
                throw new Error(error)
            }

            if (nuevoEstado === "disponible") {
                // Mirar que el apartamento tenga al menos una habitacion
                const consultaHabitaciones = `
                SELECT 
                habitacion,
                uid
                FROM "configuracionHabitacionesDelApartamento"
                WHERE apartamento = $1
                `
                const resuelveConsultaHabitaciones = await conexion.query(consultaHabitaciones, [apartamentoIDV])
                if (resuelveConsultaHabitaciones.rowCount === 0) {
                    const error = "No se puede poner en disponible esta configurac√≠on por que no es valida. Necesitas al menos una habitac√≠on en esta configurac√≠on y este apartamento no la tiene"
                    throw new Error(error)
                }
                // Mirar que todas las habitaciones tengan una cama asignada
                if (resuelveConsultaHabitaciones.rowCount > 0) {

                    const habitacionesSinCama = []
                    const habitacionesEnConfiguracion = resuelveConsultaHabitaciones.rows
                    for (const detalleHabitacion of habitacionesEnConfiguracion) {
                        const habitacionUID = detalleHabitacion.uid
                        const habitacionIDV = detalleHabitacion.habitacion

                        const resolucionHabitacionUI = await conexion.query(`SELECT "habitacionUI" FROM habitaciones WHERE habitacion = $1`, [habitacionIDV])
                        if (resolucionHabitacionUI.rowCount === 0) {
                            const error = "No existe el identificador del apartamentoIDV"
                            throw new Error(error)
                        }
                        const habitacionUI = resolucionHabitacionUI.rows[0].habitacionUI

                        const selectorHabitacionAsignada = await conexion.query(`SELECT "cama" FROM "configuracionCamasEnHabitacion" WHERE habitacion = $1`, [habitacionUID])
                        if (selectorHabitacionAsignada.rowCount === 0) {
                            habitacionesSinCama.push(habitacionUI)
                        }
                    }

                    if (habitacionesSinCama.length > 0) {
                        let funsionArray = habitacionesSinCama.join(", "); // Fusiona los elementos con comas
                        funsionArray = funsionArray.replace(/,([^,]*)$/, ' y $1');
                        const error = `No se puede establecer el estado disponible por que la configuracion no es valida. Por favor revisa las camas asignadas ne las habitaciones. En las habitaciones ${funsionArray} no hay una sola cama signada como opcion. Por favor asigna la camas`
                        throw new Error(error)

                    }

                }

                // Mira que tenga un perfil de precio creado y superiro 0
                const consultaPerfilPrecio = await conexion.query(`SELECT precio FROM "preciosApartamentos" WHERE apartamento = $1`, [apartamentoIDV])
                if (consultaPerfilPrecio.rowCount === 0) {
                    const error = "La configuracion no es valida y no se pued establecer en disponible por que esta configuracion no tiene asignado un perfil de precio para poderse publica con un precio y calcular los impuestos. Por favor establece un perfil de precio para esta configuracion"
                    throw new Error(error)
                }


            }


            const actualizarEstadoConfiguracion = `
            UPDATE "configuracionApartamento"
            SET "estadoConfiguracion" = $1
            WHERE "apartamentoIDV" = $2;
            `
            const clienteActualizarEstadoConfiguracion = await conexion.query(actualizarEstadoConfiguracion, [nuevoEstado, apartamentoIDV])
            if (clienteActualizarEstadoConfiguracion.rowCount === 0) {
                const error = "No se ha podido actualizar el estado de la configuracion del apartamento"
                throw new Error(error)
            }
            if (clienteActualizarEstadoConfiguracion.rowCount === 1) {
                const ok = {
                    ok: "Se ha actualizado el estado correctamente",
                    nuevoEstado: nuevoEstado
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "gestionImagenConfiguracionApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV
            const contenidoArchivo = entrada.body.contenidoArchivo

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }

            const filtroBase64 = /^[A-Za-z0-9+/=]+$/;

            if (typeof contenidoArchivo !== "string" || !filtroBase64.test(contenidoArchivo)) {
                const error = "El campo contenido archivo solo acepta archivos codificados en base64";
                throw new Error(error);
            }

            const esImagenPNG = (contenidoArchivo) => {
                const binarioMagicoPNG = Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]);

                // Decodifica la cadena base64 a un buffer
                const buffer = Buffer.from(contenidoArchivo, 'base64');

                // Compara los primeros 8 bytes del buffer con el binario m√°gico
                return buffer.subarray(0, 8).compare(binarioMagicoPNG) === 0;
            }

            if (esImagenPNG(contenidoArchivo)) {
                
            } else {
                const error = "Solo se acetan imagenes PNG codificadas en base64, se comprobara los bits iniciales";
                throw new Error(error);
            }

            const validarIDV = `
                SELECT 
                "estadoConfiguracion"
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveValidarIDV = await conexion.query(validarIDV, [apartamentoIDV])
            if (resuelveValidarIDV.rowCount === 0) {
                const error = "No existe el apartamento como entidad. Primero crea la entidad y luego podras crear la configuirac√≠on"
                throw new Error(error)
            }

            if (resuelveValidarIDV.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede actualizar la imagen de una configuracion de apartamento cuando esta disponbile,cambie el estado primero"
                throw new Error(error)
            }

            const actualizarImagenConfiguracion = `
            UPDATE "configuracionApartamento"
            SET imagen = $1
            WHERE "apartamentoIDV" = $2;
            `
            const resuelveActualizarImagenConfiguracion = await conexion.query(actualizarImagenConfiguracion, [contenidoArchivo, apartamentoIDV])
            if (resuelveActualizarImagenConfiguracion.rowCount === 0) {
                const error = "No se ha podido actualizar la imagen del apartmento reintentalo"
                throw new Error(error)
            }
            if (resuelveActualizarImagenConfiguracion.rowCount === 1) {
                const ok = {
                    ok: "Se ha actualizado imagen correctamnte",
                    imagen: String(contenidoArchivo)
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "eliminarImagenConfiguracionApartamento") {
        try {
            const apartamentoIDV = entrada.body.apartamentoIDV

            const filtroCadenaMinusculasSinEspacios = /^[a-z0-9]+$/;
            if (!apartamentoIDV || !filtroCadenaMinusculasSinEspacios.test(apartamentoIDV)) {
                const error = "el campo 'apartamentoIDV' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }

            const validarIDV = `
                SELECT 
                "estadoConfiguracion"
                FROM "configuracionApartamento"
                WHERE "apartamentoIDV" = $1
                `
            const resuelveValidarIDV = await conexion.query(validarIDV, [apartamentoIDV])
            if (resuelveValidarIDV.rowCount === 0) {
                const error = "No existe el apartamento como entidad. Primero crea la entidad y luego podras crear la configuirac√≠on"
                throw new Error(error)
            }

            if (resuelveValidarIDV.rows[0].estadoConfiguracion === "disponible") {
                const error = "No se puede actualizar la imagen de una configuracion de apartamento cuando esta disponbile,cambie el estado primero"
                throw new Error(error)
            }

            const actualizarImagenConfiguracion = `
            UPDATE "configuracionApartamento"
            SET imagen = NULL
            WHERE "apartamentoIDV" = $1;
            `
            const resuelveActualizarImagenConfiguracion = await conexion.query(actualizarImagenConfiguracion, [apartamentoIDV])
            if (resuelveActualizarImagenConfiguracion.rowCount === 0) {
                const error = "No se ha podido borrar la imagen del apartmento reintentalo"
                throw new Error(error)
            }
            if (resuelveActualizarImagenConfiguracion.rowCount === 1) {
                const ok = {
                    ok: "Se ha borrado imagen correctamnte"
                }
                salida.json(ok)
            }

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        }
    }
    if (transaccion === "buscarUsuarios") {
        try {

            const buscar = entrada.body.buscar;
            const nombreColumna = entrada.body.nombreColumna
            let sentidoColumna = entrada.body.sentidoColumna

            if (!buscar) {
                let error = "se tiene que espeficiar 'buscar' y lo que se desea buscar"
                throw new Error(error)
            }
            let Pagina = entrada.body.pagina
            Pagina = Pagina ? Pagina : 1
            if (typeof Pagina !== "number" || !Number.isInteger(Pagina) || Pagina <= 0) {
                const error = "En 'pagina' solo se aceptan numero enteros superiores a cero y positivos. Nada de decimales"
                throw new Error(error)
            }

            let condicionComplejaSQLOrdenarResultadosComoSegundaCondicion = ""
            let nombreColumnaSentidoUI
            let nombreColumnaUI
            if (nombreColumna) {
                if (nombreColumna !== "usuarioIDX" && nombreColumna !== "nombre" && nombreColumna !== "primerApellido" && nombreColumna !== "segundoApellido" && nombreColumna !== "pasaporte" && nombreColumna !== "email" && nombreColumna !== "telefono") {
                    const error = "En 'nombreColumna' solo se aceptan nombre, primerApellido, segundoApellido, pasaporte, uid"
                    throw new Error(error)
                }
                // OJO con la coma, OJO LA COMA ES IMPORTANTISMA!!!!!!!!
                //!!!!!!!
                if (sentidoColumna !== "descendente" && sentidoColumna !== "ascendente") {
                    sentidoColumna = "ascendente"
                }
                if (sentidoColumna == "ascendente") {
                    sentidoColumna = "ASC"
                    nombreColumnaSentidoUI = "ascendente"
                }
                if (sentidoColumna == "descendente") {
                    sentidoColumna = "DESC"
                    nombreColumnaSentidoUI = "descendente"
                }
                nombreColumnaUI = nombreColumna
                condicionComplejaSQLOrdenarResultadosComoSegundaCondicion = `,"${nombreColumna}" ${sentidoColumna}`
            }

            

            const terminoBuscar = buscar.split(" ")
            const terminosFormateados = []
            terminoBuscar.map((termino) => {
                const terminoFinal = "%" + termino + "%"
                terminosFormateados.push(terminoFinal)
            })
            const numeroPorPagina = 10
            const numeroPagina = Number((Pagina - 1) + "0");
            const consultaConstructor =
                `    
                SELECT "usuarioIDX", email, nombre, "primerApellido", "segundoApellido", pasaporte, telefono,
                COUNT(*) OVER() as "totalUsuarios"
                FROM "datosDeUsuario"
                WHERE  
                (
                    
                LOWER(COALESCE("usuarioIDX", '')) ILIKE ANY($1) OR
                LOWER(COALESCE(email, '')) ILIKE ANY($1) OR
                LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1) OR
                LOWER(COALESCE(telefono, '')) ILIKE ANY($1) OR


                LOWER(COALESCE(nombre, '')) ILIKE ANY($1) OR
                LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1) OR
                LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1) OR
                LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1)
                )
                ORDER BY
                (
                  CASE
                    WHEN (

                      (LOWER(COALESCE("usuarioIDX", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(email, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(telefono, '')) ILIKE ANY($1))::int +

                      (LOWER(COALESCE(nombre, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int
                    ) = 1 THEN 1
                    WHEN (


                      (LOWER(COALESCE("usuarioIDX", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(email, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(telefono, '')) ILIKE ANY($1))::int +

                      (LOWER(COALESCE(nombre, '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("primerApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE("segundoApellido", '')) ILIKE ANY($1))::int +
                      (LOWER(COALESCE(pasaporte, '')) ILIKE ANY($1))::int
                    ) = 3 THEN 3
                    ELSE 2
                  END
                ) DESC
                ${condicionComplejaSQLOrdenarResultadosComoSegundaCondicion}
            LIMIT $2 OFFSET $3;`

            const consultaUsuarios = await conexion.query(consultaConstructor, [terminosFormateados, numeroPorPagina, numeroPagina])
            const usuariosEncontrados = consultaUsuarios.rows
            const consultaConteoTotalFilas = usuariosEncontrados[0]?.totalUsuarios ? usuariosEncontrados[0].totalUsuarios : 0

            const totalPaginas = Math.ceil(consultaConteoTotalFilas / numeroPorPagina);
            const corretorNumeroPagina = String(numeroPagina).replace("0", "")
            const Respuesta = {
                transaccion: "buscarClientes",
                buscar: buscar,
                totalUsuarios: consultaConteoTotalFilas,
                nombreColumna: nombreColumna,
                paginasTotales: totalPaginas,
                pagina: Number(corretorNumeroPagina) + 1,
            }
            if (nombreColumna) {
                Respuesta.nombreColumna
                Respuesta.sentidoColumna = nombreColumnaSentidoUI
            }

            usuariosEncontrados.map((detallesUsuario) => {
                delete detallesUsuario.totalUsuarios
            })


            Respuesta.usuarios = usuariosEncontrados

            salida.json(Respuesta)
        } catch (error) {
            const detalleError = {
                "error": error.message,
            }
            return salida.json(detalleError)
        } finally {
            
        }

    }
    if (transaccion === "datosCuentaIDX") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const filtroCadena = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtroCadena.test(usuarioIDX)) {
                const error = "el campo 'usuarioIDX' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }

            const consultaDetallesUsuario = `
            SELECT 
            usuario, 
            rol,
            "estadoCuenta"
            FROM 
            usuarios
            WHERE 
            usuario = $1;`
            const resolverConsultaDetallesUsuario = await conexion.query(consultaDetallesUsuario, [usuarioIDX])
            if (resolverConsultaDetallesUsuario.rowCount === 0) {
                const error = "No existe ningun usuario con ese IDX"
                throw new Error(error)
            }

            const detallesCliente = resolverConsultaDetallesUsuario.rows[0]
            const ok = {
                "ok": detallesCliente
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "detallesUsuario") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const filtroCadena = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtroCadena.test(usuarioIDX)) {
                const error = "el campo 'usuarioIDX' solo puede ser letras min√∫sculas, numeros y sin pesacios"
                throw new Error(error)
            }


            const consultaDetallesUsuario = `
            SELECT 
            ddu."usuarioIDX", 
            ddu.nombre,
            ddu."primerApellido",
            ddu."segundoApellido",
            ddu.pasaporte,
            ddu.telefono,
            ddu.email,
            u.rol,
            u."estadoCuenta"
            FROM 
            "datosDeUsuario" ddu
            JOIN usuarios u ON ddu."usuarioIDX" = u.usuario
            WHERE 
            ddu."usuarioIDX" = $1;`

            const resolverConsultaDetallesUsuario = await conexion.query(consultaDetallesUsuario, [usuarioIDX])
            if (resolverConsultaDetallesUsuario.rowCount === 0) {
                const error = "No existe ningun usuario con ese IDX"
                throw new Error(error)
            }

            const detallesCliente = resolverConsultaDetallesUsuario.rows[0]
            const ok = {
                "ok": detallesCliente
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "actualizarDatosUsuarioDesdeAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let email = entrada.body.email

            const filtroCantidad = /^\d+\.\d{2}$/;
            const filtro_min√∫sculas_Mayusculas_numeros_espacios = /^[a-zA-Z0-9\s]+$/;
            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            const filtroNumeros = /^[0-9]+$/;

            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;

            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }

            if (nombre) {
                nombre = nombre.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(nombre)) {
                    const error = "El campo nombre solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }


            if (primerApellido) {
                primerApellido = primerApellido.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(primerApellido)) {
                    const error = "El campo primerApellido solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }

            if (segundoApellido) {
                segundoApellido = segundoApellido.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(segundoApellido)) {
                    const error = "El campo segundoApellido solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }

            if (pasaporte) {
                const filtroBase64 = /^[A-Za-z0-9+/]*={0,2}$/
                pasaporte = btoa(pasaporte);
                if (!filtroBase64.test(pasaporte)) {
                    const error = "Ha ocurrido un error en el formato del pasaporte."
                    throw new Error(error)
                }
            }

            if (telefono) {
                telefono = telefono.replaceAll("+", "00")
                telefono = telefono.replaceAll(" ", "")
                if (!filtroNumeros.test(telefono)) {
                    const error = "El campo telefono admite numeros y el simbolo + que sera sustituido por 00"
                    throw new Error(error)
                }
            }

            if (email) {
                const filtroEmail = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                if (!filtroEmail.test(email)) {
                    const error = "El campo email no tiene le formato correcto, por ejemplo usuario@servidor.zona"
                    throw new Error(error)
                }
                email = email.toLowerCase()
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarDatosUsuario2 = `
            UPDATE "datosDeUsuario"
            SET 
              "nombre" = COALESCE(NULLIF($1, ''), "nombre"),
              "primerApellido" = COALESCE(NULLIF($2, ''), "primerApellido"),
              "segundoApellido" = COALESCE(NULLIF($3, ''), "segundoApellido"),
              "pasaporte" = COALESCE(NULLIF($4, ''), "pasaporte"),
              "telefono" = COALESCE(NULLIF($5, ''), "telefono"),
              "email" = COALESCE(NULLIF($6, ''), "email")
            WHERE "usuarioIDX" = $7
            RETURNING 
              "nombre",
              "primerApellido",
              "segundoApellido",
              "pasaporte",
              "telefono",
              "email";
            
            
            `
            const datos = [
                nombre,
                primerApellido,
                segundoApellido,
                pasaporte,
                telefono,
                email,
                usuarioIDX,
            ]
            const resuelveActualizarDatosUsuario2 = await conexion.query(actualizarDatosUsuario2, datos)
            if (resuelveActualizarDatosUsuario2.rowCount === 1) {
                const datosActualizados = resuelveActualizarDatosUsuario2.rows
                datosActualizados[0].pasaporte = atob(datosActualizados[0].pasaporte);


                const ok = {
                    "ok": "El comportamiento se ha actualizado bien junto con los apartamentos dedicados",
                    datosActualizados: datosActualizados
                }
                salida.json(ok)

            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarIDXAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            let nuevoIDX = entrada.body.nuevoIDX

            const filtroCantidad = /^\d+\.\d{2}$/;
            const filtro_min√∫sculas_Mayusculas_numeros_espacios = /^[a-zA-Z0-9\s]+$/;
            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            const filtroNumeros = /^[0-9]+$/;
            const filtroCadenaSinEspacio = /^[a-z0-9]+$/;

            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }

            nuevoIDX = nuevoIDX.toLowerCase();
            if (!nuevoIDX || !filtro_min√∫sculas_numeros.test(nuevoIDX)) {
                const error = "El campo nuevoIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarIDX = `
            UPDATE usuarios
            SET 
                usuario = $2
            WHERE 
                usuario = $1
            RETURNING 
                usuario           
            `
            const datos = [
                usuarioIDX,
                nuevoIDX
            ]
            const resuelveActualizarIDX = await conexion.query(actualizarIDX, datos)
            if (resuelveActualizarIDX.rowCount === 1) {
                const IDXEstablecido = resuelveActualizarIDX.rows[0].usuario
                const ok = {
                    "ok": "Se ha actualizado el IDX correctamente",
                    usuarioIDX: IDXEstablecido
                }
                salida.json(ok)

            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarClaveUsuarioAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const claveNueva = entrada.body.claveNueva
            const claveNuevaDos = entrada.body.claveNuevaDos

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;


            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }
            

            if (claveNueva !== claveNuevaDos) {
                const error = "No has escrito dos veces la misma nueva contrasena"
                throw new Error(error)
            }
            const cryptoData = {
                sentido: "cifrar",
                clavePlana: claveNueva
            }

            const retorno = vitiniCrypto(cryptoData)
            const nuevaSal = retorno.nuevaSal
            const hashCreado = retorno.hashCreado


            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarClave = `
            UPDATE usuarios
            SET 
                clave = $1,
                sal = $2
            WHERE 
                usuario = $3
            `
            const datos = [
                hashCreado,
                nuevaSal,
                usuarioIDX
            ]
            const resuelveActualizarClave = await conexion.query(actualizarClave, datos)
            if (resuelveActualizarClave.rowCount === 1) {
                const ok = {
                    "ok": "Se ha actualizado la nueva clave"
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarEstadoCuentaDesdeAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const nuevoEstado = entrada.body.nuevoEstado

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }

            if (nuevoEstado !== "activado" && nuevoEstado !== "desactivado") {
                const error = "El campo nuevoEstado solo puede ser activado o desactivado"
                throw new Error(error)
            }


            // validar existencia de contrasena
            const validarClave = `
            SELECT 
            clave
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveValidarClave = await conexion.query(validarClave, [usuarioIDX])
            if (!resuelveValidarClave.rows[0].clave) {
                const error = "No se puede activar una cuenta que carece de contrasena, por favor establece una contrasena primero"
                throw new Error(error)
            }



            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarEstadoCuenta = `
            UPDATE usuarios
            SET 
                "estadoCuenta" = $1
            WHERE 
                usuario = $2
            `
            const datos = [
                nuevoEstado,
                usuarioIDX
            ]
            const resuelveEstadoCuenta = await conexion.query(actualizarEstadoCuenta, datos)
            if (resuelveEstadoCuenta.rowCount === 0) {
                const error = "No se encuentra el usuario"
                throw new Error(error)
            }
            if (resuelveEstadoCuenta.rowCount === 1) {

                if (nuevoEstado !== "desactivado") {
                    const cerrarSessiones = `
                    DELETE FROM sessiones
                    WHERE sess->> 'usuario' = $1;
                    `
                    await conexion.query(cerrarSessiones, [usuarioIDX])

                }










                const ok = {
                    ok: "Se ha actualizado el estado de la cuenta",
                    estadoCuenta: nuevoEstado
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "eliminarCuentaDesdeAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            // Validar si es un usuario administrador
            const validarTipoCuenta = `
            SELECT 
            rol
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveValidarTipoCuenta = await conexion.query(validarTipoCuenta, [usuarioIDX])
            const rol = resuelveValidarTipoCuenta.rows[0].rol
            const rolAdministrador = "administrador"

            if (rol === rolAdministrador) {
                const validarUltimoAdministrador = `
                SELECT 
                rol
                FROM usuarios
                WHERE rol = $1;
                `
                const resuelValidarUltimoAdministrador = await conexion.query(validarUltimoAdministrador, [rolAdministrador])
                if (resuelValidarUltimoAdministrador.rowCount === 1) {
                    const error = "No se puede eliminar esta cuenta por que es la unica cuenta adminsitradora existente. Si quieres eliminar esta cuenta tienes que crear otra cuenta administradora. Por que en el sistema debe de existir al menos una cuenta adminitrador"
                    throw new Error(error)
                }
            }


            const cerrarSessiones = `
            DELETE FROM sessiones
            WHERE sess->> 'usuario' = $1;
            `
            await conexion.query(cerrarSessiones, [usuarioIDX])



            const eliminarCuenta = `
            DELETE FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveEliminarCuenta = await conexion.query(eliminarCuenta, [usuarioIDX])
            if (resuelveEliminarCuenta.rowCount === 0) {
                const error = "No se encuentra el usuario"
                throw new Error(error)
            }
            if (resuelveEliminarCuenta.rowCount === 1) {
                const ok = {
                    ok: "Se ha eliminado correctamente la cuenta de usuario",
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "crearCuentaDesdeAdministracion") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const rol = entrada.body.rol

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros y nada mas"
                throw new Error(error)
            }

            if (usuarioIDX === "crear" || usuarioIDX === "buscador") {
                const error = "El nombre de usuario no esta disponbile, escoge otro"
                throw new Error(error)
            }

            if (!rol) {
                const error = "Selecciona un rol para la nueva cuenta de usuario"
                throw new Error(error)
            }

            if (!filtro_min√∫sculas_numeros.test(rol)) {
                const error = "El campo rol solo admite min√∫sculas y numeros y nada mas"
                throw new Error(error)
            }

            // validar rol
            const validarRol = `
            SELECT 
            rol
            FROM "usuariosRoles"
            WHERE rol = $1
            `
            const resuelveValidarRol = await conexion.query(validarRol, [rol])
            if (resuelveValidarRol.rowCount === 0) {
                const error = "No existe el rol, revis el rol introducido"
                throw new Error(error)
            }


            // comporbar que no exista la el usuario
            const validarNuevoUsuario = `
            SELECT 
            usuario
            FROM usuarios
            WHERE usuario = $1
            `
            const resuelveValidarNuevoUsaurio = await conexion.query(validarNuevoUsuario, [usuarioIDX])
            if (resuelveValidarNuevoUsaurio.rowCount > 0) {
                const error = "El nombre de usuario no esta disponbile, escoge otro"
                throw new Error(error)
            }

            const estadoCuenta = "desactivado"
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const crearNuevoUsuario = `
            INSERT INTO usuarios
            (
            usuario,
            rol,
            "estadoCuenta"
            )
            VALUES 
            ($1, $2,$3)
            RETURNING
            usuario
            `
            const datosNuevoUsuario = [
                usuarioIDX,
                rol,
                estadoCuenta
            ]
            const resuelveCrearNuevoUsuario = await conexion.query(crearNuevoUsuario, datosNuevoUsuario)
            if (resuelveCrearNuevoUsuario.rowCount === 0) {
                const error = "No se ha insertado el nuevo usuario en la base de datos"
                throw new Error(error)
            }
            const crearNuevosDatosUsuario = `
            INSERT INTO "datosDeUsuario"
            (
            "usuarioIDX"
            )
            VALUES 
            ($1)
            `
            const resuelveCrearNuevosDatosUsuario = await conexion.query(crearNuevosDatosUsuario, [usuarioIDX])
            if (resuelveCrearNuevosDatosUsuario.rowCount === 0) {
                const error = "No se ha insertado los datos del nuevo usuario"
                throw new Error(error)
            }
            const ok = {
                "ok": "Se ha creado el nuevo usuario",
                "usuarioIDX": resuelveCrearNuevoUsuario.rows[0].usuario
            }
            salida.json(ok)

            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "obtenerSessionesActivasDesdeMiCasa") {
        try {
            const session = entrada.session
            const usuarioIDX = entrada.session.usuario
            if (!session || !usuarioIDX) {
                const error = "Tienes que identificarte para ver las sessiones activas de tu cuenta"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            // validar rol
            const consultaSessionesActivas = `
            SELECT 
            sid AS "sessionIDX",
            expire::text AS "caducidadUTC",
            sess->> 'ip' AS ip
            FROM sessiones
            WHERE sess->> 'usuario' = $1;
            `
            const resuelveConsultaSessionesActivas = await conexion.query(consultaSessionesActivas, [usuarioIDX])
            if (resuelveConsultaSessionesActivas.rowCount === 0) {
                const error = "No existe ninguna session activa para este usuario"
                throw new Error(error)
            }


            const cambiarPosicionMesDia = (fecha) => {
                const partes = fecha.split("T");
                if (partes.length === 2) {
                    const fechaPartes = partes[0].split("-");
                    if (fechaPartes.length === 3) {
                        const anio = fechaPartes[0];
                        const dia = fechaPartes[1];
                        const mes = fechaPartes[2];

                        const horaMinSeg = partes[1];

                        // Formatear la fecha en el formato deseado YYYY-MM-DDTHH:mm:ss.000Z
                        const fechaTransformada = `${anio}-${mes}-${dia}T${horaMinSeg}`;
                        return fechaTransformada;
                    }
                }
                return "Formato de fecha incorrecto.";
            }


            const calcularTiempoRestante = (fechaObjetivo) => {
                const ahora = new Date();
                const diferencia = fechaObjetivo - ahora;
                
                

                if (diferencia <= 0) {
                    return "Ya ha pasado la fecha objetivo";
                }

                const segundosTotales = Math.floor(diferencia / 1000); // Total de segundos
                const segundos = segundosTotales % 60;
                const minutosTotales = Math.floor(segundosTotales / 60); // Total de minutos
                const minutos = minutosTotales % 60;
                const horasTotales = Math.floor(minutosTotales / 60); // Total de horas
                const horas = horasTotales % 24;
                const dias = Math.floor(horasTotales / 24); // Total de d√≠as

                const resultado = {
                    dias: dias,
                    horas: horas,
                    minutos: minutos,
                    segundos: segundos,
                    segundosTotales: segundosTotales
                }
                return resultado;
            };

            const zonaHorariaEspana = "Europe/Madrid";


            const sessionesActivas = resuelveConsultaSessionesActivas.rows
            sessionesActivas.map((detallesSession) => {
                const caducidad = new Date(detallesSession.caducidadUTC);

                let fechaFormateada = cambiarPosicionMesDia(caducidad.toISOString());
                fechaFormateada = new Date(fechaFormateada)
                detallesSession.caducidadUTC = fechaFormateada
                const fechaEspana = fechaFormateada.toLocaleString("es-ES", { timeZone: zonaHorariaEspana });
                detallesSession.caducidadESP = fechaEspana
                const tiempoRestante = calcularTiempoRestante(fechaFormateada);
                detallesSession.tiempoRestante = tiempoRestante

                let ipNoFormateada = detallesSession.ip
                ipNoFormateada = ipNoFormateada.split(":")
                const ipFormateada = ipNoFormateada[ipNoFormateada.length - 1]
                detallesSession.ip = ipFormateada


            })
            const fechaActual = new Date();
            
            const ok = {
                ok: "Sessiones activas",
                sessionIDX: entrada.sessionID,
                sessionesActivas: sessionesActivas
            }
            salida.json(ok)

            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "cerrarSessionSelectivamenteDesdeMiCasa") {
        try {
            const usuarioIDX = entrada.session.usuario
            if (!usuarioIDX) {
                const error = "Tienes que identificarte para poder cerrar sessiones"
                //  throw new Error(error)
            }
            //  await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const tipoOperacion = entrada.body.tipoOperacion
            if (tipoOperacion !== "cerrarUna" && tipoOperacion !== "todasMenosActual") {
                const error = "El campo tipoOperacion necesita especificar si es cerrarUna o todasMenosUna"
                throw new Error(error)
            }

            if (tipoOperacion === "cerrarUna") {
                const sessionIDX = entrada.body.sessionIDX
                const filtroSessionIDX = /^[a-zA-Z0-9_-]+$/
                if (!sessionIDX || !filtroSessionIDX.test(sessionIDX)) {
                    const error = "El campo sessionIDX solo admite min√∫sculas, may√∫sculas, numeros y nada mas"
                    throw new Error(error)
                }

                const cerrarSessionSelectivamente = `
                DELETE FROM sessiones
                WHERE sid = $1 AND sess->> 'usuario' = $2;
                `
                const resuelveCerrarSessionSelectivamente = await conexion.query(cerrarSessionSelectivamente, [sessionIDX, usuarioIDX])
                if (resuelveCerrarSessionSelectivamente.rowCount === 0) {
                    const error = "No existe la session que intentas cerrar"
                    throw new Error(error)
                }
                if (resuelveCerrarSessionSelectivamente.rowCount === 1) {
                    const ok = {
                        ok: "Se ha cerrado correctament la session",
                        sessionAtual: entrada.sessionID
                    }
                    salida.json(ok)
                }
            }


            if (tipoOperacion === "todasMenosActual") {
                const sessionIDXActual = entrada.sessionID
                const cerrarSessionTodasMenosActual = `
                DELETE FROM sessiones
                WHERE sid != $1 AND sess->> 'usuario' = $2;
                `
                const resuelveCerrarSessionTodasMenosActual = await conexion.query(cerrarSessionTodasMenosActual, [sessionIDXActual, usuarioIDX])
                if (resuelveCerrarSessionTodasMenosActual.rowCount === 0) {
                    const error = "No se ha encontrado ninguna session que cerrar"
                    throw new Error(error)
                }
                if (resuelveCerrarSessionTodasMenosActual.rowCount > 0) {
                    const ok = {
                        ok: "Se ha cerrado correctament el resto de sessiones",
                        sessionAtual: entrada.sessionID
                    }
                    salida.json(ok)
                }




            }




            // await conexion.query('COMMIT');
        } catch (errorCapturado) {
            // await conexion.query('ROLLBACK');

            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "actualizarClaveUsuarioDesdeMicasa") {
        try {
            const usuarioIDX = entrada.session.usuario

            const claveActual = entrada.body.claveActual
            const claveNueva = entrada.body.claveNueva
            const claveConfirmada = entrada.body.claveConfirmada

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;

            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }
            if (!claveActual) {
                const error = "No has escrito tu contrasena actual en el campo correspondiente"
                throw new Error(error)
            }
            if (!claveNueva) {
                const error = "Escribe la nueva contrasena en el campo correspondiente"
                throw new Error(error)
            }
            if (!claveConfirmada) {
                const error = "Confirma la nueva contrasena antes de cambiarla"
                throw new Error(error)
            }
            
            if (claveNueva !== claveConfirmada) {
                const error = "No has escrito dos veces la misma nueva contrasena, revisa las claves que has escrito y cerciorate que ambas claves nueva son iguales"
                throw new Error(error)
            }

            if (claveNueva === claveActual) {
                const error = "Has escrito una clave nueva que es la misma que la actual. Por favor revisa lo campos."
                throw new Error(error)
            }

            //Obtener claveActual guardada, el hash
            const obtenerClaveActualHASH = `
            SELECT 
            clave,
            sal
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveObtenerClaveActualHASH = await conexion.query(obtenerClaveActualHASH, [usuarioIDX])
            if (resuelveObtenerClaveActualHASH.rowCount === 0) {
                const error = "No existe el usuarios"
                throw new Error(error)
            }

            const claveActualHASH = resuelveObtenerClaveActualHASH.rows[0].clave
            const sal = resuelveObtenerClaveActualHASH.rows[0].sal

            const metadatos = {
                sentido: "comparar",
                clavePlana: claveActual,
                sal: sal,
                claveHash: claveActualHASH
            }
            const controlClave = vitiniCrypto(metadatos)
            if (!controlClave) {
                const error = "Revisa la contrasena actual que has escrito por que no es correcta por lo tanto no se puede cambiar la contrasena"
                throw new Error(error)
            }

            const cryptoData = {
                sentido: "cifrar",
                clavePlana: claveNueva
            }

            const retorno = vitiniCrypto(cryptoData)
            const nuevaSal = retorno.nuevaSal
            const hashCreado = retorno.hashCreado


            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarClave = `
            UPDATE usuarios
            SET 
                clave = $1,
                sal = $2
            WHERE 
                usuario = $3
            `
            const datos = [
                hashCreado,
                nuevaSal,
                usuarioIDX
            ]
            const resuelveActualizarClave = await conexion.query(actualizarClave, datos)
            if (resuelveActualizarClave.rowCount === 1) {
                const ok = {
                    "ok": "Se ha actualizado la nueva contrasena."
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "eliminarCuentaDesdeMiCasa") {
        try {
            const usuarioIDX = entrada.session.usuario
            const clave = entrada.body.clave

            if (!usuarioIDX) {
                const error = "Tienes que estar identificado"
                throw new Error(error)
            }
            if (!clave) {
                const error = "No has escrito tu contrasena. Es necesaria para eliminar tu cuenta"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const obtenerClaveActualHASH = `
            SELECT 
            clave,
            sal
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveObtenerClaveActualHASH = await conexion.query(obtenerClaveActualHASH, [usuarioIDX])
            if (resuelveObtenerClaveActualHASH.rowCount === 0) {
                const error = "No existe el usuarios"
                throw new Error(error)
            }

            const claveActualHASH = resuelveObtenerClaveActualHASH.rows[0].clave
            const sal = resuelveObtenerClaveActualHASH.rows[0].sal

            const metadatos = {
                sentido: "comparar",
                clavePlana: clave,
                sal: sal,
                claveHash: claveActualHASH
            }
            const controlClave = vitiniCrypto(metadatos)
            if (!controlClave) {
                const error = "Revisa la contrasena actual que has escrito por que no es correcta por lo tanto no se puede eliminar tu cuenta"
                throw new Error(error)
            }

            const eliminarCuenta = `
            DELETE FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveEliminarCuenta = await conexion.query(eliminarCuenta, [usuarioIDX])
            if (resuelveEliminarCuenta.rowCount === 1) {
                const cerrarSessiones = `
                DELETE FROM sessiones
                WHERE sess->> 'usuario' = $1;
                `
                await conexion.query(cerrarSessiones, [usuarioIDX])
                const ok = {
                    ok: "Se ha eliminado correctamente la cuenta"
                };
                salida.json(ok)
            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "crearCuentaDesdeMiCasa") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const email = entrada.body.email
            const claveNueva = entrada.body.claveNueva
            const claveConfirmada = entrada.body.claveConfirmada

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;
            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros y nada mas"
                throw new Error(error)
            }
            const filtroCorreoElectronico = /^[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/;
            if (!email || !filtroCorreoElectronico.test(email)) {
                const error = "el campo de correo electronico no cumple con el formato esperado"
                throw new Error(error)
            }

            if (!claveNueva) {
                const error = "Escribe tu contrasena, no has escrito tu contrasena"
                throw new Error(error)
            }

            if (!claveConfirmada) {
                const error = "Vuelve a escribir tu contrasena de nuevo"
                throw new Error(error)
            }
            if (claveNueva !== claveConfirmada) {
                const error = "La contrasenas no coinciden, revisa la contrasenas escritas"
                throw new Error(error)
            }
            if (usuarioIDX === "crear" || usuarioIDX === "buscador") {
                const error = "El nombre de usuario no esta disponbile, escoge otro"
                throw new Error(error)
            }
            if (claveNueva !== usuarioIDX) {
                const error = "El nombre de usuario y la contrasena no pueden ser iguales"
                throw new Error(error)
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const validarNuevoUsuario = `
            SELECT 
            usuario
            FROM usuarios
            WHERE usuario = $1
            `
            const resuelveValidarNuevoUsaurio = await conexion.query(validarNuevoUsuario, [usuarioIDX])
            if (resuelveValidarNuevoUsaurio.rowCount > 0) {
                const error = "El nombre de usuario no esta disponbile, escoge otro"
                throw new Error(error)
            }


            const cryptoData = {
                sentido: "cifrar",
                clavePlana: claveNueva
            }

            const retorno = vitiniCrypto(cryptoData)
            const nuevaSal = retorno.nuevaSal
            const hashCreado = retorno.hashCreado


            const estadoCuenta = "activado"
            const rol = "cliente"
            const crearNuevoUsuario = `
            INSERT INTO usuarios
            (
            usuario,
            rol,
            "estadoCuenta",
            sal,
            clave
            )
            VALUES 
            ($1, $2, $3, $4, $5)
            RETURNING
            usuario
            `
            const datosNuevoUsuario = [
                usuarioIDX,
                rol,
                estadoCuenta,
                nuevaSal,
                hashCreado
            ]
            const resuelveCrearNuevoUsuario = await conexion.query(crearNuevoUsuario, datosNuevoUsuario)
            if (resuelveCrearNuevoUsuario.rowCount === 0) {
                const error = "No se ha insertado el nuevo usuario en la base de datos"
                throw new Error(error)
            }
            const crearNuevosDatosUsuario = `
            INSERT INTO "datosDeUsuario"
            (
            "usuarioIDX",
            email
            )
            VALUES 
            ($1, $2)
            `
            const resuelveCrearNuevosDatosUsuario = await conexion.query(crearNuevosDatosUsuario, [usuarioIDX, email])
            if (resuelveCrearNuevosDatosUsuario.rowCount === 0) {
                const error = "No se ha insertado los datos del nuevo usuario"
                throw new Error(error)
            }
            const ok = {
                "ok": "Se ha creado el nuevo usuario",
                "usuarioIDX": resuelveCrearNuevoUsuario.rows[0].usuario
            }
            salida.json(ok)
            await conexion.query('COMMIT');
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK');

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "obtenerRoles") {
        try {
            const consultaRoles = `
            SELECT 
            rol, 
            "rolUI"
            FROM 
            "usuariosRoles";`
            const resolverConsultaRoles = await conexion.query(consultaRoles)
            if (resolverConsultaRoles.rowCount === 0) {
                const error = "No existe ning√∫n rol"
                throw new Error(error)
            }
            const roles = resolverConsultaRoles.rows
            const ok = {
                "ok": roles
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "actualizarRolCuenta") {
        try {
            const usuarioIDX = entrada.body.usuarioIDX
            const nuevoRol = entrada.body.nuevoRol

            const filtro_min√∫sculas_numeros = /^[a-z0-9]+$/;

            if (!usuarioIDX || !filtro_min√∫sculas_numeros.test(usuarioIDX)) {
                const error = "El campo usuarioIDX solo admite min√∫sculas y numeros"
                throw new Error(error)
            }
            if (!nuevoRol || !filtro_min√∫sculas_numeros.test(nuevoRol)) {
                const error = "El rolIDX solo admine min√∫sculas y numeros y nada mas"
                throw new Error(error)
            }
            await conexion.query('BEGIN'); // Inicio de la transacci√≥n

            // Validas usaurios
            const validarUsuario = `
            SELECT 
            usuario
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveValidarUsuario = await conexion.query(validarUsuario, [usuarioIDX])
            if (resuelveValidarUsuario.rowCount === 0) {
                const error = "No existe el usuarios"
                throw new Error(error)
            }

            // Validar rol
            const validarRol = `
            SELECT 
            "rolUI",
            rol
            FROM "usuariosRoles"
            WHERE rol = $1;
            `
            const resuelveValidarRol = await conexion.query(validarRol, [nuevoRol])
            if (resuelveValidarRol.rowCount === 0) {
                const error = "No existe el rol"
                throw new Error(error)
            }
            const rolUI = resuelveValidarRol.rows[0].rolUI
            const rolIDV = resuelveValidarRol.rows[0].rol

            // Validar que el usuario que hace el cambio sea administrador
            const IDXActor = entrada.session.usuario
            const validarIDXActor = `
            SELECT 
            rol
            FROM usuarios
            WHERE usuario = $1;
            `
            const resuelveValidarIDXActor = await conexion.query(validarIDXActor, [IDXActor])
            if (resuelveValidarIDXActor.rowCount === 0) {
                const error = "No existe el usuario de origen que intenta realizar esta operacion."
                throw new Error(error)
            }

            const rolActor = resuelveValidarIDXActor.rows[0].rol
            if (rolActor !== "administrador") {
                const error = "No estas autorizado a realizar un cambio de rol. Solo los Administradores pueden realizar cambios de rol"
                throw new Error(error)

            }

            const actualizarRol = `
            UPDATE
            usuarios
            SET
            rol = $1
            WHERE
            usuario = $2;
            `
            const resuelveActualizarRol = await conexion.query(actualizarRol, [nuevoRol, usuarioIDX])
            if (resuelveActualizarRol.rowCount === 0) {
                const error = "No se ha podido actualizar el rol de este usuario"
                throw new Error(error)
            }

            const ok = {
                ok: "Se ha actualizado el rol en esta cuenta",
                rolIDV: rolIDV,
                rolUI: rolUI
            }
            salida.json(ok)

            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error

            let error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }
    if (transaccion === "datosPersonalesDesdeMiCasa") {
        try {
            const usuarioIDX = entrada.session.usuario
            if (!usuarioIDX) {
                const error = "Necesitar identiifcarte para ver tus datos personales"
                throw new Error(error)
            }

            const consultaDetallesUsuario = `
            SELECT 
            ddu."usuarioIDX", 
            ddu.nombre,
            ddu."primerApellido",
            ddu."segundoApellido",
            ddu.pasaporte,
            ddu.telefono,
            ddu.email,
            u.rol,
            u."estadoCuenta"
            FROM 
            "datosDeUsuario" ddu
            JOIN usuarios u ON ddu."usuarioIDX" = u.usuario
            WHERE 
            ddu."usuarioIDX" = $1;`

            const resolverConsultaDetallesUsuario = await conexion.query(consultaDetallesUsuario, [usuarioIDX])
            if (resolverConsultaDetallesUsuario.rowCount === 0) {
                const error = "No existe ningun usuario con ese IDX"
                throw new Error(error)
            }

            const detallesCliente = resolverConsultaDetallesUsuario.rows[0]
            const ok = {
                "ok": detallesCliente
            }
            salida.json(ok)

        } catch (errorCapturado) {
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }

    }
    if (transaccion === "actualizarDatosUsuarioDesdeMiCasa") {
        try {
            const usuarioIDX = entrada.session.usuario
            let nombre = entrada.body.nombre
            let primerApellido = entrada.body.primerApellido
            let segundoApellido = entrada.body.segundoApellido
            let pasaporte = entrada.body.pasaporte
            let telefono = entrada.body.telefono
            let email = entrada.body.email

            const filtro_min√∫sculas_Mayusculas_numeros_espacios = /^[a-zA-Z0-9\s]+$/;
            const filtroNumeros = /^[0-9]+$/;

            if (!usuarioIDX) {
                const error = "Identificate para actualizar los datos personales de tu cuenta"
                throw new Error(error)
            }

            if (nombre) {
                nombre = nombre.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(nombre)) {
                    const error = "El campo nombre solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }

            if (primerApellido) {
                primerApellido = primerApellido.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(primerApellido)) {
                    const error = "El campo primerApellido solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }

            if (segundoApellido) {
                segundoApellido = segundoApellido.toUpperCase();
                if (!filtro_min√∫sculas_Mayusculas_numeros_espacios.test(segundoApellido)) {
                    const error = "El campo segundoApellido solo admite may√∫sculas, min√∫sculas, numeros y espacios"
                    throw new Error(error)
                }
            }

            if (pasaporte) {
                const filtroBase64 = /^[A-Za-z0-9+/]*={0,2}$/
                pasaporte = btoa(pasaporte);
                if (!filtroBase64.test(pasaporte)) {
                    const error = "Ha ocurrido un error en el formato del pasaporte."
                    throw new Error(error)
                }
            }

            if (telefono) {
                telefono = telefono.replaceAll("+", "00")
                telefono = telefono.replaceAll(" ", "")
                if (!filtroNumeros.test(telefono)) {
                    const error = "El campo telefono admite numeros y el simbolo + que sera sustituido por 00"
                    throw new Error(error)
                }
            }

            if (email) {
                const filtroEmail = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                if (!filtroEmail.test(email)) {
                    const error = "El campo email no tiene le formato correcto, por ejemplo usuario@servidor.zona"
                    throw new Error(error)
                }
                email = email.toLowerCase()
            }

            await conexion.query('BEGIN'); // Inicio de la transacci√≥n
            const actualizarDatosUsuario = `
            UPDATE "datosDeUsuario"
            SET 
              "nombre" = COALESCE(NULLIF($1, ''), "nombre"),
              "primerApellido" = COALESCE(NULLIF($2, ''), "primerApellido"),
              "segundoApellido" = COALESCE(NULLIF($3, ''), "segundoApellido"),
              "pasaporte" = COALESCE(NULLIF($4, ''), "pasaporte"),
              "telefono" = COALESCE(NULLIF($5, ''), "telefono"),
              "email" = COALESCE(NULLIF($6, ''), "email")
            WHERE "usuarioIDX" = $7
            RETURNING 
              "nombre",
              "primerApellido",
              "segundoApellido",
              "pasaporte",
              "telefono",
              "email";            
            `
            const datos = [
                nombre,
                primerApellido,
                segundoApellido,
                pasaporte,
                telefono,
                email,
                usuarioIDX,
            ]

            const resuelveActualizarDatosUsuario = await conexion.query(actualizarDatosUsuario, datos)

            const esBase64 = (cadena) => {
                try {
                    return btoa(atob(cadena)) === cadena;
                } catch (err) {
                    return false;
                }
            }

            if (resuelveActualizarDatosUsuario.rowCount === 1) {
                const datosActualizados = resuelveActualizarDatosUsuario.rows
                const pasaporteAlmacenado = datosActualizados[0].pasaporte
                if (esBase64(pasaporteAlmacenado)) {
                    // Si es una cadena en base64, decodificarla
                    const cadenaDecodificada = atob(pasaporteAlmacenado);
                    datosActualizados[0].pasaporte = cadenaDecodificada;
                }

                const ok = {
                    "ok": "El comportamiento se ha actualizado bien junto con los apartamentos dedicados",
                    datosActualizados: datosActualizados
                }
                salida.json(ok)
            }
            await conexion.query('COMMIT'); // Confirmar la transacci√≥n
        } catch (errorCapturado) {
            await conexion.query('ROLLBACK'); // Revertir la transacci√≥n en caso de error
            const error = {
                "error": errorCapturado.message
            }
            salida.json(error)
        } finally {
            
        }
    }